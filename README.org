#+TITLE: Computing with Register Machines
So far we have learned the meanings of procedures using a succession of models
of evaluation: The substitution model, the environment model, the metacircular
evaluator. But none of these evaluation model did not dispel how the evaluation
of subexpression manages to return a value to the expression that uses this
value, nor does the evaluator explain how some recursive procedures generate
iterative processes.

In this chapter we are going to learn so called "linking" process, which link
the callee and caller with the returning value.

Further more, as it is the last chapter of this text book, this chapter
organized as the canonical structure in that we've learned so far: By wishful
thinking,
1. Design or specify what we want to implement or the behavior that we want from
   the application -- section 5.1;
2. implement the high level procedures using the low level procedure's
   specifications, by wishful thinking -- we haven't yet implemented the low
   level procedure but we can specify what we want from the perspective of high
   level procedure implementor --, section 5.2;
3. then we implement the very low procedures using only the primitives --
   section 5.3;
4. a variation or application of what we implemented -- section 5.4;
5. deep dive what we have assumed as primitive or "as given" -- section 5.5;


So by learning through this chapter, we can learn not just the contents it
contains but also the general strategy to embody the ideas into the real world
program. This general strategy would be applied to any of design process one
would encounter with when try to create something that isn't yet in the world
that solves the given specific kind of problem.

We'd better to be engraved in our mind the general strategy through out this chapter.

* Designing Register Machines
*** Exercise 5.1
I've drawn this with my digital paper. But you should be careful that our switch
is not just simple switch, which we probably used in electrical experiment in
middle or like that age, but a switch that has memorizing feature so that one
can clobber the contents of given register.

So we can use the result signal or value of operator -- multiply, addition, etc.
-- to clobber the operand register directly without intervening the
intermediate register.

It is not deducible from the contents before this exercise, that is, from the
=gcd= machine; but we can do from the later example machines. It is quite unfair
they did not specify what feature the switches possesses exactly -- only in a
context that even not appear until this exercise.

** A Language for Describing Register Machines
So far our language for the design of machines was diagrams -- one for data
paths and one for controller; now through this chapter we extends our tools for
designing register machines to more powerful programming like language that we
can simulate easily by restricting the freedom of design -- only the finite
number of instructions can be used in the designing.

*** Exercise 5.2
#+BEGIN_SRC scheme
(controller
    (assign p (const 1))
    (assign c (const 1))
 test-c
    (test (op >) (reg c) (reg n))
    (branch (label fact-done))
    (assign p (op *) (reg p) (reg c))
    (assign c (op +) (reg c) (const 1))
    (goto (label test-c))
 fact-done)
#+END_SRC
** Abstraction in Machine Design
*** Exercise 5.3
The first version that assume the internal definitions are available as
primitive procedure in the =sqrt-iter=.
#+BEGIN_SRC scheme
(controller
    (assign g (const 1.0))
 test-g
    (test (op g-e?) (reg g))
    (branch (label sqrt-done))
    (assign g (op imp) (reg g))
    (goto (label test-g))
 sqrt-done)
#+END_SRC

Note that we haven't even mentioned the =x= in above controller description.

Now we are going to implement the second task -- unwind the internal definitions
into the primitive ones.

#+BEGIN_SRC scheme
;;; Version 2
;;; middle level procedures

;;;; good-enough?
(assign s-q (op sq) (reg g))
(assign d (op -) (reg s-q) (reg x))
(assign ad (op abs) (reg d))
(test (op <) (reg ad) (const 0.001))

;;;; improve
(assign x/g (op /) (reg x) (reg g))
(assign imped (op avg) (reg g) (reg x/g))

;;; low level procedures
;;;; square
(assign cp (reg g))
(assign squared (op *) (reg cp) (reg g))

;;;; abs
(test (op <) (reg d) (const 0))
(branch (label abs-fetch))
(assign absed (op neg) (reg d))
(goto (label abs-done))
abs-fetch
(assign absed (reg d))
abs-done

;;;; average
(assign s (op +) (reg x) (reg g))
(assing aved (op /) (reg s) (const 2))

;;; And linking all together
(controller
    (assign g (const 1.0))
 test-g
;;; good-enough? {
    ;; sq {
    (assign d (reg g))
    (assign t (op *) (reg d) (reg g))
    ;; }
    (assign d (op -) (reg t) (reg x))
    ;; abs {
    (test (op <) (reg d) (const 0))
    (branch (label abs-fetch))
    (assign t (op neg) (reg d))
    (goto (label abs-done))
 abs-fetch
    (assign t (reg d))
 abs-done
    ;; }
    (test (op <) (reg t) (const 0.001))
;;; }
    (branch (label sqrt-done))
;;; improve {
    (assign d (op /) (reg x) (reg g))
    ;; average {
    (assign t (op +) (reg x) (reg g))
    (assing g (op /) (reg t) (const 2))
    ;; }
;;; }
    (goto (label test-g))
 sqrt-done)
#+END_SRC

For the data paths diagrams, I've drawn in digital paper.
** Subroutines
** Using a Stack to Implement Recursion
*** Exercise 5.4
**** a.
#+BEGIN_SRC scheme
(controller
    (assign continue (label expt-done))
 expt-loop
    (test (op =) (reg n) (const 0))
    (branch (label base-case))
 ;; setup to compute b^{n-1}
    (save continue)
    (assign continue (label after-expt-recur))
    (assign n (op -) (reg n) (const 1))
    (goto (label expt-loop))
 after-expt-recur
    (restore continue)
    (assign val (op *) (reg b) (reg val))
    (goto (reg continue))
 base-case
    (assign val (const 1))
    (goto (reg continue))
 expt-done)
#+END_SRC
**** b.
#+BEGIN_SRC scheme
(controller
    (assign c (reg n))
    (assign p (const 1))
 expt-loop
    (test (op =) (reg c) (const 0))
    (branch (label expt-done))
    (assign c (op -) (reg c) (const 1))
    (assign p (op *) (reg b) (reg p))
    (goto (label expt-loop))
 expt-done)
#+END_SRC
*** Exercise 5.5
I've done this in our text book (with digital paper).
*** Exercise 5.6
We can remove the pair before and after
#+BEGIN_SRC scheme
;; set up to compute Fib(n - 2)
(assign n (op -) (reg n) (const 2))
#+END_SRC
** Instruction Summary
In this section, the specifications we need to implement are summarized.
* A Register-Machine Simulator
Now we implement or learn what they implemented step by step for the
specifications of preceding design. Here they implement through by using wishful
thinking as we outlined in the beginning of this chapter.
*** Exercise 5.7
#+BEGIN_SRC scheme
(define expt-recur-machine
  (make-machine
   '(n b val)
   `((= ,=) (- ,-) (* ,*))
   '(
        (assign continue (label expt-done))
     expt-loop
        (test (op =) (reg n) (const 0))
        (branch (label base-case))
        ;; setup to compute b^{n-1}
        (save continue)
        (assign continue (label after-expt-recur))
        (assign n (op -) (reg n) (const 1))
        (goto (label expt-loop))
     after-expt-recur
        (restore continue)
        (assign val (op *) (reg b) (reg val))
        (goto (reg continue))
     base-case
        (assign val (const 1))
        (goto (reg continue))
     expt-done)))
#+END_SRC

And
#+BEGIN_SRC scheme
(define expt-iter-machine
  (make-machine
   '(n b c p)
   `((= ,=) (- ,-) (* ,*))
   '(
        (assign c (reg n))
        (assign p (const 1))
    expt-loop
        (test (op =) (reg c) (const 0))
        (branch (label expt-done))
        (assign c (op -) (reg c) (const 1))
        (assign p (op *) (reg b) (reg p))
        (goto (label expt-loop))
    expt-done)))
#+END_SRC

Then run:
#+BEGIN_SRC scheme
(set-register-contents! expt-recur-machine 'b 2)

;Value: done

(set-register-contents! expt-recur-machine 'n 5)

;Value: done

(start expt-recur-machine)

;Value: done

(get-register-contents expt-recur-machine 'val)

;Value: 32
#+END_SRC

And
#+BEGIN_SRC scheme
;; Run expt-iter-machine
(set-register-contents! expt-iter-machine 'b 2)
(set-register-contents! expt-iter-machine 'n 5)
(start expt-iter-machine)

(get-register-contents expt-iter-machine 'p)
;Value: 32
#+END_SRC

** The Machine Model
This subsection implements the middle-high level procedures.
** The Assembler
The assembler is like the analyzer in section 4.1.7. It transforms the text
instructions (expressions) into execution procedures. The idea behind this
process is much of the works the simulator would do otherwise can be processed
without knowing the actual contents of machine registers. For example, they
replaced the references to registers by pointers to the register objects -- as
we did in the last exercise in the [[org:../MEGAsync/MIT Challenge/6.001/Chapter4.org][previous chapter]], and replace references to
labels by pointers to the place in the instruction sequence that the label
designates -- like the variable bound to pair actually bound to pointer to that
pair.

*** Exercise 5.8
Since we construct the label entries from the very end to the start point (using
continuation), when we =lookup-label= with label =here=, the first label =here=
in the controller text returned by the contract of =assoc=.

So =a= would be 3 when it reaches =there=.

To modify this behavior as specified in the statement, we need to construct ADT
barrier for adding the newly constructed label entry to the given labels.

Specifically it should =lookup-label= to check whether the given =label-name= is
already in the labels; if it is, signal error.

#+BEGIN_SRC scheme
(define (add-label-entry entry labels)
  (if (get-label labels (label-name entry))
      (error "Given label name already exists in the labels" (list entry labels))
      (cons entry labels)))

(define (label-name entry) (car entry))

(define (get-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        false)))
#+END_SRC

Then
#+BEGIN_SRC scheme
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts (add-label-entry
                               (make-label-entry next-inst
                                                 insts)
                               labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
#+END_SRC

And we can test this feature:
#+BEGIN_SRC scheme
(define test-5.8-machine
  (make-machine
   '(a)
   '()
   '(start
     (goto (label here))
     here
     (assign a (const 3))
     (goto (label there))
     here
     (assign a (const 4))
     (goto (label there))
     there)
   ))

;Given label name already exists in the labels ((here ((assign a (const 3))) ((goto (label there))) . #0=(((assign a (const 4))) ((goto (label there))))) ((here . #0#) (there)))
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC
** Generating Execution Procedures for Instructions
=Assemble= procedure uses =make-execution-procedure=. This is has many analogy
with =analyze= procedure in section 4.1.7; these uses dispatch on data type, and
produce execution procedure that is analyzed using informations other than
actual contents.

*** Exercise 5.9
We can use either of following strategies:
- Define the procedure analogous to =make-primitive-exp=; or
- filter the label expression before calling the =make-primitive-exp=.


Here we are going to use the latter since it elicit what we meant more
specifically than the former.

#+BEGIN_SRC scheme
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (if (label-exp? e)
                    (error "Operation can not operate on label expression" e))
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
#+END_SRC
*** Exercise 5.10
We can do that other than the instructions should have type notation in its
=car= part since =make-execution-procedure= depends on this fact directly. For the
rest we are good to modify whatever we like since there are no restriction at all.

It means we should fence around dispatch on data type in the =make-execution-procedure=.

But for now let we stick what granted for us.

What we requested is not to create new syntax that has new semantic per se but
change one of the existing syntax to new one. We could change the register
syntax as post-fix notation like =(n reg)= by modifying as
#+BEGIN_SRC scheme
(define (register-exp? exp)
  (and (pair? exp)
       (pair? (cdr exp))
       (eq? (cadr exp) 'reg)))

(define (register-exp-reg exp) (car exp))
#+END_SRC

Then it works as expected:
#+BEGIN_SRC scheme
(define expt-iter-machine
  (make-machine
   '(n b c p)
   `((= ,=) (- ,-) (* ,*))
   '(
     (assign c (n reg))
     (assign p (const 1))
     expt-loop
     (test (op =) (c reg) (const 0))
     (branch (label expt-done))
     (assign c (op -) (c reg) (const 1))
     (assign p (op *) (b reg) (p reg))
     (goto (label expt-loop))
     expt-done)))

;Value: expt-iter-machine

(set-register-contents! expt-iter-machine 'b 2)

;Value: done

(set-register-contents! expt-iter-machine 'n 5)

;Value: done

(start expt-iter-machine)

;Value: done

(get-register-contents expt-iter-machine 'p)

;Value: 32
#+END_SRC
*** Exercise 5.11
First let us code the test machine:
#+BEGIN_SRC scheme
(define test-5.11-machine
  (make-machine
   '(x y)
   '()
   '((save y)
     (save x)
     (restore y))))
#+END_SRC
**** a.
We can reduce the following two lines
#+BEGIN_SRC scheme
,*** in Fibonacci controller
    (assign n (reg val))                ;n now contains Fib(n - 2)
    (restore val)                       ;val now contains Fib(n - 1)
#+END_SRC
into one line:
#+BEGIN_SRC scheme
    (restore n)                         ;n now contains Fib(n - 1)
#+END_SRC
**** b.
Now =save= has to construct new data structure that associate value with the
name of register. For now let's just use pair for to do this work:
#+BEGIN_SRC scheme
(define (make-save inst machine stack pc)
  (let ((reg-name (stack-inst-reg-name inst)))
    (let ((reg (get-register machine reg-name)))
      (lambda ()
        (push stack (cons reg-name (get-contents reg)))
        (advance-pc pc)))))

(define (make-restore inst machine stack pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine reg-name)))
    (lambda ()
      (let* ((assoc-entry (pop stack))
             (assoc-name (car assoc-entry)))
        (if (eq? assoc-name reg-name)
            (set-contents! reg (pop stack))
            (error "Tried to restore value from register which is not one saved -- MAKE-RESTORE"))
        (advance-pc pc)))))
#+END_SRC

And test:
#+BEGIN_SRC scheme
(set-register-contents! test-5.11-machine 'y 6)
(set-register-contents! test-5.11-machine 'x 3)
(start test-5.11-machine)

;Tried to restore value from register which is not one saved -- MAKE-RESTORE
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

**** c.
Whenever =allocate-register= to machine it should also add new stack to the
stacks -- =Alist<reg-name x stack>=; then =save= & =restore= first lookup the
specific stack associated with given register and do usual stack manipulations.

To initialize, it sends =initialize= messages each of stack in stacks.

#+BEGIN_SRC scheme
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stacks '())
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stacks
                       (lambda () (for-each (lambda (stack) (stack 'initialize))
                                            stacks)))
...
              ((eq? message 'stacks) stacks)
...
))))))

(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stacks (machine 'stacks))
        (ops (machine 'operations)))
     ...)

(define (make-save inst machine stacks pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine reg-name)))
    (lambda ()
      (let ((stack (cadr (assoc reg-name stacks))))
        (push stack (get-contents reg)))
      (advance-pc pc))))

(define (make-restore inst machine stacks pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine
                            (stack-inst-reg-name inst))))
    (lambda ()
      (let ((stack (cadr (assoc reg-name stacks))))
        (set-contents! reg (pop stack)))
      (advance-pc pc))))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(set-register-contents! test-5.11-machine 'y 6)
(set-register-contents! test-5.11-machine 'x 3)
(start test-5.11-machine)

;Value: done

(get-register-contents test-5.11-machine 'y)

;Value: 6

(get-register-contents test-5.11-machine 'x)

;Value: 3
#+END_SRC

Works as expected.
*** Exercise 5.12
- a list of all instructions without duplicates, sorted by instruction type;

  We need to implement constructing procedure that is analogous to
  =merge-weighted= or ordered. We could have chosen to sort the instructions
  in alphabetical order without bothered by the instruction type, but I felt it
  is more canonical to order the result in the order of dispatch on type in
  =make-execution-procedure=.

  Here is one possible solution:
  #+BEGIN_SRC scheme
(define type-dict
  '((assign 1) (test 2) (branch 3) (goto 4)
    (save 5) (restore 6) (perform 7)))

(define (adjoin-ordered precede? item ordered)
  (if (null? ordered)
      (list item)
      (let ((first (first ordered)))
        (cond ((precede? item first)
               (cons item ordered))
              ((precede? first item)
               (cons first
                     (adjoin-ordered
                      precede? item (cdr ordered))))
              (else
               ;; given item already in the ordered
               ordered)))))

(define (inst-precede? inst1 inst2)
  (let ((type1 (car inst1))
        (type2 (car inst2)))
    (let ((mapped1 (cadr (assoc type1 type-dict)))
          (mapped2 (cadr (assoc type2 type-dict))))
      (cond ((< mapped1 mapped2) true)
            ((> mapped1 mapped2) false)
            (else
             ;; same number
             (not (equal? inst1 inst2)) ;just exclude the same one
             )))))

;; First request
(define (assemble controller-text machine receive)
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      (receive
          insts
          (fold-right (lambda (inst ordered)
                        (adjoin-ordered inst-precede? inst ordered))
                      '()
                      (map (lambda (inst) (instruction-text inst))
                           insts))))))
  #+END_SRC

  Here we used the continuation to hand over the updated instructions with the
  newly constructed a list of all instructions:
  #+BEGIN_SRC scheme
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) register-name))
              register-names)
    ((machine 'install-operations) ops)
    (assemble controller-text machine
               (lambda (instructions all-instructions)
                 ((machine 'install-instruction-sequence)
                  instructions)
                 ((machine 'install-all-instructions)
                  all-instructions)))
    machine))
  #+END_SRC

  And modify the =make-new-machine= accordingly. Then test with Fibonacci
  machine:
  #+BEGIN_SRC scheme
(pp (fib-machine 'all-instructions))
((assign continue (label fib-done))
 (assign continue (label afterfib-n-1))
 (assign n (op -) (reg n) (const 1))
 (assign n (op -) (reg n) (const 2))
 (assign continue (label afterfib-n-2))
 (assign n (reg val))
 (assign val (op +) (reg val) (reg n))
 (assign val (reg n))
 (test (op <) (reg n) (const 2))
 (branch (label immediate-answer))
 (goto (label fib-loop))
 (goto (reg continue))
 (save continue)
 (save n)
 (save continue)
 (save val)
 (restore n)
 (restore continue)
 (restore val)
 (restore continue))
;Unspecified return value
  #+END_SRC

  Unfortunately, our implementation was wrong! the duplicates appear in the
  result. So we need to arrange in strict order:
  #+BEGIN_SRC scheme
(define (inst-precede? inst1 inst2)
  (let ((type1 (car inst1))
        (type2 (car inst2)))
    (let ((mapped1 (cadr (assoc type1 type-dict)))
          (mapped2 (cadr (assoc type2 type-dict))))
      (cond ((< mapped1 mapped2) true)
            ((> mapped1 mapped2) false)
            (else
             ;; same number
             ;; (not (equal? inst1 inst2)) ;just exclude the same one
             (symbol<? (hash-symbol-list (cdr inst1))
                       (hash-symbol-list (cdr inst2)))
             )))))

(define (hash-symbol-list slst)
  (fold-right
   (lambda (s appended)
     (symbol-append s appended))
   '||
   (flatten slst)))

;; Test hash-symbol-list
;; (hash-symbol-list '(a b (c d e) f g))
;; ;Value: abcdefg


;; Tree<A> -> List<A>
(define (flatten tree)
  (tree-map list append '() tree))

;; Test flatten
;; (flatten '(1 (2 3) (4 (5 6) 7)))
;; ;Value: (1 2 3 4 5 6 7)


;; (Leaf<A> -> B), (B, B -> B), B, Tree<A>
;; -> B
(define (tree-map leaf-op combine-op initial tree)
  (cond ((null? tree) initial)
        ((not (pair? tree)) (leaf-op tree))
        (else                           ;pair
         (combine-op
          (tree-map leaf-op combine-op initial
                    (car tree))
          (tree-map leaf-op combine-op initial
                    (cdr tree))))))
  #+END_SRC

  For the reminding purpose, we implemented other high order procedure also.
  Then let's re-test
  #+BEGIN_SRC scheme
(pp (fib-machine 'all-instructions))
((assign continue (label afterfib-n-1))
 (assign continue (label afterfib-n-2))
 (assign continue (label fib-done))
 (assign n (op -) (reg n) (const 1))
 (assign n (op -) (reg n) (const 2))
 (assign n (reg val))
 (assign val (op +) (reg val) (reg n))
 (assign val (reg n))
 (test (op <) (reg n) (const 2))
 (branch (label immediate-answer))
 (goto (label fib-loop))
 (goto (reg continue))
 (save continue)
 (save n)
 (save val)
 (restore continue)
 (restore n)
 (restore val))
;Unspecified return value
  #+END_SRC

  Now it returns what we expected.
- a list (without duplicates) of the registers used to hold entry points (these
  are the registers referenced by =goto= instructions);

  To do this task, we reuse what the result from the previous task. Here is the
  strategy:
  1. Filter the all instructions with =goto-exp?=;

  2. using =map=, extract the =goto-dest= part;

  3. filter that with =register-exp?=;

  4. and lastly, extract the =register-exp-reg= part and that is what we wanted.

    Here is the code do this idea:
    #+BEGIN_SRC scheme
  ,*** in assemble
  (let* ((all-insts
          (fold-right (lambda (inst ordered)
                        (adjoin-ordered inst-precede? inst ordered))
                      '()
                      (map (lambda (inst) (instruction-text inst))
                           insts)))
         (entry-regs
          (filter-map
           (lambda (goto-inst)
             (let ((dest (goto-dest goto-inst)))
               (and (register-exp? dest)
                    (register-exp-reg dest))))
           (take-while
            (lambda (inst)
              (eq? (car inst) 'goto))
            (drop-while
             (lambda (inst)
               (not (eq? (car inst) 'goto)))
             all-insts)))))
    (accept
     insts
     all-insts
     entry-regs))
    #+END_SRC

    We've integrate *2.* to *4.* part using =filter-map=; and for the first one,
    we used =take-while= and =drop-while= exploiting the fact that all
    instructions are sorted in types.

    Then test:
    #+BEGIN_SRC scheme
  (pp (fib-machine 'registers-with-entry))
  (continue)
  ;Unspecified return value
    #+END_SRC
- a list (without duplicates) of the registers that are =save= d or =restore= d;

  This is analogous to the preceding one:
  #+BEGIN_SRC scheme
,*** in let expression of assemble
(stack-related-regs
 (map
  (lambda (inst)
    (stack-inst-reg-name inst))
  (take-while
   (lambda (inst)
     (or (eq? (car inst) 'save)
         (eq? (car inst) 'restore)))
   (drop-while
    (lambda (inst)
      (not (eq? (car inst) 'save)))
    all-insts))))
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(pp (fib-machine 'stack-instruction-registers))
(continue n val continue n val)
;Unspecified return value
  #+END_SRC

  Huh! It's not what we expected. It is due to that we count one for the =save=
  and one for the =restore=, which usually end up with duplicates names.

  So let's fix it using the =adjoin-ordered=:
  #+BEGIN_SRC scheme
(stack-related-regs
 (fold-right
  (lambda (reg-name regs)
    (adjoin-ordered
     symbol<?
     reg-name
     regs))
  '()
  (map (lambda (inst)
         (stack-inst-reg-name inst))
       (take-while
        (lambda (inst)
          (or (eq? (car inst) 'save)
              (eq? (car inst) 'restore)))
        (drop-while
         (lambda (inst)
           (not (eq? (car inst) 'save)))
         all-insts)))))
  #+END_SRC

  Then we got
  #+BEGIN_SRC scheme
(pp (fib-machine 'stack-instruction-registers))
(continue n val)
;Unspecified return value
  #+END_SRC

- for each register, a list (without duplicates) of the sources from which it is
  assigned.

  Notice that the register source relations can be deduced directly from the
  =assign= expressions. So here we attempt to solve this task using the
  following strategy:
  1. Assume we have table data structure that has key /values/ entries. That is,
     if one insert key value pair into the given table, the value adjoined into
     the value list of given key.

  2. Then filter out the all instructions into =assign= expressions, and then
     insert the =assign-reg-name= as key and the =assign-value-exp= as value
     into the above table.

  3. The rest is interfacing this with the machine object; one can retrieve the
     sources of given register using the message, =sources-of=.

  Here is the code:
  #+BEGIN_SRC scheme
,*** in assemble let expression
(reg-sources-table
 (let ((tbl (make-multivalues-table)))
   (for-each
    (lambda (inst)
      ((tbl 'insert!)
       (assign-reg-name inst)
       (assign-value-exp inst)))
    (take-while
     (lambda (inst)
       (eq? (car inst) 'assign))
     all-insts))
   tbl))
  #+END_SRC

  Then what assumed:
  #+BEGIN_SRC scheme
(define (make-multivalues-table)
  (let ((local-table '(*table*)))
    (define (lookup-vals key)
      (cond ((assoc key (cdr local-table)) => cdr)
            (else false)))
    (define (insert-value! key value)
      (let ((entry (assoc key (cdr local-table))))
        (if entry
            (set-cdr! entry
                      (cons value (cdr entry)))
            (set-cdr! local-table
                      (cons (cons key (list value))
                            (cdr local-table))))))
    (lambda (m)
      (case m
        ((lookup) lookup-vals)
        ((insert!) insert-value!)
        (else
         (error "Unknown request -- MAKE-MULTIVALUES-TABLE" m))))))

;; Test for make-multivalues-table
;; (define x (make-multivalues-table))
;; ((x 'insert!) 'a 5)
;; ((x 'lookup) 'a)
;; ;; (5)
;; ((x 'insert!) 'a 2)
;; ((x 'lookup) 'a)
;; ;; (2 5)
;; ((x 'insert!) 'b 2)
;; ((x 'lookup) 'b)
;; ;; (2)
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(pp ((fib-machine 'sources-of) 'n))
(((reg val)) ((op -) (reg n) (const 2)) ((op -) (reg n) (const 1)))
;Unspecified return value
  #+END_SRC
*** Exercise 5.13
We can what we want by modifying =get-register= procedure, which called in the
=make-execution-procedure= to reference the register object allocated in given
machine.

But it is not good idea to alter the existing =get-register= procedure since it
may interface with other process also as its contract is not just for the
=make-execution-procedure=.

So it would be better to make procedure that is analogous to =get-register= but
it allocates given register name whenever it has not been allocated in given
machine. If given register name already allocated in given machine, then it
should works like =get-register=.

With this idea, we can do the task what we requested. After implementing this
idea, we are good to discard the preallocating process in the =make-machine=.

#+BEGIN_SRC scheme
,*** within make-new-machine
(define (try-allocate-and-return-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (begin (allocate-register name)
                     (lookup-register name)))))
,*** in the dispatch
((eq? message 'try-allocate-and-get-register)
               try-allocate-and-return-register)
#+END_SRC

Then
#+BEGIN_SRC scheme
(define (make-sure-allocate-register-and-get machine reg-name)
  ((machine 'try-allocate-and-get-register) reg-name))
#+END_SRC

And we should replace all the subprocesses of =assemble= to use
=make-sure-allocate-register-and-get= instead of =get-register=:
#+BEGIN_SRC scheme
(define (make-assign inst machine labels operations pc)
  (let ((target
         (make-sure-allocate-register-and-get machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()                ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))

(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (make-sure-allocate-register-and-get machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction -- ASSEMBLE"
                       inst)))))

(define (make-save inst machine stack pc)
  (let ((reg (make-sure-allocate-register-and-get machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (make-sure-allocate-register-and-get machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))

(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (make-sure-allocate-register-and-get machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type -- ASSEMBLE" exp))))
#+END_SRC

Now =make-machine= gets
#+BEGIN_SRC scheme
(define (make-machine ops controller-text)
  (let ((machine (make-new-machine)))
    ((machine 'install-operations) ops)
    (assemble controller-text machine
              (lambda (instructions
                       all-instructions registers-with-entry
                       stack-inst-regs reg-sources-table)
                ((machine 'install-instruction-sequence)
                 instructions)
                ((machine 'install-all-instructions)
                 all-instructions)
                ((machine 'install-registers-with-entry)
                 registers-with-entry)
                ((machine 'install-stack-instruction-registers)
                 stack-inst-regs)
                ((machine 'install-register-sources-table)
                 reg-sources-table)))
    machine))
#+END_SRC

And let's test:
#+BEGIN_SRC scheme
(define fib-machine
  (make-machine
   `((< ,<) (- ,-) (+ ,+))
   '((assign continue (label fib-done))
     fib-loop
     (test (op <) (reg n) (const 2))
     (branch (label immediate-answer))
     ;; set up to compute Fib(n-1)
     (save continue)
     (assign continue (label afterfib-n-1))
     (save n)                            ; save old value of n
     (assign n (op -) (reg n) (const 1)) ; clobber n to n-1
     (goto (label fib-loop))             ; perform recursive call
     afterfib-n-1                        ; upon return, val contains Fib(n-1)
     (restore n)
     (restore continue)
     ;; set up to compute Fib(n-2)
     (assign n (op -) (reg n) (const 2))
     (save continue)
     (assign continue (label afterfib-n-2))
     (save val)                         ; save Fib(n-1)
     (goto (label fib-loop))
     afterfib-n-2                       ; upon return, val contains Fib(n-2)
     (assign n (reg val))               ; n now contains Fib(n-2)
     (restore val)                      ; val now contains Fib(n-1)
     (restore continue)
     (assign val                        ; Fib(n-1)+Fib(n-2)
             (op +) (reg val) (reg n))
     (goto (reg continue))              ; return to caller, answer is in val
     immediate-answer
     (assign val (reg n))               ; base case: Fib(n)=n
     (goto (reg continue))
     fib-done)))

;Value: fib-machine

(set-register-contents! fib-machine 'n 4)

;Value: done

(start fib-machine)

;Value: done

(get-register-contents fib-machine 'val)

;Value: 3
#+END_SRC

Works well.
** Monitoring Machine Performance
*** Exercise 5.14
#+BEGIN_SRC scheme
 (define fact-machine
  (make-machine
   `((= ,=) (- ,-) (* ,*))
   '(
     (perform (op initialize-stack))
     (assign continue (label fact-done)) ; set up final return address
     fact-loop
     (test (op =) (reg n) (const 1))
     (branch (label base-case))
     ;; Set up for the recursive call by saving n and continue.
     ;; Set up continue so that the computation will continue
     ;; at after-fact when the subroutine returns.
     (save continue)
     (save n)
     (assign n (op -) (reg n) (const 1))
     (assign continue (label after-fact))
     (goto (label fact-loop))
     after-fact
     (restore n)
     (restore continue)
     (assign val (op *) (reg n) (reg val)) ; val now contains n(n-1)!
     (goto (reg continue))                 ; return to caller
     base-case
     (assign val (const 1))             ; base case: 1!=1
     (goto (reg continue))              ; return to caller
     fact-done
     (perform (op print-stack-statistics)))))
#+END_SRC

Then here is the experiment cases:
#+BEGIN_SRC scheme
(set-register-contents! fact-machine 'n 10)

;Value: done

(start fact-machine)

(total-pushes = 18 maximum-depth = 18)
;Value: done

(set-register-contents! fact-machine 'n 20)

;Value: done

(start fact-machine)

(total-pushes = 38 maximum-depth = 38)
;Value: done

(set-register-contents! fact-machine 'n 2)

;Value: done

(start fact-machine)

(total-pushes = 2 maximum-depth = 2)
;Value: done
#+END_SRC

From this data, we can deduce that =total-pushes= and =maximum-depth= are same
and the general formula for this in terms of =n= is $T(n) = 2n-2$.

Or using =read=:
#+BEGIN_SRC scheme
(start fact-machine)
5

(total-pushes = 8 maximum-depth = 8)
;Value: done

(start fact-machine)
35

(total-pushes = 68 maximum-depth = 68)
;Value: done
#+END_SRC
*** Exercise 5.15
We need to modify the =make-new-machine= procedure to include =number-execs= to
accommodate new feature specified in the statement.

And define as internal definition of that procedure the following print method:
#+BEGIN_SRC scheme
(define (print-statistics)
        (newline)
        (display
         `(tatal-executions = ,number-execs)))
#+END_SRC

And modify =execute=:
#+BEGIN_SRC scheme
(define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (set! number-execs (1+ number-execs))
                (execute)))))
#+END_SRC

And interface with the rest:
#+BEGIN_SRC scheme
,*** in dispatch
              ((eq? message 'print-statistics) (print-statistics))
              ((eq? message 'initialize-statistics) (set! number-execs 0))
#+END_SRC

Now we can use as follows:
#+BEGIN_SRC scheme
(set-register-contents! fib-machine 'n 10)

;Value: done

(start fib-machine)

;Value: done

(fib-machine 'print-statistics)

(tatal-executions = 2029)
;Unspecified return value

(fib-machine 'initialize-statistics)

;Value: 2029

(set-register-contents! fib-machine 'n 20)

;Value: done

(start fib-machine)

;Value: done

(fib-machine 'print-statistics)

(tatal-executions = 251740)
;Unspecified return value
#+END_SRC

Exponential growth verified!
*** Exercise 5.16
