#+TITLE: Metalinguistic Abstraction
/Metalinguistic Abstraction/ -- establishing new languages -- plays an important
role in all branches of engineering design. It is particularly important to
computer programming, because in programming /not only can we formulate new
languages but we can also implement these languages by constructing evaluators/.

* The Metacircular Evaluator
** The Core of the Evaluator
In this section we use the syntax operations (the representation for the syntax
of language being implemented) to implement the =eval= and =apply= process. Our
evaluator uses several ADTs each for syntax for language being implemented and the
internal representations for internal evaluation model -- environment.
*** Exercise 4.1
We can force the order by using =let= statement -- since it is just syntactic
sugar for lambda application, the value of each bindings of =let= expression
evaluated before evaluating the body of it.
#+BEGIN_SRC scheme
;;; Left to Right
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((first (eval (first-operand exps) env)))
        (cons first
              (list-of-values (rest-operands exps) env)))))
;;; Right to Left
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((rest (list-of-values (rest-operands exps) env)))
        (cons (eval (first-operand exps) env)
              rest))))
#+END_SRC
** Representing Expressions
It is reminiscent of the symbolic differentiation program discussed in section
2.3.2; each expression has its own type tag in it, so our evaluator dispatch on
this type and recursively evaluate the nested expression.
*** Exercise 4.2
**** a.
It will deal the assignment expression as if it is procedure application since
procedure application expression doesn't have any type for specifying it so any
the pairs not sifted by the =cond= clauses before that clause treated as
procedure application. So =(define x 3)= are treated procedure application and,
in turn, evaluator lookup the =define= variable; since it couldn't find any it
will signal error -- undefined variable.
**** b.
Here is the fix:
#+BEGIN_SRC scheme
(define (application? exp) (tagged-list? exp 'call))
#+END_SRC
*** Exercise 4.3
We can rely on the data-directed style only for the tagged expressions:
#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        (else
         (let ((op (and (tagged-exp? exp)
                        (get 'eval (type-tag exp)))))
           (cond (op (op exp env))
                 ((application? exp)
                  (apply (eval (operator exp) env)
                         (list-of-values (operands exp) env)))
                 (else
                  (error "Unknown expression type -- EVAL" exp)))))))
#+END_SRC

The procedures of =tagged-exp= ADT:
#+BEGIN_SRC scheme
(define (type-tag exp)
  (car exp))
(define (tagged-exp? exp)
  (pair? exp))
#+END_SRC

Then install the contents:
#+BEGIN_SRC scheme
(define (install-eval-clauses)
  (put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
  (put 'eval 'set! eval-assignment)
  (put 'eval 'define eval-definition)
  (put 'eval 'if eval-if)
  (put 'eval 'lambda (lambda (exp env)
                       (make-procedure (lambda-parameters exp)
                                       (lambda-body exp)
                                       env)))
  (put 'eval 'begin (lambda (exp env)
                      (eval-sequence (begin-actions exp) env)))
  (put 'eval 'cond (lambda (exp env)
                     (eval (cond->if exp) env)))
  'done)
#+END_SRC

I've implemented the type tags directly for simplicity.
*** Exercise 4.4
**** As special expression
#+BEGIN_SRC scheme
(define (install-eval-and-or-direct)
  ;; and eval
  (define (eval-and exp env)
    (eval-and-subs (subexps exp) env))
  (define (eval-and-subs subs env)
    (cond ((null? subs) (eval 'true env))
          ((last-sub? subs) (eval (first subs) env))
          (else
           (if (true? (eval (first-sub subs) env))
               (eval-and-subs (rest-subs subs) env)
               (eval 'false env)))))

  ;; or eval
  (define (eval-or exp env)
    (eval-or-subs (subexps exp) env))
  (define (eval-or-subs subs env)
    (cond ((null? subs) (eval 'false env))
          ((last-sub? subs) (eval (first subs) env))
          (else
           (let ((current
                  (eval (first-sub subs) env)))
             (if (false? current)
                 (eval-or-subs (rest-subs subs) env)
                 current)))))

  ;; selector on And or Or expression
  (define (subexps exp) (cdr exp))
  ;; sub ADT
  (define (last-sub? subs)
    (and (pair? subs) (null? (cdr subs))))
  (define first-sub car)
  (define rest-subs cdr)

  ;; interface with eval procedure
  (put 'eval 'and eval-and)
  (put 'eval 'or eval-or)
  'done)
#+END_SRC

Here we used data-directed style =eval= from [[Exercise 4.3][ex 4.3]].

Then setup for test:
#+BEGIN_SRC scheme
(define eval-table (make-hash-table))
(define (put op type item)
  (if (eq? op 'eval)
      (hash-table-set! eval-table type item)
      (error "Unallowed operation -- PUT" op)))
(define (get op type)
  (if (eq? op 'eval)
      (hash-table-ref eval-table type (lambda () #f))
      (error "Unknown operation -- GET" op)))
#+END_SRC

Let's run!
#+BEGIN_SRC scheme
1 ]=> (install-eval-clauses)

;Value: done

1 ]=> (install-eval-and-or-direct)

;Value: done

1 ]=> (driver-loop)

;;; M-Eval input:
(and)

;;; M-Eval value:
#t

;;; M-Eval input:
(and 5)

;;; M-Eval value:
5

;;; M-Eval input:
(and false)

;;; M-Eval value:
#f

;;; M-Eval input:
(and false 5 2)

;;; M-Eval value:
#f

;;; M-Eval input:
(and 5 2)

;;; M-Eval value:
2

;;; M-Eval input:
(and 5 false)

;;; M-Eval value:
#f

;;; M-Eval input:
(or)

;;; M-Eval value:
#f

;;; M-Eval input:
(or 5)

;;; M-Eval value:
5

;;; M-Eval input:
(or false 5 false flase)

;;; M-Eval value:
5

;;; M-Eval input:
(or false 5 false)

;;; M-Eval value:
5

;;; M-Eval input:
(or false false 5)

;;; M-Eval value:
5

#+END_SRC

Or we could test this in unit:
#+BEGIN_SRC scheme
(install-eval-clauses)

;Value: done

(install-eval-and-or-direct)

;Value: done

(eval '(and 5) the-global-environment)

;Value: 5

(eval '(and false 5) the-global-environment)

;Value: #f

(eval '(or 5 false) the-global-environment)

;Value: 5
#+END_SRC
**** As derived expression
This is analogous to =cond=:
#+BEGIN_SRC scheme
define (install-eval-and-or-derived)
  (define (expand-or-subs subs)
    (cond ((null? subs) 'false)
          ((null? (cdr subs)) (car subs))
          (else
           (let ((first (car subs)))
             (make-let
              (list (list 'first first))
              (list (make-if 'first
                        'first
                        (expand-or-subs (cdr subs)))))))))
  (define (expand-and-subs subs)
    (cond ((null? subs) 'true)
          ((null? (cdr subs)) (car subs))
          (else
           (make-if (car subs)
                    (expand-and-subs (cdr subs))
                    'false))))

  (define (and->if exp)
    (expand-and-subs (cdr exp)))

  (define (or->if exp)
    (expand-or-subs (cdr exp)))

  (put 'eval 'and (lambda (exp env)
                    (eval (and->if exp) env)))
  (put 'eval 'or (lambda (exp env)
                   (eval (or->if exp) env)))
  'done)
#+END_SRC
For =or=, we used =make-let= to reuse the result of evaluation of first
subexpression in case where it turns out true.

Here is =make-let= syntax procedure that is analogous to =make-lambda=
#+BEGIN_SRC scheme
;; List<binding>, List<expression> -> Let
(define (make-let bindings body)
  (cons 'let (cons bindings body)))
#+END_SRC

Then test!
#+BEGIN_SRC scheme
(install-eval-and-or-derived)

;Value: done

(eval '(and 5) the-global-environment)

;Value: 5

(eval '(and false 5) the-global-environment)

;Value: #f

(eval '(and true 2 true) the-global-environment)

;Value: #t
#+END_SRC

For the =or= part, we delegate the test until we implement the =let= expression
in our evaluator ([[Exercise 4.6][ex 4.6]])
*** Exercise 4.5
We can support this new feature through either special form or derived form. The
key issue is that is it okay re-evaluate the =<test>= expression twice?
- If it is okay, the only change that we should make is the =sequence->exp= part
  of =expand-clauses= into
  #+BEGIN_SRC scheme
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (cond-actions->exp first)
                     (expand-clauses rest))))))

(define (cond-actions->exp clause)
  (let ((actions (cond-actions clause)))
    (if (eq? (car actions) '=>)
        (if (and (pair? (cdr actions))
                 (null? (cddr actions)))
            (list (cadr actions) (cond-predicate clause))
            (error "Illformed expression -- COND-MAP" clause))
        (sequence->exp actions))))
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr)
                         (else false)) the-global-environment)

;Value: 4

(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Illformed expression -- COND-MAP ((cons 3 4) => cdr 3)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC
- If it is not, in other word, we are constrained to evaluate the =cond-predicate=
  only once, we do use =make-let= as we did in the previous exercise.
  #+BEGIN_SRC scheme
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (let ((pred (cond-predicate first)))
              (make-let
               (list (list 'pred pred))
               (list (make-if 'pred
                              (map-or-sequence->exp
                               (cond-actions first) 'pred)
                              (expand-clauses rest)))))))))

(define (map-or-sequence->exp actions pred)
  (if (eq? (car actions) '=>)
      (if (and (pair? (cdr actions))
               (null? (cddr actions)))
          (list (cadr actions) pred)
          (error "Illformed expression -- COND-MAP" clause))
      (sequence->exp actions)))
  #+END_SRC
*** Exercise 4.6
#+BEGIN_SRC scheme
(define (install-eval-let)
  (define (let->combination exp)
    (let* ((bindings (bindings exp))
           (unziped-b
            (fold-right
             (lambda (var-exp vars-exps)
               (cons (cons (car var-exp) (car vars-exps))
                     (cons (cadr var-exp) (cdr vars-exps))))
             (cons '() '())
             bindings))
           (params (car unziped-b))
           (exps (cdr unziped-b)))
      (cons (make-lambda params (body exp))
            exps)))

  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let (lambda (exp env)
                    (eval (let->combination exp) env)))
  'done)
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(eval '(let ((x 1)) (cons x 2)) the-global-environment)

;Value: (1 . 2)

(eval '(let ((x 1)) (cons x 2) (cons 2 x)) the-global-environment)

;Value: (2 . 1)
#+END_SRC

Then now we can test the =or= of derived version:
#+BEGIN_SRC scheme
(install-eval-and-or-derived)

;Value: done

(eval '(or 5 false) the-global-environment)

;Value: 5

(eval '(or false 5 false) the-global-environment)

;Value: 5
#+END_SRC

And derived =cond='s new feature:
#+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr)
                         (else false)) the-global-environment)

;Value: 4

(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Unbound variable: clause
#+END_SRC
By test it we found the bug in our previous error handling. It is easy to fix.
After fixing,
#+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Illformed expression -- COND-MAP (=> cdr 3)
#+END_SRC
It works as expected.
*** Exercise 4.7
#+BEGIN_SRC scheme
(define (install-eval-let*)
  (define (let*->let exp)
    (define (expand-let* bindings)
      (if (null? bindings)
          (body exp)
          (let ((first (car bindings))
                (rest (cdr bindings)))
            (make-let
             (list first)
             ((if (null? rest)
                  identity-procedure
                  list) ;for the type contraction of make-let
              (expand-let* rest))))))
    (expand-let* (bindings exp)))
  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let* (lambda (exp env)
                     (eval (let*->let exp) env)))
  'done)
#+END_SRC
It suffices to define =let*= as derived expression since subsequent derived
expression reduced to non-derived expression by =eval= and =apply= loop, which
in turn reduced to primitive expressions.

Then test:
#+BEGIN_SRC scheme
(install-eval-let*)

;Value: done

(eval
 '(let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))
 the-global-environment)

;Value: 39
#+END_SRC
*** Exercise 4.8
First let we code the test:
#+BEGIN_SRC scheme
(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)
;; ok
(eval
 '(fib 3)
 the-global-environment)
;; 1
#+END_SRC

And note that by using the environment model, we can deduce named let expression
=(let <var> <bindings> <body>)= is equivalent to
#+BEGIN_SRC scheme
(let ((<var> undef))
  (set! <var>
    (lambda <params of bindings> body))
  (apply <var> <exps of bindings>))
#+END_SRC

So we convert named let expression above equivalent expression.

Here is the result:
#+BEGIN_SRC scheme
(define (install-eval-let-with-named)
  ;; ADT for named
  (define (named? exp)
    (and (pair? exp)
         (pair? (cdr exp))
         (symbol? (cadr exp))))

  (define (named exp)
    (cadr exp))

  (define (except-name-let exp)
    (cdr exp))

  (define (let->combination exp)
    (let* ((bindings (bindings exp))
           (unziped-b
            (fold-right
             (lambda (var-exp vars-exps)
               (cons (cons (car var-exp) (car vars-exps))
                     (cons (cadr var-exp) (cdr vars-exps))))
             (cons '() '())
             bindings))
           (params (car unziped-b))
           (exps (cdr unziped-b)))
      (cons (make-lambda params (body exp))
            exps)))

  (define (named->let-combination exp)
    (let ((var (named exp))
          (comb (let->combination
                 (except-name-let exp))))
      (let ((lambda-part (car comb))
            (exps (cdr comb)))
        (make-let
         (list (list var (list 'quote undef)))
         (list
          (make-assignment var
                           lambda-part)
          (cons var
                exps))))))

  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let (lambda (exp env)
                    (eval (if (named? exp)
                              (named->let-combination exp)
                              (let->combination exp)) env)))
  'done)
#+END_SRC

And the auxiliary parts:
#+BEGIN_SRC scheme
(define undef '*unassigned*)
(define (make-assignment var val)
  (list 'set! var val))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
(install-eval-let-with-named)

;Value: done

(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)

;Value: ok

(eval
 '(fib 3)
 the-global-environment)

;Unbound variable =
#+END_SRC

Huh, we should set ~=~ (and also =-=) as primitive procedure in our environment.
Do that and re-run:
#+BEGIN_SRC scheme
(install-eval-clauses)

;Value: done

(install-eval-let-with-named)

;Value: done

(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)

;Value: ok

(eval
 '(fib 3)
 the-global-environment)

;Value: 2

(eval
 '(fib 2)
 the-global-environment)

;Value: 1
#+END_SRC

Oh-huh there are good news and bad news:
- Our test code was wrong! =(fib 3)= should return 2 not 1 as it count from 0!
- Our code works right!
