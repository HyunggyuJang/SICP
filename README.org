#+TITLE: Computing with Register Machines
So far we have learned the meanings of procedures using a succession of models
of evaluation: The substitution model, the environment model, the metacircular
evaluator. But none of these evaluation model did not dispel how the evaluation
of subexpression manages to return a value to the expression that uses this
value, nor does the evaluator explain how some recursive procedures generate
iterative processes.

In this chapter we are going to learn so called "linking" process, which link
the callee and caller with the returning value.

Further more, as it is the last chapter of this text book, this chapter
organized as the canonical structure in that we've learned so far: By wishful
thinking,
1. Design or specify what we want to implement or the behavior that we want from
   the application -- section 5.1;
2. implement the high level procedures using the low level procedure's
   specifications, by wishful thinking -- we haven't yet implemented the low
   level procedure but we can specify what we want from the perspective of high
   level procedure implementor --, section 5.2;
3. then we implement the very low procedures using only the primitives --
   section 5.3;
4. a variation or application of what we implemented -- section 5.4;
5. deep dive what we have assumed as primitive or "as given" -- section 5.5;


So by learning through this chapter, we can learn not just the contents it
contains but also the general strategy to embody the ideas into the real world
program. This general strategy would be applied to any of design process one
would encounter with when try to create something that isn't yet in the world
that solves the given specific kind of problem.

We'd better to be engraved in our mind the general strategy through out this chapter.

* Designing Register Machines
*** Exercise 5.1
I've drawn this with my digital paper. But you should be careful that our switch
is not just simple switch, which we probably used in electrical experiment in
middle or like that age, but a switch that has memorizing feature so that one
can clobber the contents of given register.

So we can use the result signal or value of operator -- multiply, addition, etc.
-- to clobber the operand register directly without intervening the
intermediate register.

It is not deducible from the contents before this exercise, that is, from the
=gcd= machine; but we can do from the later example machines. It is quite unfair
they did not specify what feature the switches possesses exactly -- only in a
context that even not appear until this exercise.

** A Language for Describing Register Machines
So far our language for the design of machines was diagrams -- one for data
paths and one for controller; now through this chapter we extends our tools for
designing register machines to more powerful programming like language that we
can simulate easily by restricting the freedom of design -- only the finite
number of instructions can be used in the designing.

*** Exercise 5.2
#+BEGIN_SRC scheme
(controller
    (assign p (const 1))
    (assign c (const 1))
 test-c
    (test (op >) (reg c) (reg n))
    (branch (label fact-done))
    (assign p (op *) (reg p) (reg c))
    (assign c (op +) (reg c) (const 1))
    (goto (label test-c))
 fact-done)
#+END_SRC
** Abstraction in Machine Design
*** Exercise 5.3
The first version that assume the internal definitions are available as
primitive procedure in the =sqrt-iter=.
#+BEGIN_SRC scheme
(controller
    (assign g (const 1.0))
 test-g
    (test (op g-e?) (reg g))
    (branch (label sqrt-done))
    (assign g (op imp) (reg g))
    (goto (label test-g))
 sqrt-done)
#+END_SRC

Note that we haven't even mentioned the =x= in above controller description.

Now we are going to implement the second task -- unwind the internal definitions
into the primitive ones.

#+BEGIN_SRC scheme
;;; Version 2
;;; middle level procedures

;;;; good-enough?
(assign s-q (op sq) (reg g))
(assign d (op -) (reg s-q) (reg x))
(assign ad (op abs) (reg d))
(test (op <) (reg ad) (const 0.001))

;;;; improve
(assign x/g (op /) (reg x) (reg g))
(assign imped (op avg) (reg g) (reg x/g))

;;; low level procedures
;;;; square
(assign cp (reg g))
(assign squared (op *) (reg cp) (reg g))

;;;; abs
(test (op <) (reg d) (const 0))
(branch (label abs-fetch))
(assign absed (op neg) (reg d))
(goto (label abs-done))
abs-fetch
(assign absed (reg d))
abs-done

;;;; average
(assign s (op +) (reg x) (reg g))
(assing aved (op /) (reg s) (const 2))

;;; And linking all together
(controller
    (assign g (const 1.0))
 test-g
;;; good-enough? {
    ;; sq {
    (assign d (reg g))
    (assign t (op *) (reg d) (reg g))
    ;; }
    (assign d (op -) (reg t) (reg x))
    ;; abs {
    (test (op <) (reg d) (const 0))
    (branch (label abs-fetch))
    (assign t (op neg) (reg d))
    (goto (label abs-done))
 abs-fetch
    (assign t (reg d))
 abs-done
    ;; }
    (test (op <) (reg t) (const 0.001))
;;; }
    (branch (label sqrt-done))
;;; improve {
    (assign d (op /) (reg x) (reg g))
    ;; average {
    (assign t (op +) (reg x) (reg g))
    (assing g (op /) (reg t) (const 2))
    ;; }
;;; }
    (goto (label test-g))
 sqrt-done)
#+END_SRC

For the data paths diagrams, I've drawn in digital paper.
** Subroutines
** Using a Stack to Implement Recursion
*** Exercise 5.4
**** a.
#+BEGIN_SRC scheme
(controller
    (assign continue (label expt-done))
 expt-loop
    (test (op =) (reg n) (const 0))
    (branch (label base-case))
 ;; setup to compute b^{n-1}
    (save continue)
    (assign continue (label after-expt-recur))
    (assign n (op -) (reg n) (const 1))
    (goto (label expt-loop))
 after-expt-recur
    (restore continue)
    (assign val (op *) (reg b) (reg val))
    (goto (reg continue))
 base-case
    (assign val (const 1))
    (goto (reg continue))
 expt-done)
#+END_SRC
**** b.
#+BEGIN_SRC scheme
(controller
    (assign c (reg n))
    (assign p (const 1))
 expt-loop
    (test (op =) (reg c) (const 0))
    (branch (label expt-done))
    (assign c (op -) (reg c) (const 1))
    (assign p (op *) (reg b) (reg p))
    (goto (label expt-loop))
 expt-done)
#+END_SRC
*** Exercise 5.5
I've done this in our text book (with digital paper).
*** Exercise 5.6
We can remove the pair before and after
#+BEGIN_SRC scheme
;; set up to compute Fib(n - 2)
(assign n (op -) (reg n) (const 2))
#+END_SRC
** Instruction Summary
In this section, the specifications we need to implement are summarized.
* A Register-Machine Simulator
Now we implement or learn what they implemented step by step for the
specifications of preceding design. Here they implement through by using wishful
thinking as we outlined in the beginning of this chapter.
*** Exercise 5.7
#+BEGIN_SRC scheme
(define expt-recur-machine
  (make-machine
   '(n b val)
   `((= ,=) (- ,-) (* ,*))
   '(
        (assign continue (label expt-done))
     expt-loop
        (test (op =) (reg n) (const 0))
        (branch (label base-case))
        ;; setup to compute b^{n-1}
        (save continue)
        (assign continue (label after-expt-recur))
        (assign n (op -) (reg n) (const 1))
        (goto (label expt-loop))
     after-expt-recur
        (restore continue)
        (assign val (op *) (reg b) (reg val))
        (goto (reg continue))
     base-case
        (assign val (const 1))
        (goto (reg continue))
     expt-done)))
#+END_SRC

And
#+BEGIN_SRC scheme
(define expt-iter-machine
  (make-machine
   '(n b c p)
   `((= ,=) (- ,-) (* ,*))
   '(
        (assign c (reg n))
        (assign p (const 1))
    expt-loop
        (test (op =) (reg c) (const 0))
        (branch (label expt-done))
        (assign c (op -) (reg c) (const 1))
        (assign p (op *) (reg b) (reg p))
        (goto (label expt-loop))
    expt-done)))
#+END_SRC

Then run:
#+BEGIN_SRC scheme
(set-register-contents! expt-recur-machine 'b 2)

;Value: done

(set-register-contents! expt-recur-machine 'n 5)

;Value: done

(start expt-recur-machine)

;Value: done

(get-register-contents expt-recur-machine 'val)

;Value: 32
#+END_SRC

And
#+BEGIN_SRC scheme
;; Run expt-iter-machine
(set-register-contents! expt-iter-machine 'b 2)
(set-register-contents! expt-iter-machine 'n 5)
(start expt-iter-machine)

(get-register-contents expt-iter-machine 'p)
;Value: 32
#+END_SRC

** The Machine Model
This subsection implements the middle-high level procedures.
** The Assembler
The assembler is like the analyzer in section 4.1.7. It transforms the text
instructions (expressions) into execution procedures. The idea behind this
process is much of the works the simulator would do otherwise can be processed
without knowing the actual contents of machine registers. For example, they
replaced the references to registers by pointers to the register objects -- as
we did in the last exercise in the [[org:../MEGAsync/MIT Challenge/6.001/Chapter4.org][previous chapter]], and replace references to
labels by pointers to the place in the instruction sequence that the label
designates -- like the variable bound to pair actually bound to pointer to that
pair.

*** Exercise 5.8
Since we construct the label entries from the very end to the start point (using
continuation), when we =lookup-label= with label =here=, the first label =here=
in the controller text returned by the contract of =assoc=.

So =a= would be 3 when it reaches =there=.

To modify this behavior as specified in the statement, we need to construct ADT
barrier for adding the newly constructed label entry to the given labels.

Specifically it should =lookup-label= to check whether the given =label-name= is
already in the labels; if it is, signal error.

#+BEGIN_SRC scheme
(define (add-label-entry entry labels)
  (if (get-label labels (label-name entry))
      (error "Given label name already exists in the labels" (list entry labels))
      (cons entry labels)))

(define (label-name entry) (car entry))

(define (get-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        false)))
#+END_SRC

Then
#+BEGIN_SRC scheme
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts (add-label-entry
                               (make-label-entry next-inst
                                                 insts)
                               labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
#+END_SRC

And we can test this feature:
#+BEGIN_SRC scheme
(define test-5.8-machine
  (make-machine
   '(a)
   '()
   '(start
     (goto (label here))
     here
     (assign a (const 3))
     (goto (label there))
     here
     (assign a (const 4))
     (goto (label there))
     there)
   ))

;Given label name already exists in the labels ((here ((assign a (const 3))) ((goto (label there))) . #0=(((assign a (const 4))) ((goto (label there))))) ((here . #0#) (there)))
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC
** Generating Execution Procedures for Instructions
=Assemble= procedure uses =make-execution-procedure=. This is has many analogy
with =analyze= procedure in section 4.1.7; these uses dispatch on data type, and
produce execution procedure that is analyzed using informations other than
actual contents.

*** Exercise 5.9
We can use either of following strategies:
- Define the procedure analogous to =make-primitive-exp=; or
- filter the label expression before calling the =make-primitive-exp=.


Here we are going to use the latter since it elicit what we meant more
specifically than the former.

#+BEGIN_SRC scheme
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (if (label-exp? e)
                    (error "Operation can not operate on label expression" e))
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
#+END_SRC
*** Exercise 5.10
We can do that other than the instructions should have type notation in its
=car= part since =make-execution-procedure= depends on this fact directly. For the
rest we are good to modify whatever we like since there are no restriction at all.

It means we should fence around dispatch on data type in the =make-execution-procedure=.

But for now let we stick what granted for us.

What we requested is not to create new syntax that has new semantic per se but
change one of the existing syntax to new one. We could change the register
syntax as post-fix notation like =(n reg)= by modifying as
#+BEGIN_SRC scheme
(define (register-exp? exp)
  (and (pair? exp)
       (pair? (cdr exp))
       (eq? (cadr exp) 'reg)))

(define (register-exp-reg exp) (car exp))
#+END_SRC

Then it works as expected:
#+BEGIN_SRC scheme
(define expt-iter-machine
  (make-machine
   '(n b c p)
   `((= ,=) (- ,-) (* ,*))
   '(
     (assign c (n reg))
     (assign p (const 1))
     expt-loop
     (test (op =) (c reg) (const 0))
     (branch (label expt-done))
     (assign c (op -) (c reg) (const 1))
     (assign p (op *) (b reg) (p reg))
     (goto (label expt-loop))
     expt-done)))

;Value: expt-iter-machine

(set-register-contents! expt-iter-machine 'b 2)

;Value: done

(set-register-contents! expt-iter-machine 'n 5)

;Value: done

(start expt-iter-machine)

;Value: done

(get-register-contents expt-iter-machine 'p)

;Value: 32
#+END_SRC
*** Exercise 5.11
First let us code the test machine:
#+BEGIN_SRC scheme
(define test-5.11-machine
  (make-machine
   '(x y)
   '()
   '((save y)
     (save x)
     (restore y))))
#+END_SRC
**** a.
We can reduce the following two lines
#+BEGIN_SRC scheme
,*** in Fibonacci controller
    (assign n (reg val))                ;n now contains Fib(n - 2)
    (restore val)                       ;val now contains Fib(n - 1)
#+END_SRC
into one line:
#+BEGIN_SRC scheme
    (restore n)                         ;n now contains Fib(n - 1)
#+END_SRC
**** b.
Now =save= has to construct new data structure that associate value with the
name of register. For now let's just use pair for to do this work:
#+BEGIN_SRC scheme
(define (make-save inst machine stack pc)
  (let ((reg-name (stack-inst-reg-name inst)))
    (let ((reg (get-register machine reg-name)))
      (lambda ()
        (push stack (cons reg-name (get-contents reg)))
        (advance-pc pc)))))

(define (make-restore inst machine stack pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine reg-name)))
    (lambda ()
      (let* ((assoc-entry (pop stack))
             (assoc-name (car assoc-entry)))
        (if (eq? assoc-name reg-name)
            (set-contents! reg (pop stack))
            (error "Tried to restore value from register which is not one saved -- MAKE-RESTORE"))
        (advance-pc pc)))))
#+END_SRC

And test:
#+BEGIN_SRC scheme
(set-register-contents! test-5.11-machine 'y 6)
(set-register-contents! test-5.11-machine 'x 3)
(start test-5.11-machine)

;Tried to restore value from register which is not one saved -- MAKE-RESTORE
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

**** c.
Whenever =allocate-register= to machine it should also add new stack to the
stacks -- =Alist<reg-name x stack>=; then =save= & =restore= first lookup the
specific stack associated with given register and do usual stack manipulations.

To initialize, it sends =initialize= messages each of stack in stacks.

#+BEGIN_SRC scheme
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stacks '())
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stacks
                       (lambda () (for-each (lambda (stack) (stack 'initialize))
                                            stacks)))
...
              ((eq? message 'stacks) stacks)
...
))))))

(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stacks (machine 'stacks))
        (ops (machine 'operations)))
     ...)

(define (make-save inst machine stacks pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine reg-name)))
    (lambda ()
      (let ((stack (cadr (assoc reg-name stacks))))
        (push stack (get-contents reg)))
      (advance-pc pc))))

(define (make-restore inst machine stacks pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine
                            (stack-inst-reg-name inst))))
    (lambda ()
      (let ((stack (cadr (assoc reg-name stacks))))
        (set-contents! reg (pop stack)))
      (advance-pc pc))))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(set-register-contents! test-5.11-machine 'y 6)
(set-register-contents! test-5.11-machine 'x 3)
(start test-5.11-machine)

;Value: done

(get-register-contents test-5.11-machine 'y)

;Value: 6

(get-register-contents test-5.11-machine 'x)

;Value: 3
#+END_SRC

Works as expected.
*** Exercise 5.12
- a list of all instructions without duplicates, sorted by instruction type;

  We need to implement constructing procedure that is analogous to
  =merge-weighted= or ordered. We could have chosen to sort the instructions
  in alphabetical order without bothered by the instruction type, but I felt it
  is more canonical to order the result in the order of dispatch on type in
  =make-execution-procedure=.

  Here is one possible solution:
  #+BEGIN_SRC scheme
(define type-dict
  '((assign 1) (test 2) (branch 3) (goto 4)
    (save 5) (restore 6) (perform 7)))

(define (adjoin-ordered precede? item ordered)
  (if (null? ordered)
      (list item)
      (let ((first (first ordered)))
        (cond ((precede? item first)
               (cons item ordered))
              ((precede? first item)
               (cons first
                     (adjoin-ordered
                      precede? item (cdr ordered))))
              (else
               ;; given item already in the ordered
               ordered)))))

(define (inst-precede? inst1 inst2)
  (let ((type1 (car inst1))
        (type2 (car inst2)))
    (let ((mapped1 (cadr (assoc type1 type-dict)))
          (mapped2 (cadr (assoc type2 type-dict))))
      (cond ((< mapped1 mapped2) true)
            ((> mapped1 mapped2) false)
            (else
             ;; same number
             (not (equal? inst1 inst2)) ;just exclude the same one
             )))))

;; First request
(define (assemble controller-text machine receive)
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      (receive
          insts
          (fold-right (lambda (inst ordered)
                        (adjoin-ordered inst-precede? inst ordered))
                      '()
                      (map (lambda (inst) (instruction-text inst))
                           insts))))))
  #+END_SRC

  Here we used the continuation to hand over the updated instructions with the
  newly constructed a list of all instructions:
  #+BEGIN_SRC scheme
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) register-name))
              register-names)
    ((machine 'install-operations) ops)
    (assemble controller-text machine
               (lambda (instructions all-instructions)
                 ((machine 'install-instruction-sequence)
                  instructions)
                 ((machine 'install-all-instructions)
                  all-instructions)))
    machine))
  #+END_SRC

  And modify the =make-new-machine= accordingly. Then test with Fibonacci
  machine:
  #+BEGIN_SRC scheme
(pp (fib-machine 'all-instructions))
((assign continue (label fib-done))
 (assign continue (label afterfib-n-1))
 (assign n (op -) (reg n) (const 1))
 (assign n (op -) (reg n) (const 2))
 (assign continue (label afterfib-n-2))
 (assign n (reg val))
 (assign val (op +) (reg val) (reg n))
 (assign val (reg n))
 (test (op <) (reg n) (const 2))
 (branch (label immediate-answer))
 (goto (label fib-loop))
 (goto (reg continue))
 (save continue)
 (save n)
 (save continue)
 (save val)
 (restore n)
 (restore continue)
 (restore val)
 (restore continue))
;Unspecified return value
  #+END_SRC

  Unfortunately, our implementation was wrong! the duplicates appear in the
  result. So we need to arrange in strict order:
  #+BEGIN_SRC scheme
(define (inst-precede? inst1 inst2)
  (let ((type1 (car inst1))
        (type2 (car inst2)))
    (let ((mapped1 (cadr (assoc type1 type-dict)))
          (mapped2 (cadr (assoc type2 type-dict))))
      (cond ((< mapped1 mapped2) true)
            ((> mapped1 mapped2) false)
            (else
             ;; same number
             ;; (not (equal? inst1 inst2)) ;just exclude the same one
             (symbol<? (hash-symbol-list (cdr inst1))
                       (hash-symbol-list (cdr inst2)))
             )))))

(define (hash-symbol-list slst)
  (fold-right
   (lambda (s appended)
     (symbol-append s appended))
   '||
   (flatten slst)))

;; Test hash-symbol-list
;; (hash-symbol-list '(a b (c d e) f g))
;; ;Value: abcdefg


;; Tree<A> -> List<A>
(define (flatten tree)
  (tree-map list append '() tree))

;; Test flatten
;; (flatten '(1 (2 3) (4 (5 6) 7)))
;; ;Value: (1 2 3 4 5 6 7)


;; (Leaf<A> -> B), (B, B -> B), B, Tree<A>
;; -> B
(define (tree-map leaf-op combine-op initial tree)
  (cond ((null? tree) initial)
        ((not (pair? tree)) (leaf-op tree))
        (else                           ;pair
         (combine-op
          (tree-map leaf-op combine-op initial
                    (car tree))
          (tree-map leaf-op combine-op initial
                    (cdr tree))))))
  #+END_SRC

  For the reminding purpose, we implemented other high order procedure also.
  Then let's re-test
  #+BEGIN_SRC scheme
(pp (fib-machine 'all-instructions))
((assign continue (label afterfib-n-1))
 (assign continue (label afterfib-n-2))
 (assign continue (label fib-done))
 (assign n (op -) (reg n) (const 1))
 (assign n (op -) (reg n) (const 2))
 (assign n (reg val))
 (assign val (op +) (reg val) (reg n))
 (assign val (reg n))
 (test (op <) (reg n) (const 2))
 (branch (label immediate-answer))
 (goto (label fib-loop))
 (goto (reg continue))
 (save continue)
 (save n)
 (save val)
 (restore continue)
 (restore n)
 (restore val))
;Unspecified return value
  #+END_SRC

  Now it returns what we expected.
- a list (without duplicates) of the registers used to hold entry points (these
  are the registers referenced by =goto= instructions);

  To do this task, we reuse what the result from the previous task. Here is the
  strategy:
  1. Filter the all instructions with =goto-exp?=;

  2. using =map=, extract the =goto-dest= part;

  3. filter that with =register-exp?=;

  4. and lastly, extract the =register-exp-reg= part and that is what we wanted.

    Here is the code do this idea:
    #+BEGIN_SRC scheme
  ,*** in assemble
  (let* ((all-insts
          (fold-right (lambda (inst ordered)
                        (adjoin-ordered inst-precede? inst ordered))
                      '()
                      (map (lambda (inst) (instruction-text inst))
                           insts)))
         (entry-regs
          (filter-map
           (lambda (goto-inst)
             (let ((dest (goto-dest goto-inst)))
               (and (register-exp? dest)
                    (register-exp-reg dest))))
           (take-while
            (lambda (inst)
              (eq? (car inst) 'goto))
            (drop-while
             (lambda (inst)
               (not (eq? (car inst) 'goto)))
             all-insts)))))
    (accept
     insts
     all-insts
     entry-regs))
    #+END_SRC

    We've integrate *2.* to *4.* part using =filter-map=; and for the first one,
    we used =take-while= and =drop-while= exploiting the fact that all
    instructions are sorted in types.

    Then test:
    #+BEGIN_SRC scheme
  (pp (fib-machine 'registers-with-entry))
  (continue)
  ;Unspecified return value
    #+END_SRC
- a list (without duplicates) of the registers that are =save= d or =restore= d;

  This is analogous to the preceding one:
  #+BEGIN_SRC scheme
,*** in let expression of assemble
(stack-related-regs
 (map
  (lambda (inst)
    (stack-inst-reg-name inst))
  (take-while
   (lambda (inst)
     (or (eq? (car inst) 'save)
         (eq? (car inst) 'restore)))
   (drop-while
    (lambda (inst)
      (not (eq? (car inst) 'save)))
    all-insts))))
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(pp (fib-machine 'stack-instruction-registers))
(continue n val continue n val)
;Unspecified return value
  #+END_SRC

  Huh! It's not what we expected. It is due to that we count one for the =save=
  and one for the =restore=, which usually end up with duplicates names.

  So let's fix it using the =adjoin-ordered=:
  #+BEGIN_SRC scheme
(stack-related-regs
 (fold-right
  (lambda (reg-name regs)
    (adjoin-ordered
     symbol<?
     reg-name
     regs))
  '()
  (map (lambda (inst)
         (stack-inst-reg-name inst))
       (take-while
        (lambda (inst)
          (or (eq? (car inst) 'save)
              (eq? (car inst) 'restore)))
        (drop-while
         (lambda (inst)
           (not (eq? (car inst) 'save)))
         all-insts)))))
  #+END_SRC

  Then we got
  #+BEGIN_SRC scheme
(pp (fib-machine 'stack-instruction-registers))
(continue n val)
;Unspecified return value
  #+END_SRC

- for each register, a list (without duplicates) of the sources from which it is
  assigned.

  Notice that the register source relations can be deduced directly from the
  =assign= expressions. So here we attempt to solve this task using the
  following strategy:
  1. Assume we have table data structure that has key /values/ entries. That is,
     if one insert key value pair into the given table, the value adjoined into
     the value list of given key.

  2. Then filter out the all instructions into =assign= expressions, and then
     insert the =assign-reg-name= as key and the =assign-value-exp= as value
     into the above table.

  3. The rest is interfacing this with the machine object; one can retrieve the
     sources of given register using the message, =sources-of=.

  Here is the code:
  #+BEGIN_SRC scheme
,*** in assemble let expression
(reg-sources-table
 (let ((tbl (make-multivalues-table)))
   (for-each
    (lambda (inst)
      ((tbl 'insert!)
       (assign-reg-name inst)
       (assign-value-exp inst)))
    (take-while
     (lambda (inst)
       (eq? (car inst) 'assign))
     all-insts))
   tbl))
  #+END_SRC

  Then what assumed:
  #+BEGIN_SRC scheme
(define (make-multivalues-table)
  (let ((local-table '(*table*)))
    (define (lookup-vals key)
      (cond ((assoc key (cdr local-table)) => cdr)
            (else false)))
    (define (insert-value! key value)
      (let ((entry (assoc key (cdr local-table))))
        (if entry
            (set-cdr! entry
                      (cons value (cdr entry)))
            (set-cdr! local-table
                      (cons (cons key (list value))
                            (cdr local-table))))))
    (lambda (m)
      (case m
        ((lookup) lookup-vals)
        ((insert!) insert-value!)
        (else
         (error "Unknown request -- MAKE-MULTIVALUES-TABLE" m))))))

;; Test for make-multivalues-table
;; (define x (make-multivalues-table))
;; ((x 'insert!) 'a 5)
;; ((x 'lookup) 'a)
;; ;; (5)
;; ((x 'insert!) 'a 2)
;; ((x 'lookup) 'a)
;; ;; (2 5)
;; ((x 'insert!) 'b 2)
;; ((x 'lookup) 'b)
;; ;; (2)
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(pp ((fib-machine 'sources-of) 'n))
(((reg val)) ((op -) (reg n) (const 2)) ((op -) (reg n) (const 1)))
;Unspecified return value
  #+END_SRC
*** Exercise 5.13
We can what we want by modifying =get-register= procedure, which called in the
=make-execution-procedure= to reference the register object allocated in given
machine.

But it is not good idea to alter the existing =get-register= procedure since it
may interface with other process also as its contract is not just for the
=make-execution-procedure=.

So it would be better to make procedure that is analogous to =get-register= but
it allocates given register name whenever it has not been allocated in given
machine. If given register name already allocated in given machine, then it
should works like =get-register=.

With this idea, we can do the task what we requested. After implementing this
idea, we are good to discard the preallocating process in the =make-machine=.

#+BEGIN_SRC scheme
,*** within make-new-machine
(define (try-allocate-and-return-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (begin (allocate-register name)
                     (lookup-register name)))))
,*** in the dispatch
((eq? message 'try-allocate-and-get-register)
               try-allocate-and-return-register)
#+END_SRC

Then
#+BEGIN_SRC scheme
(define (make-sure-allocate-register-and-get machine reg-name)
  ((machine 'try-allocate-and-get-register) reg-name))
#+END_SRC

And we should replace all the subprocesses of =assemble= to use
=make-sure-allocate-register-and-get= instead of =get-register=:
#+BEGIN_SRC scheme
(define (make-assign inst machine labels operations pc)
  (let ((target
         (make-sure-allocate-register-and-get machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()                ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))

(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (make-sure-allocate-register-and-get machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction -- ASSEMBLE"
                       inst)))))

(define (make-save inst machine stack pc)
  (let ((reg (make-sure-allocate-register-and-get machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (make-sure-allocate-register-and-get machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))

(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (make-sure-allocate-register-and-get machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type -- ASSEMBLE" exp))))
#+END_SRC

Now =make-machine= gets
#+BEGIN_SRC scheme
(define (make-machine ops controller-text)
  (let ((machine (make-new-machine)))
    ((machine 'install-operations) ops)
    (assemble controller-text machine
              (lambda (instructions
                       all-instructions registers-with-entry
                       stack-inst-regs reg-sources-table)
                ((machine 'install-instruction-sequence)
                 instructions)
                ((machine 'install-all-instructions)
                 all-instructions)
                ((machine 'install-registers-with-entry)
                 registers-with-entry)
                ((machine 'install-stack-instruction-registers)
                 stack-inst-regs)
                ((machine 'install-register-sources-table)
                 reg-sources-table)))
    machine))
#+END_SRC

And let's test:
#+BEGIN_SRC scheme
(define fib-machine
  (make-machine
   `((< ,<) (- ,-) (+ ,+))
   '((assign continue (label fib-done))
     fib-loop
     (test (op <) (reg n) (const 2))
     (branch (label immediate-answer))
     ;; set up to compute Fib(n-1)
     (save continue)
     (assign continue (label afterfib-n-1))
     (save n)                            ; save old value of n
     (assign n (op -) (reg n) (const 1)) ; clobber n to n-1
     (goto (label fib-loop))             ; perform recursive call
     afterfib-n-1                        ; upon return, val contains Fib(n-1)
     (restore n)
     (restore continue)
     ;; set up to compute Fib(n-2)
     (assign n (op -) (reg n) (const 2))
     (save continue)
     (assign continue (label afterfib-n-2))
     (save val)                         ; save Fib(n-1)
     (goto (label fib-loop))
     afterfib-n-2                       ; upon return, val contains Fib(n-2)
     (assign n (reg val))               ; n now contains Fib(n-2)
     (restore val)                      ; val now contains Fib(n-1)
     (restore continue)
     (assign val                        ; Fib(n-1)+Fib(n-2)
             (op +) (reg val) (reg n))
     (goto (reg continue))              ; return to caller, answer is in val
     immediate-answer
     (assign val (reg n))               ; base case: Fib(n)=n
     (goto (reg continue))
     fib-done)))

;Value: fib-machine

(set-register-contents! fib-machine 'n 4)

;Value: done

(start fib-machine)

;Value: done

(get-register-contents fib-machine 'val)

;Value: 3
#+END_SRC

Works well.
** Monitoring Machine Performance
*** Exercise 5.14
#+BEGIN_SRC scheme
 (define fact-machine
  (make-machine
   `((= ,=) (- ,-) (* ,*))
   '(
     (perform (op initialize-stack))
     (assign continue (label fact-done)) ; set up final return address
     fact-loop
     (test (op =) (reg n) (const 1))
     (branch (label base-case))
     ;; Set up for the recursive call by saving n and continue.
     ;; Set up continue so that the computation will continue
     ;; at after-fact when the subroutine returns.
     (save continue)
     (save n)
     (assign n (op -) (reg n) (const 1))
     (assign continue (label after-fact))
     (goto (label fact-loop))
     after-fact
     (restore n)
     (restore continue)
     (assign val (op *) (reg n) (reg val)) ; val now contains n(n-1)!
     (goto (reg continue))                 ; return to caller
     base-case
     (assign val (const 1))             ; base case: 1!=1
     (goto (reg continue))              ; return to caller
     fact-done
     (perform (op print-stack-statistics)))))
#+END_SRC

Then here is the experiment cases:
#+BEGIN_SRC scheme
(set-register-contents! fact-machine 'n 10)

;Value: done

(start fact-machine)

(total-pushes = 18 maximum-depth = 18)
;Value: done

(set-register-contents! fact-machine 'n 20)

;Value: done

(start fact-machine)

(total-pushes = 38 maximum-depth = 38)
;Value: done

(set-register-contents! fact-machine 'n 2)

;Value: done

(start fact-machine)

(total-pushes = 2 maximum-depth = 2)
;Value: done
#+END_SRC

From this data, we can deduce that =total-pushes= and =maximum-depth= are same
and the general formula for this in terms of =n= is $T(n) = 2n-2$.

Or using =read=:
#+BEGIN_SRC scheme
(start fact-machine)
5

(total-pushes = 8 maximum-depth = 8)
;Value: done

(start fact-machine)
35

(total-pushes = 68 maximum-depth = 68)
;Value: done
#+END_SRC
*** Exercise 5.15
We need to modify the =make-new-machine= procedure to include =number-execs= to
accommodate new feature specified in the statement.

And define as internal definition of that procedure the following print method:
#+BEGIN_SRC scheme
(define (print-statistics)
        (newline)
        (display
         `(tatal-executions = ,number-execs)))
#+END_SRC

And modify =execute=:
#+BEGIN_SRC scheme
(define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (set! number-execs (1+ number-execs))
                (execute)))))
#+END_SRC

And interface with the rest:
#+BEGIN_SRC scheme
,*** in dispatch
              ((eq? message 'print-statistics) (print-statistics))
              ((eq? message 'initialize-statistics) (set! number-execs 0))
#+END_SRC

Now we can use as follows:
#+BEGIN_SRC scheme
(set-register-contents! fib-machine 'n 10)

;Value: done

(start fib-machine)

;Value: done

(fib-machine 'print-statistics)

(tatal-executions = 2029)
;Unspecified return value

(fib-machine 'initialize-statistics)

;Value: 2029

(set-register-contents! fib-machine 'n 20)

;Value: done

(start fib-machine)

;Value: done

(fib-machine 'print-statistics)

(tatal-executions = 251740)
;Unspecified return value
#+END_SRC

Exponential growth verified!
*** Exercise 5.16
1. Make =make-new-machine= have =trace?= as state variable, which can be on and
   off by the message =trace-on= and =trace-off=.
2. Then in the =execute= procedure, if =trace?= then it should print out the
   instruction text -- by using the =instruction-text= selector.


Then test
#+BEGIN_SRC scheme
(fib-machine 'trace-on)

;Value: #f

(set-register-contents! fib-machine 'n 3)

;Value: done

(start fib-machine)

(assign continue (label fib-done))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(save continue)
(assign continue (label afterfib-n-1))
(save n)
(assign n (op -) (reg n) (const 1))
(goto (label fib-loop))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(save continue)
(assign continue (label afterfib-n-1))
(save n)
(assign n (op -) (reg n) (const 1))
(goto (label fib-loop))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(assign val (reg n))
(goto (reg continue))
(restore n)
(restore continue)
(assign n (op -) (reg n) (const 2))
(save continue)
(assign continue (label afterfib-n-2))
(save val)
(goto (label fib-loop))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(assign val (reg n))
(goto (reg continue))
(assign n (reg val))
(restore val)
(restore continue)
(assign val (op +) (reg val) (reg n))
(goto (reg continue))
(restore n)
(restore continue)
(assign n (op -) (reg n) (const 2))
(save continue)
(assign continue (label afterfib-n-2))
(save val)
(goto (label fib-loop))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(assign val (reg n))
(goto (reg continue))
(assign n (reg val))
(restore val)
(restore continue)
(assign val (op +) (reg val) (reg n))
(goto (reg continue))
;Value: done
#+END_SRC
*** Exercise 5.17
Here we should think of what abstraction level we are going to modify. Since the
tracing things is about in the =make-new-machine= procedure, we may need to the
machine object to possess label information.

But we do not want break the ADT about the label data, it would be better to
offer lookup method with the label data from outside of machine object.

And also construct additional ADT:
#+BEGIN_SRC scheme
;;; ADT for labels package which going to be installed into machine object
(define (make-labels-package find-from-key find-from-val labels)
  (list find-from-key find-from-val labels))
(define (find-from-key-proc labels-pack)
  (car labels-pack))
(define (find-from-val-proc labels-pack)
  (cadr labels-pack))
(define (labels-data labels-pack)
  (caddr labels-pack))

;; operate on labels-package
(define (find-from-val labels-pack)
  (lambda (val)
    ((find-from-val-proc labels-pack)
     val
     (labels-data labels-pack))))

(define (find-from-key labels-pack)
  (lambda (key)
    ((find-from-key-proc labels-pack)
     key
     (labels-data labels-pack))))
#+END_SRC

Then define the retriever:
#+BEGIN_SRC scheme
;; selector of labels
(define retrive-label-from-insts
  (association-procedure eq? cdr))
#+END_SRC

The rest is interface with the others:
#+BEGIN_SRC scheme
,*** in assemble
(accept
 insts
 (make-labels-package
  get-label
  retrive-label-from-insts
  labels)
 all-insts
 entry-regs
 stack-related-regs
 reg-sources-table)

,*** in make-machine
((machine 'install-labels-package)
 labels-package)

,*** in execute in the make-new-machine
(let ((inst (car insts)))
  (if trace?
      (let ((label-entry ((find-from-val labels-package)
                          insts)))
        (if label-entry
            (begin (newline)
                   (display (label-name label-entry))))
        (begin (newline)
               (display (instruction-text inst)))))
  ((instruction-execution-proc inst))
  (set! number-execs (1+ number-execs))
  (execute))
#+END_SRC

=Label-name= and =get-label= are defined in [[Exercise 5.8][exercise 5.8]].

Then test
#+BEGIN_SRC scheme
(start fib-machine)

(assign continue (label fib-done))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(save continue)
(assign continue (label afterfib-n-1))
(save n)
(assign n (op -) (reg n) (const 1))
(goto (label fib-loop))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(save continue)
(assign continue (label afterfib-n-1))
(save n)
(assign n (op -) (reg n) (const 1))
(goto (label fib-loop))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
immediate-answer
(assign val (reg n))
(goto (reg continue))
afterfib-n-1
(restore n)
(restore continue)
(assign n (op -) (reg n) (const 2))
(save continue)
(assign continue (label afterfib-n-2))
(save val)
(goto (label fib-loop))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
immediate-answer
(assign val (reg n))
(goto (reg continue))
afterfib-n-2
(assign n (reg val))
(restore val)
(restore continue)
(assign val (op +) (reg val) (reg n))
(goto (reg continue))
afterfib-n-1
(restore n)
(restore continue)
(assign n (op -) (reg n) (const 2))
(save continue)
(assign continue (label afterfib-n-2))
(save val)
(goto (label fib-loop))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
immediate-answer
(assign val (reg n))
(goto (reg continue))
afterfib-n-2
(assign n (reg val))
(restore val)
(restore continue)
(assign val (op +) (reg val) (reg n))
(goto (reg continue))
;Value: done
#+END_SRC
*** Exercise 5.18
It is analogous to the previous one:
#+BEGIN_SRC scheme
(define (make-register name)
  (let ((contents '*unassigned*)
        (trace? #f))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value)
               (if trace?
                   (begin (newline)
                          (display `(Register ,name gets ,value from ,contents))))
               (set! contents value)))
            ((eq? message 'trace-on)
             (set! trace? #t))
            ((eq? message 'trace-off)
             (set! trace? #f))
            (else
             (error "Unknown request -- REGISTER" message))))
    dispatch))
#+END_SRC

Then unit test:
#+BEGIN_SRC scheme
(define x (make-register 'x))
(x 'trace-on)
((x 'set) 5)

(register x gets 5 from *unassigned*)
;Value: *unassigned*
#+END_SRC

All the rest is to interface in the =make-new-machine=:
#+BEGIN_SRC scheme
,*** in make-new-machine
              ((eq? message 'trace-on-register)
               (lambda (reg-name)
                 ((lookup-register reg-name) 'trace-on)))
              ((eq? message 'trace-off-register)
               (lambda (reg-name)
                 ((lookup-register reg-name) 'trace-off)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
((fib-machine 'trace-on-register) 'n)

;Value: #f

(set-register-contents! fib-machine 'n 3)

(register n gets 3 from *unassigned*)
;Value: done

(start fib-machine)

(register n gets 2 from 3)
(register n gets 1 from 2)
(register n gets 2 from 1)
(register n gets 0 from 2)
(register n gets 0 from 0)
(register n gets 3 from 0)
(register n gets 1 from 3)
(register n gets 1 from 1)
;Value: done
#+END_SRC
*** Exercise 5.19
This is a analogous feature to =start= procedure; but use =label= data. The
specifications on the procedures that manipulate break points indicates we need
to define new data structure that keeps track of all the break points.

As we noted before, our machine now has the information about the label as its
state variable, we can transform the specifications of where the break point
should be into the actual instruction. So here we are going to store this
transformed information as the break points data structure -- so called internal
data.

For the break points data structure, we need to remove the specified break point
from the structure; it means we should mutate the data structure. So we'd better
to give the data structure identity. For this purpose, we'll implement the break
points as headed list to possess identity.

And more, we should keep track of the current break point since we should
support the =proceed-machine= procedure. We can exploit dummy head of the headed
list possessing this additional information. Or

Then here is the code
#+BEGIN_SRC scheme
,*** as state variable of make-new-machine
        (break-points '(#f))
...
,*** internal defintions of make-new-machine
      (define (cdring-down lst n)
        (if (= n 1)
            lst
            (cdring-down (cdr lst)
                         (-1+ n))))
      (define (add-break-point label n)
        (let ((break-point
               (cdring-down ((find-from-key labels-package) label)
                            n)))
          (if (memq break-point (cdr break-points))
              (error "Given break point already in break points -- ADD-BREAK-POINT"
                     (list label n))
              (set-cdr! break-points (cons break-point
                                           (cdr break-points))))))
      (define (remove-break-point label n)
        (let ((break-point
               (cdring-down ((find-from-key labels-package) label)
                            n)))
          (let loop ((items break-points))
            (cond ((null? (cdr items))
                   (error "Given break point not in break points -- REMOVE-BREAK-POINT"
                          (list label n)))
                  ((eq? (cadr items) break-point)
                   (set-cdr! items (cddr items)))
                  (else (loop (cdr items)))))))
#+END_SRC

Then =execute= gets complicated than before:
#+BEGIN_SRC scheme
(define (execute)
  (let ((insts (get-contents pc)))
    (cond ((null? insts) 'done)
          ((car break-points) ;the right after instruction from the broken
           (set-car! break-points #f)
           (execute))
          ((and (not (eq? (car break-points) insts)) ;ensure this is not the point broken
                (memq insts (cdr break-points)))
           (set-car! break-points insts) ;save the broken point
           'broken)
          (else
           (let ((inst (car insts)))
             (if trace?
                 (let ((label-entry ((find-from-val labels-package)
                                     insts)))
                   (if label-entry
                       (begin (newline)
                              (display (label-name label-entry))))
                   (begin (newline)
                          (display (instruction-text inst)))))
             ((instruction-execution-proc inst))
             (set! number-execs (1+ number-execs))
             (execute))))))
#+END_SRC

And interfaces:
#+BEGIN_SRC scheme
,*** in dispatch
              ((eq? message 'proceed-machine)
               (if (car break-points)
                   (begin (set-contents! pc (car break-points))
                          (execute))
                   (error "There in no broken point to proceed from -- PROCEED-MACHINE")))
              ((eq? message 'set-breakpoint)
               add-break-point)
              ((eq? message 'cancel-breakpoint)
               remove-break-point)
              ((eq? message 'cancel-all-breakpoints)
               (set! break-points '(#f)))
#+END_SRC

To procedural syntax:
#+BEGIN_SRC scheme
(define (set-breakpoint machine label n)
  ((machine 'set-breakpoint) label n))

(define (cancel-breakpoint machine label n)
  ((machine 'cancel-breakpoint) label n))

(define (proceed-machine machine)
  (machine 'proceed-machine))

(define (cancel-all-breakpoints machine)
  (machine 'cancel-all-breakpoints))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
(set-breakpoint gcd-machine 'test-b 4)

;The object test-b, passed as an argument to assoc, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

It is due to that the =find-from-val= and =find-from-key= does not agree in
where the =labels= should position. Let us make them consist along with
=loopup-label=.

Then re-run the test:
#+BEGIN_SRC scheme
(set-register-contents! gcd-machine 'a 202)

;Value: done

(set-register-contents! gcd-machine 'b 43)

;Value: done

(set-breakpoint gcd-machine 'test-b 4)

;Unspecified return value

(gcd-machine 'trace-on)

;Value: #f

(start gcd-machine)

test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
;Value: broken

(proceed-machine gcd-machine)

;Value: broken
#+END_SRC

Unfortunately our =proceed-machine= does not work as expected.

We should have defined as follows
#+BEGIN_SRC scheme
(define (execute)
        (let ((insts (get-contents pc)))
          (cond ((null? insts) 'done)
                ((and (car break-points) ;the right after instruction from the broken
                      (not (eq? (car break-points) insts)))
                 (set-car! break-points #f)
                 (execute))
                ((and (not (eq? (car break-points) insts)) ;ensure this is not the point broken
                      (memq insts (cdr break-points)))
                 (set-car! break-points insts) ;save the broken point
                 'broken)
                (else
                 (let ((inst (car insts)))
                   (if trace?
                       (let ((label-entry ((find-from-val labels-package)
                                           insts)))
                         (if label-entry
                             (begin (newline)
                                    (display (label-name label-entry))))
                         (begin (newline)
                                (display (instruction-text inst)))))
                   ((instruction-execution-proc inst))
                   (set! number-execs (1+ number-execs))
                   (execute))))))
#+END_SRC

Now it works as expected:
#+BEGIN_SRC scheme
(start gcd-machine)

test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
;Value: broken

(proceed-machine gcd-machine)

(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
;Value: broken

(cancel-breakpoint gcd-machine 'test-b 4)

;Unspecified return value

(proceed-machine gcd-machine)

(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
;Value: done

#+END_SRC
* Storage Allocation and Garbage Collection
** Memory as Vectors
*** Exercise 5.20
I've drawn this diagram with my digital paper.
*** Exercise 5.21
**** a.
#+BEGIN_SRC scheme
(controller
 (assign continue (label count-done))
 count-leaves-loop
 (test (op null?) (reg tree))
 (branch (label base-case))
 ;; (test (op pair?) (reg tree))
 ;; (test (op not) (reg flag))
 (assign t (op pair?) (reg tree))
 (test (op not) (reg t))
 (branch (label count-case))
 (save continue)          ;setup recursive call -- (count-leaves (car tree))
 (assign continue (label after-car-tree))
 (save tree)
 (assign tree (op car) (reg tree))
 (goto (label count-leaves-loop))
 after-car-tree
 (assign continue (label after-cdr-tree))
 (restore tree)                     ;setup recursive call -- (count-leaves (cdr tree))
 (save val)
 (assign tree (op cdr) (reg tree))
 (goto (label count-leaves-loop))
 after-cdr-tree
 (restore t)
 (assign val (op +) (reg val) (reg t))
 (restore continue)
 (goto (reg continue))
 base-case
 (assign val (const 0))
 (goto (reg continue))
 count-case
 (assign val (const 1))
 (goto (reg continue))
 count-done)
#+END_SRC

To implement above register machine program, you need to use the wishful
thinking as we did in higher level procedure. For the commented code, it would
work if we use the commented code other than using intermediate register t, but
in anyway we will need =t= in later in the code, so it would be better not to
use the =flag= directly.

Then test:
#+BEGIN_SRC scheme
(define count-leaves-machine-a
  (make-machine
   `((null? ,null?)
     (pair? ,pair?)
     (not ,not)
     (+ ,+)
     (car ,car)
     (cdr ,cdr))
   '(
     (assign continue (label count-done))
     count-leaves-loop
     (test (op null?) (reg tree))
     (branch (label base-case))
     ;; (test (op pair?) (reg tree))
     ;; (test (op not) (reg flag))
     (assign t (op pair?) (reg tree))
     (test (op not) (reg t))
     (branch (label count-case))
     (save continue)          ;setup recursive call -- (count-leaves (car tree))
     (assign continue (label after-car-tree))
     (save tree)
     (assign tree (op car) (reg tree))
     (goto (label count-leaves-loop))
     after-car-tree
     (assign continue (label after-cdr-tree))
     (restore tree)                     ;setup recursive call -- (count-leaves (cdr tree))
     (save val)
     (assign tree (op cdr) (reg tree))
     (goto (label count-leaves-loop))
     after-cdr-tree
     (restore t)
     (assign val (op +) (reg val) (reg t))
     (restore continue)
     (goto (reg continue))
     base-case
     (assign val (const 0))
     (goto (reg continue))
     count-case
     (assign val (const 1))
     (goto (reg continue))
     count-done)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(set-register-contents! count-leaves-machine-a 'tree '(1 2 (3 4 (5 6) (7))))

(start count-leaves-machine-a)

;Value: done

(get-register-contents count-leaves-machine-a 'val)

;Value: 7
#+END_SRC
**** b.
The next one:
#+BEGIN_SRC scheme
(controller
 (assign n (const 0))
 (assign continue (label count-done))
 count-loop
 (test (op null?) (reg tree))
 (branch (label base-case))
 (test (op pair?) (reg tree))
 (test (op not) (reg flag))
 (branch (label count-case))
 (save continue)                    ;else clause
 (assign continue (label after-car))
 (save tree)
 (assign tree (op car) (reg tree))
 (goto (label count-loop))
 after-car
 (restore tree)
 (assign tree (op cdr) (reg tree))
 (assign continue (label after-cdr))
 (goto (label count-loop))
 after-cdr
 (restore continue)
 (goto (reg continue))
 base-case
 (goto (reg continue))
 count-case
 (assign n (op 1+) (reg n))
 (goto (reg continue))
 count-done)
#+END_SRC

Note that here we done need to use any additional register than =n= for
returning value.

And test:
#+BEGIN_SRC scheme
(set-register-contents! count-leaves-machine-b 'tree '(1 2 (3 4 (5) (6 (7)))))

;Value: done

(start count-leaves-machine-b)

;Value: done

(get-register-contents count-leaves-machine-b 'n)

;Value: 7
#+END_SRC
*** Exercise 5.22
The functional version of =append=:
#+BEGIN_SRC scheme
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
#+END_SRC

Then the trasformed version:
#+BEGIN_SRC scheme
(define append-machine
  (make-machine
   '(x continue y)
   `((null? ,null?) (pair? ,pair?)
     (car ,car) (cdr ,cdr) (cons ,cons))
   '((assign continue (label append-done))
     append-loop
     (test (op null?) (reg x))
     (branch (label base-case))
     (save continue)
     (assign continue (label after-recur))
     (save x)
     (assign x (op cdr) (reg x))
     (goto (label append-loop))
     after-recur
     (restore x)
     (assign x (op car) (reg x))
     (assign y (op cons) (reg x) (reg y))
     (restore continue)
     (goto (reg continue))
     base-case
     (goto (reg continue))
     append-done)))
#+END_SRC

Now let's test this machine in this machine -- the result in the =y= register:
#+BEGIN_SRC scheme
(set-register-contents! append-machine 'x '(1 2 3))

;Value: done

(set-register-contents! append-machine 'y '(4 5 6))

;Value: done

(start append-machine)

;Value: done

(get-register-contents append-machine 'x)

;Value: 1

(get-register-contents append-machine 'y)

;Value: (1 2 3 4 5 6)
#+END_SRC

Then imperative version:
#+BEGIN_SRC scheme
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

#+END_SRC

Then here is the transformation in step:
#+BEGIN_SRC scheme
;; High level description -- assume last-pair as primitive
'(
  (assign l-p (op last-pair) (reg x))
  (perform (op set-cdr!) (reg l-p) (reg y))
  )

;;; last-pair unwinded
'(
  test-l-p
  (assign t (op cdr) (reg x))
  (test (op null?) (reg t))
  (branch (label last-pair-done))
  (assign x (reg t))
  (goto (label test-l-p))
  last-pair-done
  )

;; Then link together
'(
  test-l-p
  (assign t (op cdr) (reg l-p))
  (test (op null?) (reg t))
  (branch (label last-pair-done))
  (assign l-p (reg t))
  (goto (label test-l-p))
  last-pair-done
  (perform (op set-cdr!) (reg l-p) (reg y))
  )
#+END_SRC

Now we can construct machine we do this simulation; the result in =x= register.
#+BEGIN_SRC scheme
(define append!-machine
  (make-machine
   '(x y l-p t)
   `((set-cdr! ,set-cdr!) (cdr ,cdr) (null? ,null?))
   '(
     (assign l-p (reg x))
     test-l-p
     (assign t (op cdr) (reg l-p))
     (test (op null?) (reg t))
     (branch (label last-pair-done))
     (assign l-p (reg t))
     (goto (label test-l-p))
     last-pair-done
     (perform (op set-cdr!) (reg l-p) (reg y))
     )))
#+END_SRC

#+BEGIN_SRC scheme
(set-register-contents! append!-machine 'x '(1 2 3))

;Value: done

(set-register-contents! append!-machine 'y '(4 5 6))

;Value: done

(start append!-machine)

;Value: done

(get-register-contents append!-machine 'x)

;Value: (1 2 3 4 5 6)
#+END_SRC

Note that in this version, we haven't used any stack operation, that means this
is iterative process unlike the preceding implementation.
** Maintaining the Illusion of Infinite Memory
In this section, we are going to learn how our evaluator manage the memory under
the hood. This is quite simple and compact algorithm that we are going to see;
but it resolves a lot of difficulties otherwise we encountered with (or should
concern about).

To keep track of the contents of this section, you should draw diagram along with
emerging controller sequence as if you were a machine; otherwise you'll get feel
like you understood the core concept of this simple and compact algorithm but
only in spurious manner.
* The Explicit-Control Evaluator
Now we turn into the application of this new language. Actually this is not an
application but in more presentation about what's going on under the hood --
this is meant to explain what they assumed or omitted to describe in preceding
chapter, [[org:../MEGAsync/MIT Challenge/6.001/Chapter4.org][Metacircular Evaluator]].

Through this material, we will get the ability to implement meta circular
evaluator or even the other variants in hardware in principal. That is, if we
are patient enough to gathering all the stuffs to implement what we planned to
do, say the query language we developed in preceding chapter, we got the machine
in real world only for that purpose.

So for start, here they are going to /unwind/ the metacircular evaluator in
sections 4.1.1 through 4.1.4.

From this point, we can get some intuition behind this concept through the
[[youtube:ikvAQ_lu31s?list=PL7BcsI5ueSNFPCEisbaoQ0kXIDX9rR5FF][lectures]] available in [[youtube:cIc8ZBMcqAc?list=PLE18841CABEA24090][online]]. So for recapitulation or to understand what concepts
the authors consider as core, before to go through this section, we'd better to
go through all the material before this section -- Register Machines.

Actually we can deduce a lot of useful informations using contraction as we did
in procedural definition (or module) in static sense -- analogous to the type
contraction rather than behavior specifications. The [[youtube:1eQpcms7c98&t=635s][lecture]] explains this
concept consistently through this term of lectures.

So using the static information (deduced by static analysis by human not the
machine; thus for human), we can put together all the relevant parts into one
chuck along with the contracts not only in the high level language also in this
very low level assembly language uniformly.
** The Core of the Explicit-Control Evaluator
** Sequence Evaluation and Tail Recursion
To deal with the tail recursion, we need to handle the last expression in the
evaluation of sequence differently.
** Conditionals, Assignments, and Definitions
*** Exercise 5.23
#+BEGIN_SRC scheme
,*** in explicit control evaluator controller
    ;; Exercise 5.23 -- derived forms
    (test (op cond?) (reg exp))
    (branch (label ev-cond))
    (test (op let?) (reg exp))
    (branch (label ev-let))
    (test (op let*?) (reg exp))
    (branch (label ev-let*))
    ;; end of exercise 5.23
...
    (branch (label ev-application))
    (goto (label unknown-expression-type))


    ;; derived forms
    ev-cond
    (assign exp (op cond->if) (reg exp))
    (goto (label ev-if))
    ev-let
    (assign exp (op let->combination) (reg exp))
    (goto (label ev-application))
    ev-let*
    (assign exp (op let*->let) (reg exp))
    (goto (label ev-let))
    ;;
#+END_SRC

Here we used the assumption or "cheat," which isn't actually cheat according to
the footnote in the text. This is due to the analysis phase in our interpreter
as noted in section 4.1.4; all the expression analyzed statically and the source
level transformation is one of the static process, it is done at that phase. We
can verify this fact -- our interpreter do the static analysis before execution
-- with the following example:
#+BEGIN_SRC scheme
(lambda (x) (define y 5) (define y 2) x)

;duplicate internal definitions for (#[uninterned-symbol 38 y]) in |#[unnamed-procedure]|
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

If it were not doing the static analysis, it couldn't the duplicated internal
definitions since it is the body of lambda expression, which is not supposed to
be evaluated until it is applied.

Then test:
#+BEGIN_SRC scheme
(start eceval)

;;; EC-Eval input:
(cond (false 5) (false 2) (true 3) (else 1))

(total-pushes = 9 maximum-depth = 3)
;;; EC-Eval value:
3

;;; EC-Eval input:
(let* ((x 5) (y (+ x 2))) (+ x y))

(total-pushes = 26 maximum-depth = 8)
;;; EC-Eval value:
12

#+END_SRC
*** Exercise 5.24
=Cond= special form is like combination of =ev-if= and =ev-application=. That is
it need to loop through the clauses and for each clause like =evl-application=
loop through in =ev-appl-operand-loop=, and within that loop, it need to branch
depending on the evaluation of =cond-predicate= of each clause as =ev-if= did,
if it were true, it need to setup to call =ev-sequence= as
=ev-appl-accum-last-arg= did.

Here is the register code do the works:
#+BEGIN_SRC scheme
ev-cond
;; Input exp env continue
;; Output val
;; Write all (call the ev-sequence)
;; Stack unchanged
    (assign unev (op cond-clauses) (reg exp))
    (save continue)
cond-clause-loop
;; Input unev env stack (top as return point)
;; Output val
;; Write all
;; Stack top value removed
    (assign exp (op cond-first-clause) (reg unev))
    (test (op cond-else-clause?) (reg exp))
    (branch (label cond-else-clause))
    (test (op cond-last-clause?) (reg unev))
    (branch (label cond-last-clause))
cond-pred
    (save unev)
    (save exp)
    (save env)
    (assign exp (op cond-predicate) (reg exp))
    (assign continue (label cond-pred-decide))
    (goto (label eval-dispatch))
cond-pred-decide
    (restore env)
    (restore exp)
    (restore unev)
    (test (op true?) (reg val))
    (branch (label cond-actions))
    (assign unev (op cond-rest-clauses) (reg unev))
    (goto (label cond-clause-loop))
cond-actions
;; Input exp, env
;; Output val
;; Write all
;; Stack top removed
    (assign unev (op cond-actions) (reg exp))
    (goto (label ev-sequence))
cond-else-clause
    (test (op cond-last-clause?) (reg unev))
    (test (op not) (reg flag))
    (branch (label bad-cond-syntax))
    (goto (label cond-actions))
cond-last-clause
    (save exp)
    (save env)
    (assign exp (op cond-predicate) (reg exp))
    (assign continue (label cond-last-decide))
    (goto (label eval-dispatch))
cond-last-decide
    (restore env)
    (restore exp)
    (test (op true?) (reg val))
    (branch (label cond-actions))
    (restore continue)
    (goto (reg continue))
#+END_SRC

Now it works as expected:
#+BEGIN_SRC scheme
(start eceval)


;;; EC-Eval input:
(cond (false 5) (false 2) (true 3) (else 1))

(total-pushes = 10 maximum-depth = 4)
;;; EC-Eval value:
3

#+END_SRC

Now test the tail recursion problem:
#+BEGIN_SRC scheme
;;; from recitation 26 of 2004
(define (list? x)
  (cond ((null? x) true)
        ((pair? x) (list? (cdr x)))))
(define z (list 1))
(set-cdr! z z)
(list? z)
#+END_SRC

Then
#+BEGIN_SRC scheme
;;; EC-Eval input:
(define z (list 1))

(total-pushes = 8 maximum-depth = 6)
;;; EC-Eval value:
ok

;;; EC-Eval input:
(set-cdr! z z)

(total-pushes = 8 maximum-depth = 5)
;;; EC-Eval value:
#!unspecific

;;; EC-Eval input:
(list? z)
  C-c C-c;Quit!
#+END_SRC

Works as expected.
*** Exercise 5.25
As we learned from section 4.2, the only change is the application from the
applicative Scheme.

That is, rather than evaluating all the operands before application, we need to
hand over the operands without evaluating since the operands needed are
different in primitive procedure's from compound procedure's.

We also need to support additional data structure called thunk since it is
needed to distinguish the delayed object from the normal values.

Also we need to handle the =if= expression somewhat differently from the
applicative one since it need =actual-value= for value of its predicate part.

Note that we can not assume the =actual-value= (implicitly =force-it= too) is
available as machine operations as the text did; we need to unwind those
procedure explicitly into register subroutines since =actual-value= and
=force-it= wrapping around the =eval= process in it. So we need to unwrap those
until we got the procedures that does not inherit the any other process that is
implemented as subroutines in our register machine (but we are good to use the
=delay-it= procedure since it is just syntactic procedure or representation of
thunk ADT).

So to summarize, we can assume the following procedures as machine operators:
#+BEGIN_SRC scheme
;; Exercise 5.25 delayed one
(define (delay-it exp env)
  (list 'thunk exp env))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

;; "thunk" that has been forced and is storing its (memoized) value
(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
#+END_SRC

But we should implement the following ones as subroutines:
#+BEGIN_SRC scheme
(define (actual-value exp env)
  (force-it (eval exp env)))

(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)  ; replace exp with its value
           (set-cdr! (cdr obj) '())     ; forget unneeded env
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
#+END_SRC

Here is the code translated. Observe the similarity of the accumulation argument
loop between the primitive and compound one -- it is more easy to see in above
high level language description; if we want to do, we could have modulate the
duplicate code into one general subroutine which will accept more arguments as
input registers or on stack. We will come back this issue in later.

#+BEGIN_SRC scheme
ev-application
    (save continue)
    (save env)
    (assign unev (op operands) (reg exp))
    (save unev)
    (assign exp (op operator) (reg exp))
    (assign continue (label ev-appl-did-operator))
    (goto (label actual-value))
ev-appl-did-operator
    (restore unev)
    (restore env)
    (assign proc (reg val))
    (branch (label apply-dispatch))

apply-dispatch
    (assign argl (op empty-arglist))
;; Input proc, unev, env, stack -- top value is return point
;; Output val
;; Write all
;; Stack top value removed
    (test (op primitive-procedure?) (reg proc))
    (branch (label primitive-apply))
    (test (op compound-procedure?) (reg proc))
    (branch (label compound-apply))
    (goto (label unknown-procedure-type))

primitive-apply
    (test (op no-operands?) (reg unev))
    (branch (label exec-primitive-apply))
    (save proc)
primitive-operand-loop
    (save argl)
    (assign exp (op first-operand) (reg unev))
    (test (op last-operand?) (reg unev))
    (branch (label prim-last-arg))
    (save env)
    (save unev)
    (assign continue (label prim-accumulate-arg))
    (goto (label actual-value))
prim-accumulate-arg
    (restore unev)
    (restore env)
    (restore argl)
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (assign unev (op rest-operands) (reg unev))
    (goto (label primitive-operand-loop))
prim-last-arg
    (assign continue (label prim-accum-last-arg))
    (goto (label actual-value))
prim-accum-last-arg
    (restore argl)
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (restore proc)
    (goto (label exec-primitive-apply))
exec-primitive-apply
    (assign val (op apply-primitive-procedure)
        (reg proc)
        (reg argl))
    (restore continue)
    (goto (reg continue))

compound-apply
    (test (op no-operands?) (reg unev))
    (branch (label exec-compound-apply))
compound-operand-loop
    (assign exp (op first-operand) (reg unev))
    (test (op last-operand?) (reg unev))
    (branch (label compound-last-arg))
    (assign val (op delay-it) (reg exp) (reg env))
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (assign unev (op rest-operands) (reg unev))
    (goto (label compound-operand-loop))
compound-last-arg
    (assign val (op delay-it) (reg exp) (reg env))
compound-accum-last-arg
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (goto (label exec-compound-apply))

exec-compound-apply
    (assign unev (op procedure-parameters) (reg proc))
    (assign env (op procedure-environment) (reg proc))
    (assign env (op extend-environment)
        (reg unev) (reg argl) (reg env))
    (assign unev (op procedure-body) (reg proc))
    (goto (label ev-sequence))

ev-if
    (save exp)
    (save env)
    (save continue)
    (assign continue (label ev-if-decide))
    (assign exp (op if-predicate) (reg exp))
    (goto (label actual-value))
ev-if-decide
    (restore continue)
    (restore env)
    (restore exp)
    (test (op true?) (reg val))
    (branch (label ev-if-consequent))
ev-if-alternative
    (assign exp (op if-alternative) (reg exp))
    (goto (label eval-dispatch))
ev-if-consequent
    (assign exp (op if-consequent) (reg exp))
    (goto (label eval-dispatch))

actual-value
;; contract is same as eval-dispatch
    (save continue)
    (assign continue (label after-eval))
    (goto (label eval-dispatch))
after-eval
    (restore continue)
    (goto (label force-it))

force-it
;; Input val continue
;; Output val
;; Write all
;; Stack unchanged
    (test (op thunk?) (reg val))
    (branch (label force-thunk))
    (test (op evaluated-thunk?) (reg val))
    (branch (label force-evaluated))
    (goto (reg continue))

force-thunk
    (save continue)
    (save val)                              ;need later -- obj
    (assign continue (label force-result))
    (assign exp (op thunk-exp) (reg val))
    (assign env (op thunk-env) (reg val))
    (goto (label actual-value))

force-result
    (restore exp)                           ;clobbering the exp as obj
    (restore continue)
    (perform (op set-car!) (reg exp) (const evaluated-thunk))
    (assign exp (op cdr) (reg exp))
    (perform (op set-car!) (reg exp) (reg val))
    (perform (op set-cdr!) (reg exp) (const ()))
    (goto (reg continue))

force-evaluated
    (assign val (op thunk-value) (reg val))
    (goto (reg continue))
#+END_SRC

Now let's test:
#+BEGIN_SRC scheme
(start eceval)


;;; EC-Eval input:
(define (try a b)
  (if (= a 0) 1 b))

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
(try 0 (/ 1 0))

(total-pushes = 22 maximum-depth = 12)
;;; EC-Eval value:
1

#+END_SRC

It works as expected.
** Running the Evaluator
*** Exercise 5.26
**** a.
Since the defined procedure captured iterative process, we expect, if our
register machine handles the tail recursion correctly, the maximum stack depth
would not change:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(factorial 5)

(total-pushes = 204 maximum-depth = 10)
;;; EC-Eval value:
120

;;; EC-Eval input:
(factorial 3)

(total-pushes = 134 maximum-depth = 10)
;;; EC-Eval value:
6

;;; EC-Eval input:
(factorial 30)

(total-pushes = 1079 maximum-depth = 10)
;;; EC-Eval value:
265252859812191058636308480000000

#+END_SRC

And it turns out 10.
**** b.
From those data, and as it is linear, we can deduce the formular as $P(n) = 35n+29$.
*** Exercise 5.27
Here is the data:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(factorial 3)

(total-pushes = 80 maximum-depth = 18)
;;; EC-Eval value:
6

;;; EC-Eval input:
(factorial 10)

(total-pushes = 304 maximum-depth = 53)
;;; EC-Eval value:
3628800

;;; EC-Eval input:
(factorial 30)

(total-pushes = 944 maximum-depth = 153)
;;; EC-Eval value:
265252859812191058636308480000000

#+END_SRC

From this fact, we can deduce the =maximum-depth= as $5n + 3$, and
=total-pushes= as $32n - 16$.

So the table gets as

|           | Maximum depth | Number of pushes |
|-----------+---------------+------------------|
| Recursive | 5n + 3        | 32n - 16         |
| factorial |               |                  |
|-----------+---------------+------------------|
| Iterative | 10            | 35n + 29         |
| factorial |               |                  |
*** Exercise 5.28
Let's modify our register machine not to be tail recursive. Then let's re-run
[[Exercise 5.26][exercise 5.26]]'s factorial -- iterative one:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(factorial 5)

(total-pushes = 218 maximum-depth = 29)
;;; EC-Eval value:
120

;;; EC-Eval input:
(factorial 3)

(total-pushes = 144 maximum-depth = 23)
;;; EC-Eval value:
6

;;; EC-Eval input:
(factorial 30)

(total-pushes = 1143 maximum-depth = 104)
;;; EC-Eval value:
265252859812191058636308480000000
#+END_SRC

Now the =maximum-depth= gets $3n+14$ not the constant 10 and =total-pushes= gets
$37n + 33$, which is definitely large number than previous one.

How about the recurvise definition?
#+BEGIN_SRC scheme
;;; EC-Eval input:
(factorial 3)

(total-pushes = 86 maximum-depth = 27)
;;; EC-Eval value:
6

;;; EC-Eval input:
(factorial 10)

(total-pushes = 324 maximum-depth = 83)
;;; EC-Eval value:
3628800

;;; EC-Eval input:
(factorial 30)

(total-pushes = 1004 maximum-depth = 243)
;;; EC-Eval value:
265252859812191058636308480000000
#+END_SRC

As expected this one also has involved more stack operations than previous since
this version of evaluator execute instructions that is useless.
*** Exercise 5.29
**** a.
From the experiments, we extracted the following data:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(fib 5)

(total-pushes = 408 maximum-depth = 28)
;;; EC-Eval value:
5

;;; EC-Eval input:
(fib 10)

(total-pushes = 4944 maximum-depth = 53)
;;; EC-Eval value:
55

;;; EC-Eval input:
(fib 15)

(total-pushes = 55232 maximum-depth = 78)
;;; EC-Eval value:
610

#+END_SRC

So we can deduce that =maximum-depth= is given as $5n + 3$.
**** b.
From the experiments conducted in *a.*, we can inspect that the =total-pushes=
increase proportionally to the value of =(fib n)=. As we reasoned in the
exercise of 1.2.2 section, we know the =(fib n)= is exponential; so as to
=total-pushes=.

As we did in that exercise to deduce the exact number of =(fib n)=, here we
analyze the =total-pushes= using the induction on the definition of =fib=. We
can do this analysis since from the controller sequence of =eceval= should
evaluate the subproblems in exact same manner with the entry calling of =(fib
n)=.

From this argument, we can formulate =total-pushes= as
\[S(n) = S(n - 1) + S(n - 2) + k\]
, where /S/ denotes the =total-pushes= of input number =n=.

Now let's deduce the =k= from the experiments:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(fib 3)

(total-pushes = 128 maximum-depth = 18)
;;; EC-Eval value:
2

;;; EC-Eval input:
(fib 4)

(total-pushes = 240 maximum-depth = 23)
;;; EC-Eval value:
3

#+END_SRC

From =(fib 3)=, =(fib 4)=, =(fib 5)=, we can get $k = 40$. Let's verify this on
different data:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(fib 14)

(total-pushes = 34120 maximum-depth = 73)
;;; EC-Eval value:
377

;;; EC-Eval input:
(fib 16)

(total-pushes = 89392 maximum-depth = 83)
;;; EC-Eval value:
987

#+END_SRC

From these set of data, we also get $k = 40$, as expected.

Now let's try to answer final question of this exercise. So far we deduced that
/S/ also can be formulated "Fibonacci" number like equation -- the doubly
recursive equation.

So now we turn to what is the initial conditions of that equation, that is, like
the ones from =fib= -- the base cases =(fib 0)= equals 0, =(fib 1)= equals 1.

After that, we can relate these numbers with the numbers of Fibonacci as we
required.

Here is the base cases:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(fib 0)

(total-pushes = 16 maximum-depth = 8)
;;; EC-Eval value:
0

;;; EC-Eval input:
(fib 1)

(total-pushes = 16 maximum-depth = 8)
;;; EC-Eval value:
1

;;; EC-Eval input:
(fib 2)

(total-pushes = 72 maximum-depth = 13)
;;; EC-Eval value:
1

#+END_SRC

So /S(0) = 16/ and /S(1) = 16/; and for verification, /S(2) = S(1) + S(0) + 40 =
72/ as expected. From these data, it seems like we can equate as /S(n) = a
Fib(n + 1) + b/. Let's verify by plugging the right hand side formula into the
left hand side in the /S(n)/ formula:
/a Fib(n + 1) + b = a Fib (n) + a Fib (n - 1) + 2 b + 40/, which reduced to
/b = - 40/ and if we plug this result into the base case, we got /S(1) = a Fib
(2) - 40/, which, in turn, means /a = 56/.

So the solution is /S(n) = 56 Fib(n + 1) - 40/.
*** Exercise 5.30
**** a.
We need to use =flag= register to signal that these erroneous process occurred.
Before modifying the =loopkup= operation as outlined in the text, we need to
inspect what the value of =flag= can be in user defined process. And then we
should design the special value that signal error, which are set in =flag=
register.

For the current version of register machine, we set =flag= as the result of
execution of condition operation; we need to fix this since we are going to
define special value that can not be set in user defined process but the current
one there is no restriction on the value of =flag= user can cause.

Moreover, as we are using the =flag= register only in the =branch= to determine
where to proceed, we don't need =flag= to be other than boolean. So it is
reasonable to restrict the condition operation in =test= can only set the
value of =flag= to true or false.

We can make contract informally to the user of our register machine but the
implementor of =eceval= machine is one of the user of this. And this is the
restriction =eceval= implementor to impose to the user of his machine. So maybe
it is none of the business for the implementor of our register machine but for
the =eceval= evaluator; that means, if the =eceval= implementor is along with
the contract that the value of =flag= should be boolean in processing user
defined process -- the unwinding process, it is good to go.

So now, we restricted the =flag= value to be boolean in normal process, we are
good to define whatever value we want to use the signaling error.

So for presentation let's change the =lookup-variable-value= to support the idea
outlined above:
#+BEGIN_SRC scheme
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
#+END_SRC

And then
#+BEGIN_SRC scheme
    ev-variable
    ;; (assign val (op lookup-variable-value) (reg exp) (reg env))
    (assign val (op lookup-variable-value-with-error) (reg exp) (reg env) (reg flag))
    (test (op error-flag?) (reg flag))
    ;; unbound-variable
    ;; Input: exp -- given unbound variable
    (branch (label unbound-variable))
    (goto (reg continue))

    unbound-variable
    (assign val (op list) (const "Unbound variable") (reg exp))
    (goto (label signal-error))
#+END_SRC

With this configuration, let's test it:
#+BEGIN_SRC scheme
;;; EC-Eval input:
x

(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
#t

;;; EC-Eval input:
y

(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
#t

#+END_SRC

Unfortunately this idea won't work since we can't change the actual contents of
=flag= register unless =assign= it directly; there is a way to embody this idea,
that is, to unwind this machine operation into subroutine. Then we are able to
mutate the flag register as we wanted; but it thought as would be better to goto
=signal-error= entry point rather than to mutate the flag register and then go
back to caller. However there is some issues around this problem like the make
the stack or other registers to be consist with the contract -- this is the
responsibilities to the caller not the =lookup-variable= itself.

Whatever it be, for now, we are not going to implement the
=lookup-variable-value= procedure as subroutine.

So it would be better to get back to the original idea suggested in the text --
use the value that can not be set by user, that is using the type-tag I think.

Here is the code:
#+BEGIN_SRC scheme
(define (error-exp? exp)
  (tagged-list? exp 'error))

(define (make-error-exp exp) `(error ,exp))

(define (lookup-variable-value-with-error var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (make-error-exp `("Unbound variable" ,var))
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
#+END_SRC

#+BEGIN_SRC scheme
    ev-variable
    ;; (assign val (op lookup-variable-value) (reg exp) (reg env))
    (assign val (op lookup-variable-value-with-error) (reg exp) (reg env))
    (test (op error-exp?) (reg val))
    ;; unbound-variable
    ;; Input: val -- Error message
    (branch (label signal-error))
    (goto (reg continue))
#+END_SRC

Let's test:
#+BEGIN_SRC scheme
;;; EC-Eval input:
y
(error (Unbound variable y))

;;; EC-Eval input:
x

(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
5

#+END_SRC

Now it runs as expected. Here we chose to delegate the duty producing error
message to the procedure who signal this error rather than to the caller -- just
hand over this to the =signal-error= subroutine.

Now let's convert all the =error= expression into the one outlined above:
#+BEGIN_SRC scheme
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          ;; (error "Too many arguments supplied" vars vals)
          (make-error-exp `("Too many arguments supplied" ,vars ,vals))
          ;; (error "Too few arguments supplied" vars vals)
          (make-error-exp `("Too few arguments supplied" ,vars ,vals))
          )))

(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        ;; (error "Unbound variable -- SET!" var)
        (make-error-exp `("Unbound variable -- SET!" ,var))
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
#+END_SRC

Then in =ev-assignment=,
#+BEGIN_SRC scheme
    ;; (perform
    ;;  (op set-variable-value!) (reg unev) (reg val) (reg env))
    (assign val (op set-variable-value!) (reg unev) (reg val) (reg env))
    (test (op error-exp?) (reg val))
    (branch (label signal-error))
    (assign val (const ok))
    (goto (reg continue))
#+END_SRC

And in =compound-apply=,
#+BEGIN_SRC scheme
    (assign env (op extend-environment)
            (reg unev) (reg argl) (reg env))
    (test (op error-exp?) (reg env))
    (branch (label unmatched-argument-number-error))
    (assign unev (op procedure-body) (reg proc))
    (goto (label ev-sequence))


    unmatched-argument-number-error
    (restore continue)
    (assign val (reg env))
    (goto (label signal-error))
#+END_SRC

These are all the procedure signal error in [[file:Exercise/ch5-eceval-support.scm][support file]].

Let's test:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(set! y 3)
(error (Unbound variable -- SET! y))

;;; EC-Eval input:
(define (test x y) 5)

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
(test 2 3 1 3)
(error (Too many arguments supplied (x y) (2 3 1 3)))

;;; EC-Eval input:
(test 1)
(error (Too few arguments supplied (x y) (1)))

#+END_SRC

Great! But there is also problem in this approach, that is, user can produce
this tagged data as they want. Like this:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(define x '(error "This should be forbidden by user"))

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
x
(error This should be forbidden by user)

#+END_SRC

Or
#+BEGIN_SRC scheme
;;; EC-Eval input:
(define y '(primitive "this also should be forbiddend"))

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
(y 5)
;The object "this also should be forbiddend" is not applicable.
;To continue, call RESTART with an option number:
; (RESTART 2) => Specify a procedure to use in its place.
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

We need to cope with this situation by noting that user only can construct pair
data -- thus list data -- via the =cons=. So if we make change the pair
structure to the tagged data like =(pair x y)= then we are free from this kind
of error:
#+BEGIN_SRC scheme
,*** in primitive-procedures
  (list (list 'car cadr)
        (list 'cdr caddr)
        (list 'cons (lambda (x y) `(pair ,x ,y)))
        (list 'null? (lambda (p) (and (tagged-list? p 'pair) (null? (cdr p)))))
        (list 'pair? (lambda (p) (tagged-list? p 'pair)))
        ...)

,*** in setup-environment
    (define-variable! 'nil '(pair) initial-env)
#+END_SRC

Then
#+BEGIN_SRC scheme
;;; EC-Eval input:
(define x (cons 'error (cons "This should be forbidden by user" nil)))

(total-pushes = 19 maximum-depth = 11)
;;; EC-Eval value:
ok

;;; EC-Eval input:
x

(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
(pair error (pair This should be forbidden by user (pair)))

#+END_SRC

Here we used =cons= rather than =quote=; but it should work if we used =quote=
instead -- we need to change the =test-of-quotation= procedure as subroutine
that converts underlying pair structure into that of =eceval=:
#+BEGIN_SRC scheme
(define (text-of-quotation exp)
  (tree-map identity-procedure
            (lambda (x y) `(pair ,x ,y))
            '(pair)
            (cadr exp)))
#+END_SRC

=tree-map= is the one implemented in [[Exercise 5.12][exercise 5.12]].

Then
#+BEGIN_SRC scheme
;;; EC-Eval input:
(define x '(error "This should be forbidden by user"))

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
x

(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
(pair error (pair This should be forbidden by user (pair)))

;;; EC-Eval input:
(define y '(primitive "this also should be forbiddend"))

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
(y 5)
unknown-procedure-type-error

#+END_SRC

Now we don't need any additional definition of =nil=:
#+BEGIN_SRC scheme
;;; EC-Eval input:
'()

(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
(pair)

;;; EC-Eval input:
(null? '())

(total-pushes = 5 maximum-depth = 3)
;;; EC-Eval value:
#t

#+END_SRC

For completeness, we should define print procedure for our pair structure:
#+BEGIN_SRC scheme
(define (user-print object)
  (cond ((compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>)))
        ((pair?* object)
         (print-pair* object))
        (else (display object))))

;; Structural induction on pair
(define (print-pair* p)
  (define (iter p)
    (cond ((null?* p))
          ((pair?* p)
           (display " ")
           (display (car* p))
           (iter (cdr* p)))
          (else
           ;; not pair -- atomic expression
           (display " . ")
           (display p))))
  (display "(")
  (display (car* p))
  (iter (cdr* p))
  (display ")"))
#+END_SRC

Then
#+BEGIN_SRC scheme
;;; EC-Eval input:
(define x '(error "This should be forbidden by user"))

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
x

(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
(error This should be forbidden by user)

;;; EC-Eval input:
(car x)

(total-pushes = 5 maximum-depth = 3)
;;; EC-Eval value:
error

#+END_SRC

Works as expected. For efficiency, professional product would use bit-wise typed
data rather than this version -- typed using pair structure, as noted in text book.

Now we are good to apply our strategy to the rest of instructions that may
corrupt in some condition other than the ones in the support file, which
signaling with the =error= procedure. To do that, we first look into the
=eceval= code to figure out.

Here is the list:
- =self-eval=: It is good as it is
- =variable=: We handled this in =lookup-variable-value= procedure.
- =quote=:
  We need to handle
  #+BEGIN_SRC scheme
(quote)

;Ill-formed syntax: (quote)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

(quote x . y)

;Ill-formed syntax: (quote x . y)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC
- =lambda=:
  We need to handle
  #+BEGIN_SRC scheme
(lambda)

;Ill-formed syntax: (lambda)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

(lambda x)

;Ill-formed syntax: (lambda x)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

(lambda x y . z)

;Ill-formed syntax: (lambda x y . z)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC
- =application=: =extend-environment= handles the error case. For the error
  during the application of primitive procedure, we will handle this *b.* part
  of this exercise.

  And should handle
  #+BEGIN_SRC scheme
(x 1 . 4)

;Combination must be a proper list: (x 1 . 4)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC
- =begin= or =ev-sequence=:
  Should it accept empty sequence?
  #+BEGIN_SRC scheme
(begin)

;Unspecified return value
  #+END_SRC

  For consistency with the =lambda= expression, let us choose above expression
  as ill-formed one.

  So we can say explicitly that the contraction of =ev-sequence='s input should
  not be empty.
- =if=:
  Should handle
  #+BEGIN_SRC scheme
(if)

;Ill-formed syntax: (if)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

(if x)

;Ill-formed syntax: (if x)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

(if 1 2 3 4)

;Ill-formed syntax: (if 1 2 3 4)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

(if 1 . 2)

;Ill-formed syntax: (if 1 . 2)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC
- =assignment=:
  Should handle
  #+BEGIN_SRC scheme
(set! x y z)

;Variable required in this context: x
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

(set! x . y)

;Variable required in this context: x
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC

  But should we?
  #+BEGIN_SRC scheme
(define x 2)

;Value: x

(set! x)

;Value: 2

x

;Unassigned variable: x
;To continue, call RESTART with an option number:
; (RESTART 3) => Specify a value to use instead of x.
; (RESTART 2) => Set x to a given value.
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC
  This is just like =unset!= if it exists; but it is "Unassigned" not "Unbound"
  as follows:
  #+BEGIN_SRC scheme
y

;Unbound variable: y
;To continue, call RESTART with an option number:
; (RESTART 3) => Specify a value to use instead of y.
; (RESTART 2) => Define y to a given value.
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC

  The difference is that we can re-set the value:
  #+BEGIN_SRC scheme
(set! x 3)

;Unspecified return value
  #+END_SRC

  Maybe it is used internally, when we want to handle expression such as
  =letrec=. So it is not needed for now; let us choose to define such expression
  as ill-formed one.
- =definition=:
  Should handle
  #+BEGIN_SRC scheme
(define)

;Ill-formed syntax: (define)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

(define x y z)

;Ill-formed syntax: (define x y z)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.

(define x . y)

;Ill-formed syntax: (define x . y)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC


As I've implemented those, let's test them:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(quote x . y)
(error (Ill-formed syntax (quote x . y)))

;;; EC-Eval input:
(quote)
(error (Ill-formed syntax (quote)))

;;; EC-Eval input:
(lambda)
(error (Ill-formed syntax (lambda)))

;;; EC-Eval input:
(lambda x)
(error (Ill-formed syntax (lambda x)))

;;; EC-Eval input:
(lambda x y . z)
(error (Ill-formed syntax (lambda x y . z)))

;;; EC-Eval input:
(x 1 . 4)
(error (Ill-formed syntax (x 1 . 4)))

;;; EC-Eval input:
(begin)
(error (Ill-formed syntax (begin)))

;;; EC-Eval input:
(begin x . y)
(error (Ill-formed syntax (begin x . y)))

;;; EC-Eval input:
(if)
(error (Ill-formed syntax (if)))

;;; EC-Eval input:
(if x)
(error (Ill-formed syntax (if x)))

;;; EC-Eval input:
(if 1 2 3 4)
(error (Ill-formed syntax (if 1 2 3 4)))

;;; EC-Eval input:
(if 1 . 2)
(error (Ill-formed syntax (if 1 . 2)))

;;; EC-Eval input:
(set!)
(error (Ill-formed syntax (set!)))

;;; EC-Eval input:
(set! x)
(error (Ill-formed syntax (set! x)))

;;; EC-Eval input:
(set! x y z)
(error (Ill-formed syntax (set! x y z)))

;;; EC-Eval input:
(set! x . y)
(error (Ill-formed syntax (set! x . y)))

;;; EC-Eval input:
(define)
(error (Ill-formed syntax (define)))

;;; EC-Eval input:
(define x y z)
(error (Ill-formed syntax (define x y z)))

;;; EC-Eval input:
(define x . y)
(error (Ill-formed syntax (define x . y)))

;;; EC-Eval input:
(define x 5)

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
(set! x 3)

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
x

(total-pushes = 0 maximum-depth = 0)
;;; EC-Eval value:
3

#+END_SRC

Of course the proper syntax expression works normally as expected.

Note that as we depends on the =read= procedure for the parsing expression,
unfortunately we cannot cope with the such errors handled by =read=:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(1 . 2 . 3)
;Ill-formed dotted list: (1 |.| 2 |.| 3)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC
**** b.
Actually this is analogous task we have done prior to the task of *a.* to
prevent from user producing our =error= ADT.

The goal would be followings
#+BEGIN_SRC scheme
(car 1)

;The object 1, passed as the first argument to car, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 2) => Specify an argument to use in its place.
; (RESTART 1) => Return to read-eval-print level 1.

(cdr 1)

;The object 1, passed as the first argument to cdr, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 2) => Specify an argument to use in its place.
; (RESTART 1) => Return to read-eval-print level 1.

(car 1 2 3)

;The procedure #[compiled-procedure 18 ("list" #x1) #x1a #x104588fc2] has been called with 3 arguments; it requires exactly 1 argument.
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

Or more specifically we can learn from the "professional" product:
#+BEGIN_SRC scheme
(pp cadr)
(named-lambda (cadr x)
  ((named-lambda (safe-car x)
     (if (pair? x)
         (car x)
         (error:not-a pair? x 'safe-car)))
   ((named-lambda (safe-cdr x)
      (if (pair? x)
          (cdr x)
          (error:not-a pair? x 'safe-cdr)))
    x)))
#+END_SRC

Or for the division case,
#+BEGIN_SRC scheme
(/ 5 0)

;Division by zero signalled by /.
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

We got
#+BEGIN_SRC scheme
(pp /)
(case number-of-arguments
  ((1)
   (named-lambda (complex:invert z)
     (if (object-type? 60 z)
         (let ((zr (system-pair-car z)) (zi (system-pair-cdr z)))
           (let ((d (real:+ (real:square zr) (real:square zi))))
             (system-pair-cons 60 (real:/ zr d) (real:/ (real:negate zi) d))))
         ((named-lambda (real:invert x) (if (object-type? 6 x) (let ((x x)) (flonum-divide 1. x)) (rat:invert x))) z))))
  ((2) (named-lambda (binary-/ z1 z2) (&/ z1 z2)))
  (else (named-lambda (/ self z1 . zs) (complex:/ z1 (reduce complex:* 1 zs)))))
;Unspecified return value
#+END_SRC

We can test this feature with following definition:
#+BEGIN_SRC scheme
(define test
  (lambda x
    (let ((number-of-arguments (length x)))
      (case number-of-arguments
        ((0) 'nullary)
        ((1) 'unary)
        ((2) 'binary)
        (else 'recursive)))))
#+END_SRC

Then we got
#+BEGIN_SRC scheme
(test 1)

;Value: unary

(test 1 2)

;Value: binary

(test 1 2 3)

;Value: recursive

(test)

;Value: nullary
#+END_SRC

From this experiment, we learned that to cope with the arity error, we need to
take the argument as list and then check.

Here is the half of that -- for the fixed arity procedures:
#+BEGIN_SRC scheme
(define cons*
  (check-error-with
   (named-lambda (cons x y) `(pair ,x ,y))
   2))

(define null?*
  (check-error-with
   (named-lambda (null? p)
     (and (tagged-list? p 'pair) (null? (cdr p))))
   1))

(define pair?*
  (check-error-with
   (named-lambda (pair? p) (tagged-list? p 'pair))
   1))

;; (define (car* p)
;;   (cadr p))

(define car*
  (check-error-with
   (named-lambda (car p)
     (if (pair?* p)
         (cadr p)
         (make-error-exp `("The object " ,p " is not a pair -- car"))))
   1))

(define (check-error-with proc fixed-arity)
  (lambda x
    (let ((number-of-arguments (length x)))
      (if (= number-of-arguments fixed-arity)
          (apply proc x)
          (make-error-exp `("The procedure "
                            ,proc
                            " has been called with "
                            ,number-of-arguments
                            " arguments; it requires exactly "
                            ,fixed-arity
                            " argument."))))))

(define cdr*
  (check-error-with
   (named-lambda (cdr p)
     (if (pair?* p)
         (caddr p)
         (make-error-exp `("The object " ,p " is not a pair -- cdr"))))
   1))
;; (define (cdr* p)
;;   (caddr p))
#+END_SRC

Then =primitive-apply= subroutine got
#+BEGIN_SRC scheme
    primitive-apply
    (assign val (op apply-primitive-procedure)
            (reg proc)
            (reg argl))
    (test (op error-exp?) (reg val))
    (branch (label signal-error))
    (restore continue)
    (goto (reg continue))
#+END_SRC

Let's test what we have done so far:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(car 1)
(error (The object  1  is not a pair -- car))

;;; EC-Eval input:
(cdr 1)
(error (The object  1  is not a pair -- cdr))

;;; EC-Eval input:
(car 1 2 3)
(error (The procedure  #[compound-procedure 24 car]  has been called with  3  arguments; it requires exactly  1  argument.))

;;; EC-Eval input:
(pair? (cons 1 2) 2 3)
(error (The procedure  #[compound-procedure 25 pair?]  has been called with  3  arguments; it requires exactly  1  argument.))

;;; EC-Eval input:
(cons 1 2 3)
(error (The procedure  #[compound-procedure 26 cons]  has been called with  3  arguments; it requires exactly  2  argument.))

#+END_SRC

So far so good!

Let's turn to the rest. Our goals are
#+BEGIN_SRC scheme
(pp <)
(case number-of-arguments
  ((0) (named-lambda (nullary-<) #t))
  ((1) (named-lambda (unary-< z) (if (not (complex:real? z)) (error:wrong-type-argument z "real number" '<)) #t))
  ((2) (named-lambda (binary-< z1 z2) (&< z1 z2)))
  (else (named-lambda (< self . zs) (reduce-comparator complex:< zs '<))))
;Unspecified return value

(pp +)
(case number-of-arguments
  ((0) (named-lambda (nullary-+) 0))
  ((1) (named-lambda (unary-+ z) (if (not (complex:complex? z)) (error:wrong-type-argument z "number" '+)) z))
  ((2) (named-lambda (binary-+ z1 z2) (&+ z1 z2)))
  (else (named-lambda (+ self . zs) (reduce complex:+ 0 zs))))
;Unspecified return value

(pp -)
(case number-of-arguments
  ((1)
   (named-lambda (complex:negate z)
     (if (object-type? 60 z)
         (system-pair-cons 60 (real:negate (system-pair-car z)) (real:negate (system-pair-cdr z)))
         ((named-lambda (real:negate x)
            (if (object-type? 6 x)
                (flonum-negate x)
                ((named-lambda (rat:negate v/v*) (if (object-type? 58 v/v*) (system-pair-cons 58 (integer-negate (system-pair-car v/v*)) (system-pair-cdr v/v*)) (integer-negate v/v*))) x)))
          z))))
  ((2) (named-lambda (binary-- z1 z2) (&- z1 z2)))
  (else (named-lambda (- self z1 . zs) (complex:- z1 (reduce complex:+ 0 zs)))))
;Unspecified return value

(pp *)
(case number-of-arguments
  ((0) (named-lambda (nullary-*) 1))
  ((1) (named-lambda (unary-* z) (if (not (complex:complex? z)) (error:wrong-type-argument z "number" '*)) z))
  ((2) (named-lambda (binary-* z1 z2) (&* z1 z2)))
  (else (named-lambda (* self . zs) (reduce complex:* 1 zs))))
;Unspecified return value

(pp =)
(case number-of-arguments
  ((0) (named-lambda (nullary-=) #t))
  ((1) (named-lambda (unary-= z) (if (not (complex:complex? z)) (error:wrong-type-argument z "complex number" '=)) #t))
  ((2) (named-lambda (binary-= z1 z2) (&= z1 z2)))
  (else (named-lambda (= self . zs) (reduce-comparator complex:= zs '=))))
;Unspecified return value

(pp /)
(case number-of-arguments
  ((1)
   (named-lambda (complex:invert z)
     (if (object-type? 60 z)
         (let ((zr (system-pair-car z)) (zi (system-pair-cdr z)))
           (let ((d (real:+ (real:square zr) (real:square zi))))
             (system-pair-cons 60 (real:/ zr d) (real:/ (real:negate zi) d))))
         ((named-lambda (real:invert x) (if (object-type? 6 x) (let ((x x)) (flonum-divide 1. x)) (rat:invert x))) z))))
  ((2) (named-lambda (binary-/ z1 z2) (&/ z1 z2)))
  (else (named-lambda (/ self z1 . zs) (complex:/ z1 (reduce complex:* 1 zs)))))
;Unspecified return value
#+END_SRC

So to summarize,
- All of the arguments of above operations should be =number?=.
- In addition to that, for the comparing operations -- =<= and =>= -- should be =real?=.
- Especially for the division, except for the first dividend, 0 should not be
  passed; if the number of argument were 1, that number shouldn't be 0.
- Except division and subtraction, it is okay with any arity; for those, it
  should be at least 1 argument.


Here is the code:
#+BEGIN_SRC scheme
(define (ensure-arity-number-gt minimum-arity proc)
  (lambda x
    (let ((number-of-arguments (length x)))
      (if (< number-of-arguments minimum-arity)
          (make-error-exp `("The procedure "
                            ,proc
                            " has been called with "
                            ,number-of-arguments
                            " arguments; it requires at least "
                            ,minimum-arity
                            " argument."))
          (apply proc x)))))

(define (all-arguments-to-be? pred? args)
  (let loop
      ((args args))
    (if (null? args)
        true
        (and (pred? (car args))
             (loop (cdr args))))))

(define -*
  (ensure-arity-number-gt
   1
   (named-lambda (- . as)
     (if (all-arguments-to-be? number? as)
         (apply - as)
         (make-error-exp
          `("The object " ,as
            ", passed as an argument to -, is not a number."))))))

(define /*
  (ensure-arity-number-gt
   1
   (named-lambda (/ a . as)
     (if (all-arguments-to-be? number? (cons a as))
         (if (or (and (null? as) (zero? a))
                 (not (all-arguments-to-be?
                       (lambda (a) (not (zero? a)))
                       as)))
             (make-error-exp
              `("Division by zero signalled by / from arguments "
                ,(cons a as)))
             (apply / (cons a as)))
         (make-error-exp
          `("The object " ,as
            ", passed as an argument to -, is not a number."))))))

(define =*
  (named-lambda (= . as)
    (if (all-arguments-to-be? number? as)
        (apply = as)
        (make-error-exp
         `("The object " ,as
           ", passed as an argument to =, is not a number.")))))

(define +*
  (named-lambda (+ . as)
    (if (all-arguments-to-be? number? as)
        (apply + as)
        (make-error-exp
         `("The object " ,as
           ", passed as an argument to +, is not a number.")))))

(define **
  (named-lambda (* . as)
    (if (all-arguments-to-be? number? as)
        (apply * as)
        (make-error-exp
         `("The object " ,as
           ", passed as an argument to *, is not a number.")))))

(define <*
  (named-lambda (< . as)
    (if (all-arguments-to-be? real? as)
        (apply < as)
        (make-error-exp
         `("The object " ,as
           ", passed as an argument to <, is not a real number.")))))

(define >*
  (named-lambda (> . as)
    (if (all-arguments-to-be? real? as)
        (apply > as)
        (make-error-exp
         `("The object " ,as
           ", passed as an argument to >, is not a real number.")))))

#+END_SRC

Now let's test it:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(+ (cons 2 3))
(error (The object  ((pair 2 3)) , passed as an argument to +, is not a number.))

;;; EC-Eval input:
(/ 1 0)
(error (Division by zero signalled by / from arguments  (1 0)))

;;; EC-Eval input:
(-)
(error (The procedure  #[compound-procedure 30 -]  has been called with  0  arguments; it requires at least  1  argument.))

;;; EC-Eval input:
(+)

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
0

;;; EC-Eval input:
(*)

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
1

;;; EC-Eval input:
(> (cons 2 3))
(error (The object  ((pair 2 3)) , passed as an argument to >, is not a real number.))

;;; EC-Eval input:
(/ 0)
(error (Division by zero signalled by / from arguments  (0)))

#+END_SRC

If we want to hide the =pair= representation we are good to use the following
helper procedures:
#+BEGIN_SRC scheme
(define (tree-map* leaf-op combine-op initial tree)
  (cond ((null?* tree) initial)
        ((not (pair?* tree)) (leaf-op tree))
        (else                           ;pair
         (combine-op
          (tree-map* leaf-op combine-op initial
                    (car* tree))
          (tree-map* leaf-op combine-op initial
                    (cdr* tree))))))

(define (pair*->pair p)
  (tree-map* identity-procedure cons '() p))

(define (represent-object* o)
  (if (pair?* o)
      (pair*->pair o)
      o))
#+END_SRC

Then
#+BEGIN_SRC scheme
(define >*
  (named-lambda (> . as)
    (if (all-arguments-to-be? real? as)
        (apply > as)
        (make-error-exp
         `("The object" ,(represent-object* as)
           ", passed as an argument to >, is not a real number.")))))
#+END_SRC

Now test this new behavior:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(> (cons 2 3))
(error (The object ((pair 2 3)) , passed as an argument to >, is not a real number.))

#+END_SRC

Turns out we need to map over the argument list:
#+BEGIN_SRC scheme
(define -*
  (ensure-arity-number-gt
   1
   (named-lambda (- . as)
     (if (all-arguments-to-be? number? as)
         (apply - as)
         (make-error-exp
          `("The object" ,(map represent-object* as)
            ", passed as an argument to -, is not a number."))))))
#+END_SRC

Then re-run!
#+BEGIN_SRC scheme
;;; EC-Eval input:
(> (cons 2 3))
(error (The object ((2 . 3)) , passed as an argument to >, is not a real number.))

;;; EC-Eval input:
(* (cons 2 3) (cons 1 (cons 3 2)))
(error (The object ((2 . 3) (1 3 . 2)) , passed as an argument to *, is not a number.))

#+END_SRC

Now works as expected.
* Compilation
Compilation is another strategy that takes opposite to what explicit control
evaluator takes: It lowers the higher level language into the very lower level
language, /natural language/ or /assembly language/. And this translated program
would be interpreted by the machine language interpreter -- CPU -- after
assembled.

This different strategy causes the great deal of changes of properties from the
evaluator. In evaluator, as it loads all the library -- the collection of
subroutines that implements the primitive operations of source language -- since
it does not what subroutines are going to be needed in interpreting, we can
develop the program dynamically. On the other hand, in the compile method, only the
required subroutines are going to be loaded in execution, since it knows what
the source code used in priori.

This is analogous situation from section 4.1.7; the compiler analyze or optimize
the instructions using the informations of the source code that can be deducted
in static manner. We should come to understand why modern computer programming
language especially the one for system program, use the strongly typed language:
The compiler can deduce more information from the code than weakly typed one
since it knows what going to be returned and what would be passed, and so on in
compile time in addition to the type inference for assisting the programmer.

As Scheme is the dynamically typed language, the compiler can not do the clever
things done by the compiler of strongly typed language like Java or Scala or
Clojure; although this fact, the compiler can works a lot than the evaluator.

The main idea that is implemented in this section is annotate between the
instruction sequences; and using that information, compiler can save additional
stack operations around instruction sequences. It is embodied by structural
definition over the compiler clause structure: Defining manually for all the
primitive clauses and inductive combination rule.

In addition to this quite "clever" idea, we can eliminates all the evaluator
specific instructions -- e.g. the instructions involving the =exp= and =unev=
registers and the =continue= to go to next entry point, and so on. Since our
compiler is not the program in the machine language but in the Scheme -- higher
level language, it can manipulate the given expression directly using the
pointer to the data structure allocated heap (or list structured memory).

** Structure of the Compiler
*** Exercise 5.31
You should look through the lecture, 10A of SICP, since the relevant and useful
diagram appears in the lecture. I've drawn that diagram based on the given
examples with my digital paper.

For the conclusion, the first one and second one can be eliminated all the stack
operations otherwise involved, and third one results in pair of =env= save and
store, that of =proc=, and that of =argl= register. For the last one, pair of
=proc= and =argl= survived.
*** Exercise 5.32
**** a.
#+BEGIN_SRC scheme
    ev-application
    ;; Error handling
    (assign val (op error-exp-if-ill-formed-combination) (reg exp))
    (test (op error-exp?) (reg val))
    (branch (label signal-error))
    ;;
    (save continue)
    (assign unev (op operands) (reg exp))
    (assign exp (op operator) (reg exp))
    ;; Exercise 5.32a
    (test (op variable?) (reg exp))
    (branch (label ev-appl-sym-op))
    (save env)
    (save unev)
    (assign continue (label ev-appl-did-operator))
    (goto (label eval-dispatch))
    ev-appl-sym-op
    (assign continue (label ev-appl-did-sym-op))
    (goto (label ev-variable))
    ev-appl-did-operator
    (restore unev)
    (restore env)
    ev-appl-did-sym-op
    (assign argl (op empty-arglist))
    (assign proc (reg val))
    (test (op no-operands?) (reg unev))
    (branch (label apply-dispatch))
    (save proc)
...
#+END_SRC
Using the information that the operator expression is symbol, we could reduce
the 2 pair of stack operation from previous version.
**** b.
Alyssa P. Hacker ignores the time it takes to analyze the instructions to
optimize the code. As we already have seen in section 4.1.7, the analysis times
can not be ignored especially if it trying to extract great deal of information
from the code, and then exploit that fact to optimize.

So if we do analyze in the execution time, it will have overhead when the code
executed for the first time; well, it can achieve efficient execution after that
evaluation but the overhead would not the one user ever expected.

On the other hand, the compiler can analyze the code in compile time, which is
not the execution time, so the user get the behavior of the program consistently
with their expectation -- it takes same time for execution. So compiler can
introduce more sophisticated algorithm to improve the efficiency of resulting
code since it is done once and compile time.
** Compiling Expressions
** Compiling Combinations
** Combining Instruction Sequences
** An Example of Compiled Code
*** Exercise 5.33
Before compiling this altered one, we can expect what difference it would make
from the informal (or the code) from this section. We expect this altered one
and original one different in view point of efficiency. Here is why:

Since this altered version place the recursive call to the last argument of last
combination expression, it needs to preserve the =env= register around the
compilation of last argument (since in our compiler, last argument would be
compiled first and the first to be last); since it alter =env= and the first
code compiled needs =env=, =env= should be wrapped by =save= and =restore=
around the compilation of last argument -- recursive call.

However the original version compile the recursive call lastly (or put
in other way, appended at the very end), and the last argument does not modify
the =env= register -- =lookup-variable-value= -- it saves pair of =save= &
=restore= stack operation compared with altered version.

Consequently the original one would be more efficient. Then let's verify this
fact:
#+BEGIN_SRC scheme
(compile
 '(define (factorial-alt n)
    (if (= n 1)
        1
        (* n (factorial-alt (- n 1)))))
 'val
 'next)

((env)
 (val)
 ((assign val (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))
  entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
  (save continue)
  (save env)
  (assign proc (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
  compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch17
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call15
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
  true-branch5
  (assign val (const 1))
  (goto (reg continue))
  false-branch4
  (assign proc (op lookup-variable-value) (const *) (reg env))
  (save continue)
  (save proc)
  (save env)                            ;this is the major difference
  (assign proc (op lookup-variable-value) (const factorial-alt) (reg env))
  (save proc)
  (assign proc (op lookup-variable-value) (const -) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
  compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call6
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
  compiled-branch10
  (assign continue (label after-call9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch11
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call9
  (assign argl (op list) (reg val))
  (restore env)                         ;***
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
  compiled-branch13
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch14
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
  after-call12
  after-if3
  after-lambda1
  (perform (op define-variable!) (const factorial-alt) (reg val) (reg env))
  (assign val (const ok))))
#+END_SRC

Unfortunately our expectation is invalid: The number of instructions are same in
both; the original one should =argl= register rather than =env= register. So the
overall efficiency would equal opposed our first expectation since the
accumulated stack contents equal in both.
*** Exercise 5.34
Here is the result:
#+BEGIN_SRC scheme
((env)
 (val)
 (
  ;; construct the procedure and skip over code for the procedure body
  (assign val (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))
  entry2                                ;calls to factorial will enter here
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
  ;; begin the procedure body
  ;; it actually first define internal procedure
  ;; so, it construct the internal procedure and skip over code for the
  ;; interanl procedure body
  (assign val (op make-compiled-procedure) (label entry7) (reg env))
  (goto (label after-lambda6))
  entry7                                ;internal procedure call will enter here
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (product counter)) (reg argl) (reg env))
  ;; actual iterative process starts
  (save continue)
  (save env)
  ;; compute (> counter n)
  (assign proc (op lookup-variable-value) (const >) (reg env))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const counter) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
  compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch22
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call20                         ;val now contains result of (> counter n)
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch9))
  true-branch10         ;return the value of product that bound to (factorial n)
  (assign val (op lookup-variable-value) (const product) (reg env))
  (goto (reg continue))
  false-branch9
  ;; compute and return (iter (* counter product) (+ counter 1))
  (assign proc (op lookup-variable-value) (const iter) (reg env))
  (save continue)
  (save proc)
  (save env)
  ;; compute (+ counter 1)
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const counter) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch16))
  compiled-branch15
  (assign continue (label after-call14))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch16
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call14                         ;val now contains result of (+ counter 1)
  (assign argl (op list) (reg val))
  (restore env)
  (save argl)
  ;; compute (* counter product)
  (assign proc (op lookup-variable-value) (const *) (reg env))
  (assign val (op lookup-variable-value) (const product) (reg env))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const counter) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch13))
  compiled-branch12
  (assign continue (label after-call11))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch13
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call11                   ;val now contains result of (* counter product)
  (restore argl)
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)                        ;restore iter
  (restore continue)
  ;; apply iter
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
  compiled-branch18
  ;; note that a compound procedure here is called tail-recursively
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch19
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
  after-call17    ;val now contains (factorial n)
  ;; there is no restore operations after this point
  ;; which means there is no defered operations and arguments --
  ;; the stack doesn't grow and get reduced before and after the
  ;; recursive call; this is why it is iterative process but above.
  after-if8
  after-lambda6        ;end of procedure body of iter
  ;; assign the procedure to the variable iter (internally)
  (perform (op define-variable!) (const iter) (reg val) (reg env))
  (assign val (const ok))
  ;; setup the initial call of iter -- (iter 1 1)
  (assign proc (op lookup-variable-value) (const iter) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (const 1))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch5))
  compiled-branch4
  ;; note also that this compound procedure call is tail-recursive
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch5
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
  after-call3
  after-lambda1                ;end of procedure body of factorial
  ;; assign the procedure to the variable factorial
  (perform (op define-variable!) (const factorial) (reg val) (reg env))
  (assign val (const ok))))
#+END_SRC

We included the analysis about the essential difference within the annotation.
*** Exercise 5.35
#+BEGIN_SRC scheme
(assign val
        (op make-compiled-procedure)    ;compilation of lambda expression
        (label entry16)
        (reg env))
(goto (label after-lambda15))
entry16
(assign env (op compiled-procedure-env) (reg proc))
(assign env
        (op extend-environment)
        (const (x))                   ;formal parameter list is (x)
        (reg argl)
        (reg env))
;; the actual procedure body of f
(assign proc
        (op lookup-variable-value)
        (const +)                       ;compliation of application of (+ ...)
        (reg env))
(save continue)
(save proc)
(save env)
;; the last argument of given application was actually another application expression
;; (g ...)
(assign proc (op lookup-variable-value) (const g) (reg env))
(save proc)
;; the last argument of inner application was yet another application (+ ...)
(assign proc (op lookup-variable-value) (const +) (reg env))
;; the last argument of innermost application was 2
(assign val (const 2))
(assign argl (op list) (reg val))
;; the next one (the argument in front of 2) was variable x
(assign val (op lookup-variable-value) (const x) (reg env))
(assign argl (op cons) (reg val) (reg argl))
;; start procedure call
;; which means argument list was (x 2)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch19))
compiled-branch18
(assign continue (label after-call17))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch19
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call17                            ;val now contains the value of (+ x 2)
(assign argl (op list) (reg val))
;; turns out (+ x 2) was the only argument of application of procedure g
(restore proc)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch22))
compiled-branch21
(assign continue (label after-call20))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch22
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call20                            ;now val contains (g (+ x 2))
(assign argl (op list) (reg val))
(restore env)
;; the next argument of outermost application was variable x
(assign val (op lookup-variable-value) (const x) (reg env))
(assign argl (op cons) (reg val) (reg argl))
;; the outermost application was (+ x (g (+ x 2)))
(restore proc)
(restore continue)
(test (op primitive-procedure?) (reg proc))
(branch (label primitive-branch25))
compiled-branch24
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
primitive-branch25
(assign val (op apply-primitive-procedure) (reg proc) (reg argl))
(goto (reg continue))
after-call23                            ;now val contains the value of (+ x (g (+ x 2)))
after-lambda15
;; the whole expression was defintion that binds f to the given lambda expression
(perform (op define-variable!) (const f) (reg val) (reg env))
(assign val (const ok))
;;end of exercise
#+END_SRC

We analyzed given code and annotated it; the result being posted above. From
this facts we can reconfigure what source code produced this instructions:
#+BEGIN_SRC scheme
(define (f x)
  (+ x (g (+ x 2))))
#+END_SRC

let's verify this:
#+BEGIN_SRC scheme
(compile
 '(define (f x)
    (+ x (g (+ x 2))))
 'val
 'next)
#+END_SRC

#+BEGIN_SRC scheme
((env)
 (val)
 ((assign val (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))
  entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (x)) (reg argl) (reg env))
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc (op lookup-variable-value) (const g) (reg env))
  (save proc)
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch5))
  compiled-branch4
  (assign continue (label after-call3))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch5
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call3
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
  compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call6
  (assign argl (op list) (reg val))
  (restore env)
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
  compiled-branch10
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch11
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
  after-call9
  after-lambda1
  (perform (op define-variable!) (const f) (reg val) (reg env))
  (assign val (const ok))))
#+END_SRC
*** Exercise 5.36
Our compiler produces right-to-left order of evaluation for operands of
combination in contrast to the explicit control evaluator in preceding [[The Explicit-Control Evaluator][section]].
It is determined by the =construct-arglist= in the =compile-application=.

To change this order according to previous left-to-right order, all we need to
change is the =construct-arglist= and =code-to-get-last-arg= not to use
=reverse= and to use =append= instead of =cons= respectively:
#+BEGIN_SRC scheme
(define (construct-arglist operand-codes) ;no reverse!
  (if (null? operand-codes)
      (make-instruction-sequence '() '(argl)
                                 '((assign argl (const ()))))
      (let ((code-to-get-last-arg
             (append-instruction-sequences
              (car operand-codes)
              (make-instruction-sequence '(val) '(argl)
                                         '((assign argl (op list) (reg val)))))))
        (if (null? (cdr operand-codes))
            code-to-get-last-arg
            (preserving '(env)
                        code-to-get-last-arg
                        (code-to-get-rest-args
                         (cdr operand-codes)))))))

(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving '(argl)
          (car operand-codes)
          (make-instruction-sequence
           '(val argl) '(val argl)            ;updated
           '((assign val (op list) (reg val)) ;changed
             (assign argl
                     (op append) (reg argl) (reg val))))))) ;changed
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving '(env)
         code-for-next-arg
         (code-to-get-rest-args (cdr operand-codes))))))
#+END_SRC

Now the instruction appending each argument code to the argument list being
constructed code got doubled -- from =cons= to make singleton =list= from newly
constructed argument and then =append= that to argument list in constructing.

Moreover, now the complexity of the constructing the whole argument list got
quadratic order of growth rather than linear order as previous.
*** Exercise 5.37
This is the place where the exercise [[Exercise 5.31][5.31]] can play its role or be verified
concretely. First, let's modify the =preserving= procedure so that it always
=save= and =restore= given registers around the first instruction sequence:
#+BEGIN_SRC scheme
(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (preserving (cdr regs)
             (make-instruction-sequence
              (list-union (list first-reg)
                          (registers-needed seq1))
              (list-difference (registers-modified seq1)
                               (list first-reg))
              (append `((save ,first-reg))
                      (statements seq1)
                      `((restore ,first-reg))))
             seq2))))
#+END_SRC

Then let's run this with the 4 cases of exercise [[Exercise 5.31][5.31]]
**** Case 1: =(f 'x 'y)=
Modified version:
#+BEGIN_SRC scheme
((env continue)
 (env proc argl continue val)
 ((save continue)
  (save env)
  (save continue)
  (assign proc (op lookup-variable-value) (const f) (reg env))
  (restore continue)
  (restore env)
  (restore continue)
  (save continue)
  (save proc)
  (save env)
  (save continue)
  (assign val (const y))
  (restore continue)
  (assign argl (op list) (reg val))
  (restore env)
  (save argl)
  (save continue)
  (assign val (const x))
  (restore continue)
  (restore argl)
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch3))
  compiled-branch2
  (assign continue (label after-call1))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch3
  (save continue)
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (restore continue)
  after-call1))
#+END_SRC

Original version:
#+BEGIN_SRC scheme
((env)
 (env proc argl continue val)
 ((assign proc (op lookup-variable-value) (const f) (reg env))
  (assign val (const y))
  (assign argl (op list) (reg val))
  (assign val (const x))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch6))
  compiled-branch5
  (assign continue (label after-call4))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch6
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call4))
#+END_SRC

34 instructions versus 14 instructions; aren't impressive?
**** Case 2: =((f) 'x 'y)=
Modified version:
#+BEGIN_SRC scheme
((env continue)
 (env proc argl continue val)
 ((save continue)
  (save env)
  (save continue)
  (save env)
  (save continue)
  (assign proc (op lookup-variable-value) (const f) (reg env))
  (restore continue)
  (restore env)
  (restore continue)
  (save continue)
  (save proc)
  (assign argl (const ()))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch9))
  compiled-branch8
  (assign continue (label proc-return10))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  proc-return10
  (assign proc (reg val))
  (goto (label after-call7))
  primitive-branch9
  (save continue)
  (assign proc (op apply-primitive-procedure) (reg proc) (reg argl))
  (restore continue)
  after-call7
  (restore env)
  (restore continue)
  (save continue)
  (save proc)
  (save env)
  (save continue)
  (assign val (const y))
  (restore continue)
  (assign argl (op list) (reg val))
  (restore env)
  (save argl)
  (save continue)
  (assign val (const x))
  (restore continue)
  (restore argl)
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch13))
  compiled-branch12
  (assign continue (label after-call11))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch13
  (save continue)
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (restore continue)
  after-call11))
#+END_SRC

Original version:
#+BEGIN_SRC scheme
((env)
 (env proc argl continue val)
 ((assign proc (op lookup-variable-value) (const f) (reg env))
  (assign argl (const ()))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch16))
  compiled-branch15
  (assign continue (label proc-return17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  proc-return17
  (assign proc (reg val))
  (goto (label after-call14))
  primitive-branch16
  (assign proc (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call14
  (assign val (const y))
  (assign argl (op list) (reg val))
  (assign val (const x))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch20))
  compiled-branch19
  (assign continue (label after-call18))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch20
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call18))
#+END_SRC

57 instructions versus 27 instructions.
**** Case 3: =(f (g 'x) y)=
Modified version:
#+BEGIN_SRC scheme
((env continue)
 (env proc argl continue val)
 ((save continue)
  (save env)
  (save continue)
  (assign proc (op lookup-variable-value) (const f) (reg env))
  (restore continue)
  (restore env)
  (restore continue)
  (save continue)
  (save proc)
  (save env)
  (save continue)
  (assign val (op lookup-variable-value) (const y) (reg env))
  (restore continue)
  (assign argl (op list) (reg val))
  (restore env)
  (save argl)
  (save continue)
  (save env)
  (save continue)
  (assign proc (op lookup-variable-value) (const g) (reg env))
  (restore continue)
  (restore env)
  (restore continue)
  (save continue)
  (save proc)
  (save continue)
  (assign val (const x))
  (restore continue)
  (assign argl (op list) (reg val))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch29))
  compiled-branch28
  (assign continue (label after-call27))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch29
  (save continue)
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (restore continue)
  after-call27
  (restore argl)
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch32))
  compiled-branch31
  (assign continue (label after-call30))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch32
  (save continue)
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (restore continue)
  after-call30))
#+END_SRC

Original version:
#+BEGIN_SRC scheme
((env)
 (env proc argl continue val)
 ((assign proc (op lookup-variable-value) (const f) (reg env))
  (save proc)
  (assign val (op lookup-variable-value) (const y) (reg env))
  (assign argl (op list) (reg val))
  (save argl)
  (assign proc (op lookup-variable-value) (const g) (reg env))
  (assign val (const x))
  (assign argl (op list) (reg val))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch23))
  compiled-branch22
  (assign continue (label after-call21))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch23
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call21
  (restore argl)
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch26))
  compiled-branch25
  (assign continue (label after-call24))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch26
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call24))
#+END_SRC

57 versus 29.
**** Case 4: =(f (g 'x) 'y)=
Modified version:
#+BEGIN_SRC scheme
((env continue)
 (env proc argl continue val)
 ((save continue)
  (save env)
  (save continue)
  (assign proc (op lookup-variable-value) (const f) (reg env))
  (restore continue)
  (restore env)
  (restore continue)
  (save continue)
  (save proc)
  (save env)
  (save continue)
  (assign val (const y))
  (restore continue)
  (assign argl (op list) (reg val))
  (restore env)
  (save argl)
  (save continue)
  (save env)
  (save continue)
  (assign proc (op lookup-variable-value) (const g) (reg env))
  (restore continue)
  (restore env)
  (restore continue)
  (save continue)
  (save proc)
  (save continue)
  (assign val (const x))
  (restore continue)
  (assign argl (op list) (reg val))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch35))
  compiled-branch34
  (assign continue (label after-call33))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch35
  (save continue)
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (restore continue)
  after-call33
  (restore argl)
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch38))
  compiled-branch37
  (assign continue (label after-call36))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch38
  (save continue)
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (restore continue)
  after-call36))
#+END_SRC
57 versus 29.
**** Conclusion
By using the "annotate" feature of =preserving=, we can halve the instructions.
*** Exercise 5.38
**** a.
Based on the problem statement, =spread-arguments= has form of
=(spread-arguments <operands>)=; and it should have following skeleton code:
#+BEGIN_SRC text
<complie first argument; targeted to arg1; linkage to next>
<complie last (second) argument; targeted to arg2; linkage to next;
 preserving arg1 register>
#+END_SRC

For the last linkage point is arbitrary; but if we think about the use cases
followed by this sub-exercise, it implies we should link these code with =next=.

In addition to these, we need to preserve the =env= register around the compiled
code of first argument since the second argument need to be evaluated in that =env=.

Here is the code:
#+BEGIN_SRC scheme
(define (spread-arguments args)
  (let ((a1 (car args))
        (a2 (cadr args)))
    (preserving
     '(env)
     (compile a1 'arg1 'next)
     (preserving
      '(arg1)
      (compile a2 'arg2 'next)
      (make-instruction-sequence
       '(arg1) '() '())))))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(pp (spread-arguments '(x y)))
((env) (arg1 arg2)
 ((assign arg1 (op lookup-variable-value) (const x) (reg env))
  (assign arg2 (op lookup-variable-value) (const y) (reg env))))
#+END_SRC

For the test of recursive case -- compiling each argument can alter the
preceding target register, we delegate after *b.* since for now we don't have
any compile clause that alter the argument registers.
**** b.
Then we can easily implements the open-code clauses. First let's implement the
equal procedure:
#+BEGIN_SRC scheme
(define (compile-= exp target linkage)
  (end-with-linkage
   linkage
   (append-instruction-sequences
    (spread-arguments (operands exp))
    (make-instruction-sequence
     '(arg1 arg2)
     (list target)
     `((assign ,target (op =) (reg arg1) (reg arg2)))))))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(pp (compile-= '(= 5 2) 'val 'next))
(() (arg1 arg2 val)
 ((assign arg1 (const 5))
  (assign arg2 (const 2))
  (assign val (op =) (reg arg1) (reg arg2))))
#+END_SRC

Let's install it into the =compile=:
#+BEGIN_SRC scheme
(define (=? exp) (tagged-list? exp '=))
#+END_SRC

And then
#+BEGIN_SRC scheme
,*** in compile
        ((=? exp) (compile-= exp target linkage))
        ((application? exp)
         (compile-application exp target linkage))
#+END_SRC

Then we can test the recursive case, which we couldn't in *a.*
#+BEGIN_SRC scheme
(pp (compile '(= (= 5 2) (= 2 1))
         'val 'next))

(()
 (arg1 arg2 val)
 ((assign arg1 (const 5))
  (assign arg2 (const 2))
  (assign arg1 (op =) (reg arg1) (reg arg2))
  (save arg1)
  (assign arg1 (const 2))
  (assign arg2 (const 1))
  (assign arg2 (op =) (reg arg1) (reg arg2))
  (restore arg1)
  (assign val (op =) (reg arg1) (reg arg2))))
#+END_SRC

As it verified, now let's add the rest open-code primitives.

Before implementing each of the primitives, observe the commonalities among the
open-code things; the only difference is the operation name: Let's exploit them!
If we restrict the open code primitives only allowed to be binary, then we can
exploit that a lot:
#+BEGIN_SRC scheme
(define (compile-open-coded-prim exp target linkage op)
  (end-with-linkage
   linkage
   (append-instruction-sequences
    (spread-arguments (operands exp))
    (make-instruction-sequence
     '(arg1 arg2)
     (list target)
     `((assign ,target (op ,op) (reg arg1) (reg arg2)))))))

;; open-code primitive dictionary
(define open-coded-prims '((= =) (* *) (- -) (+ +)))

(define (open-coded-prims? exp)
  (assoc (operator exp) open-coded-prims))
#+END_SRC

Then
#+BEGIN_SRC scheme
,**+ in compile procedure
...
        ;; ((=? exp) (compile-= exp target linkage))
        ((open-coded-prims? exp) =>
         (lambda (op-binding)
           (compile-open-coded-prim exp target linkage (cadr op-binding))))
        (application? exp)
...
#+END_SRC

But since in *d.* part we want to extend particular operations to take arbitrary
number of argument, they needs special treatment other than this; we'll comeback
this issue at *d.* part.

Then test:
#+BEGIN_SRC scheme
;; The previous one works well in this new scheme
(pp (compile '(= (= 5 2) (= 2 1))
         'val 'next))
(()
 (arg1 arg2 val)
 ((assign arg1 (const 5))
  (assign arg2 (const 2))
  (assign arg1 (op =) (reg arg1) (reg arg2))
  (save arg1)
  (assign arg1 (const 2))
  (assign arg2 (const 1))
  (assign arg2 (op =) (reg arg1) (reg arg2))
  (restore arg1)
  (assign val (op =) (reg arg1) (reg arg2))))

;; Complex one also works well
(pp (compile '(= (+ (- 5 2) (* 1 2)) 5)
             'val 'next))
(()
 (arg1 arg2 val)
 ((assign arg1 (const 5))
  (assign arg2 (const 2))
  (assign arg1 (op -) (reg arg1) (reg arg2))
  (save arg1)
  (assign arg1 (const 1))
  (assign arg2 (const 2))
  (assign arg2 (op *) (reg arg1) (reg arg2))
  (restore arg1)
  (assign arg1 (op +) (reg arg1) (reg arg2))
  (assign arg2 (const 5))
  (assign val (op =) (reg arg1) (reg arg2))))
#+END_SRC

In addition to this feature, we may want to ensure the given expression has only
two operands. We can ensure this with following modification:
#+BEGIN_SRC scheme
(define (open-coded-prims? exp)
  (and (= (length (operands exp)) 2)    ;binary
       (assoc (operator exp) open-coded-prims)))
#+END_SRC
**** c.
Then now let's try to compile =factorial= in this new strategy:
#+BEGIN_SRC scheme
(pp (compile
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 'val
 'next))

((env)
 (val)
 ((assign val (op make-compiled-procedure) (label entry55) (reg env))
  (goto (label after-lambda54))
  entry55
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
  (assign arg1 (op lookup-variable-value) (const n) (reg env))
  (assign arg2 (const 1))
  (assign val (op =) (reg arg1) (reg arg2))
  (test (op false?) (reg val))
  (branch (label false-branch57))
  true-branch58
  (assign val (const 1))
  (goto (reg continue))
  false-branch57
  (save continue)
  (save env)
  (assign proc (op lookup-variable-value) (const factorial) (reg env))
  (assign arg1 (op lookup-variable-value) (const n) (reg env))
  (assign arg2 (const 1))
  (assign val (op -) (reg arg1) (reg arg2))
  (assign argl (op list) (reg val))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch61))
  compiled-branch60
  (assign continue (label proc-return62))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  proc-return62
  (assign arg1 (reg val))
  (goto (label after-call59))
  primitive-branch61
  (assign arg1 (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call59
  (restore env)
  (assign arg2 (op lookup-variable-value) (const n) (reg env))
  (assign val (op *) (reg arg1) (reg arg2))
  (restore continue)
  (goto (reg continue))
  after-if56
  after-lambda54
  (perform (op define-variable!) (const factorial) (reg val) (reg env))
  (assign val (const ok))))
#+END_SRC

Got way more cleaner than [[Exercise 5.33][previous]].
**** d.
Since =*= and =+= satisfy the associative rule, we may exploit this property to
the compiler; but for the consistency with possible further extension where
primitive procedure does not satisfy the associative rule -- =-= , =/= , and so
on -- here we are going to implement the arithmetic operation with arbitrary
arity in =fold-right= manner -- calculate the rightmost operands first.

To deduce the algorithm, we should play with simple examples: Let's think about
=(+ 1 2 3 4)=. We would like to produce the code by compiling as follows
#+BEGIN_SRC scheme
(assign arg2 (const 4))
(assign arg1 (const 3))
(assign arg2 (op +) (reg arg1) (reg arg2))
(assign arg1 (const 2))
(assign arg2 (op +) (reg arg1) (reg arg2))
(assign arg1 (const 1))
(assign target (op +) (reg arg1) (reg arg2))
#+END_SRC

From this example, we can observe the first and last instruction treated specially.

As consequence, in general, compiling =(+ a1 a2 a3 a4)= should produce
#+BEGIN_SRC text
<compile a4; target to arg2; linkage to next; preserving env>
<compile a3; target to arg1; linkage to next; preserving env, arg2>
(assign arg2 (op +) (reg arg1) (reg arg2))
<compile a2; target to arg1; linkage to next; preserving env, arg2>
(assign arg2 (op +) (reg arg1) (reg arg2))
<compile a1; target to arg1; linkage to next; preserving arg2>
(assign target (op +) (reg arg1) (reg arg2))
<code for goto linkage point>
#+END_SRC

This is very much the same as the =construct-arglist=. Here is the code for =+=:
#+BEGIN_SRC scheme
(define (compile-+ exp target linkage)

  (define (code-to-rest-+ operands)
    (let* ((last-operand? (no-operands? (rest-operands operands)))
           (next-target
            (if last-operand?
                target
                'arg2))
           (code-for-next-+
            (preserving
             '(arg2)
             (compile (first-operand operands)
                      'arg1 'next)
             (make-instruction-sequence
              '(arg1 arg2) (list next-target)
              `((assign ,next-target (op +) (reg arg1) (reg arg2)))))))
      (if last-operand?
          code-for-next-+
          (preserving
           '(env)
           code-for-next-+
           (code-to-rest-+ (rest-operands operands))))))

  (let ((operands (operands exp)))
    (let ((number-of-arguments (length operands)))
      (case number-of-arguments
        ((0)
         (end-with-linkage
          linkage
          (make-instruction-sequence
           '() (list target))
          `((assign ,target (const 0)))))
        ((1)
         (compile (first-operand operands)
                  target linkage))
        (else
         (let ((operands (reverse operands)))
           (end-with-linkage
            linkage
            (preserving
             '(env)
             (compile (first-operand operands)
                      'arg2 'next)
             (code-to-rest-+ (rest-operands operands))))))))))
#+END_SRC

Then let's install this:
#+BEGIN_SRC scheme
;; detector for +
(define (+? exp) (tagged-list? exp '+))
#+END_SRC

And
#+BEGIN_SRC scheme
,*** in compile clause
        ;; ((=? exp) (compile-= exp target linkage))
        ((+? exp) (compile-+ exp target linkage))
        ((open-coded-prims? exp) =>
         (lambda (op-binding)
           (compile-open-coded-prim exp target linkage (cadr op-binding))))
        (application? exp)
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;; test for compile-+
(pp (compile '(+ 1 2 3 4) 'val 'next))
(()
 (arg2 arg1 val)
 ((assign arg2 (const 4))
  (assign arg1 (const 3))
  (assign arg2 (op +) (reg arg1) (reg arg2))
  (assign arg1 (const 2))
  (assign arg2 (op +) (reg arg1) (reg arg2))
  (assign arg1 (const 1))
  (assign val (op +) (reg arg1) (reg arg2))))
#+END_SRC

Note that =code-to-rest-+= can be generalized to any of expression that use
recursive definition. Let's extract out from the =compile-+=:
#+BEGIN_SRC scheme
(define (apply-recursively- op target operands)
  (let* ((last-operand? (no-operands? (rest-operands operands)))
         (next-target
          (if last-operand?
              target
              'arg2))
         (code-for-next-op
          (preserving
           '(arg2)
           (compile (first-operand operands)
                    'arg1 'next)
           (make-instruction-sequence
            '(arg1 arg2) (list next-target)
            `((assign ,next-target (op ,op) (reg arg1) (reg arg2)))))))
    (if last-operand?
        code-for-next-op
        (preserving
         '(env)
         code-for-next-op
         (apply-recursively- op target (rest-operands operands))))))
#+END_SRC

Then our original =compile-+= got
#+BEGIN_SRC scheme
(define (compile-+ exp target linkage)
  (let ((operands (operands exp)))
    (let ((number-of-arguments (length operands)))
      (case number-of-arguments
        ((0)
         (end-with-linkage
          linkage
          (make-instruction-sequence
           '() (list target))
          `((assign ,target (const 0)))))
        ((1)
         (compile (first-operand operands)
                  target linkage))
        (else
         (let ((operands (reverse operands)))
           (end-with-linkage
            linkage
            (preserving
             '(env)
             (compile (first-operand operands)
                      'arg2 'next)
             (apply-recursively- '+ target (rest-operands operands))))))))))
#+END_SRC

The other is almost same as above:
#+BEGIN_SRC scheme
;; detector for *
(define (*? exp) (tagged-list? exp '*))

(define (compile-* exp target linkage)
  (let ((operands (operands exp)))
    (let ((number-of-arguments (length operands)))
      (case number-of-arguments
        ((0)
         (end-with-linkage
          linkage
          (make-instruction-sequence
           '() (list target))
          `((assign ,target (const 1))))) ;difference
        ((1)
         (compile (first-operand operands)
                  target linkage))
        (else
         (let ((operands (reverse operands)))
           (end-with-linkage
            linkage
            (preserving
             '(env)
             (compile (first-operand operands)
                      'arg2 'next)
             (apply-recursively- '* target (rest-operands operands)))))))))) ;the other one
#+END_SRC
Only the ones annotated is the change from =compile-+=
** Lexical Addressing
*** Exercise 5.39
Here is the code:
#+BEGIN_SRC scheme
(define (lexical-address-lookup address env)
  (let ((val
         (list-ref
          (frame-values
           (frame-ref env (frame-number address)))
          (displacement-number address))))
    (if (eq? val '*unassigned*)
        (error "Unassigned variable:"
               (list-ref
                (frame-variables
                 (frame-ref env (frame-number address)))
                (displacement-number address)))
        val)))

;; ADT for environment
(define (frame-ref env index) (list-ref env index))

;; ADT for lexical-address
(define (make-lexical-address frame-num displacement-num)
  `(,frame-num ,displacement-num))
(define (frame-number address) (car address))
(define (displacement-number address) (cadr address))
#+END_SRC

Test:
#+BEGIN_SRC scheme
;; Test for lexical-address-lookup
(define test-environment
  (extend-environment
   '(y z) '((* a b x) (+ c d x))
   (extend-environment
    '(a b c d e)
    '(*unassigned* *unassigned* *unassigned* *unassigned* *unassigned*)
    (extend-environment
     '(x y)
     '(3 4)
     the-empty-environment))))

;; variable x
(lexical-address-lookup '(2 0) test-environment)

;Value: 3

;; variable a
(lexical-address-lookup '(1 0) test-environment)

;Unassigned variable: a
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

Then =lexical-address-set!= can be implemented similarly:
#+BEGIN_SRC scheme
(define (lexical-address-set! address val env)
  (set-car!
   (list-tail
    (frame-values
     (frame-ref env (frame-number address)))
    (displacement-number address))
   val))
#+END_SRC

Let's test:
#+BEGIN_SRC scheme
;; setting the value for a
(lexical-address-set! '(1 0) 1 test-environment)

;Unspecified return value

(lexical-address-lookup '(1 0) test-environment)

;Value: 1
#+END_SRC
*** Exercise 5.40
Here is the main code:
#+BEGIN_SRC scheme
;;; environemnt ADT
(define (extend-compile-time-env params env)
  (cons params env))
(define the-empty-compile-time-env '())

(define (compile-lambda-body exp proc-entry env)
  (let* ((formals (lambda-parameters exp))
        (env (extend-compile-time-env formals env)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return env))))
#+END_SRC

Then we should modify current =compile= clauses to accept =env= as additional
argument. Please see the [[file:Exercise/ch5-compiler.scm][code]] for the result.
*** Exercise 5.41
Here is simple implementation using loop:
#+BEGIN_SRC scheme
(define (find-variable var env)
  (let traverse-env ((current-env env)
                     (frame-num 0))
    (if (empty-env? current-env)
        'not-found
        (let traverse-frame ((current-vars (frame-vars current-env))
                             (displacement-num 0))
          (cond ((empty-vars? current-vars)
                 (traverse-env (enclosing-env current-env)
                               (1+ frame-num)))
                ((eq? var (first-var current-vars))
                 (make-lexical-address frame-num displacement-num))
                (else
                 (traverse-frame (rest-vars current-vars)
                                 (1+ displacement-num))))))))
;; ADT for compile-time-env
(define (frame-vars compile-time-env)
  (car compile-time-env))
(define (enclosing-env compile-time-env)
  (cdr compile-time-env))
(define (empty-env? compile-time-env) (null? compile-time-env))

;; ADT for compile-time-frame
(define (first-var compile-time-frame) (car compile-time-frame))
(define (rest-vars compile-time-frame) (cdr compile-time-frame))
(define (empty-vars? compile-time-frame) (null? compile-time-frame))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
;; test for find-variable
(find-variable 'c '((y z) (a b c d e) (x y)))

;Value: (1 2)

(find-variable 'x '((y z) (a b c d e) (x y)))

;Value: (2 0)

(find-variable 'w '((y z) (a b c d e) (x y)))

;Value: not-found
#+END_SRC
*** Exercise 5.42
Here is the code that exploit the lexical address; and incorporated the strategy
suggested in the text:
#+BEGIN_SRC scheme
(define (compile-variable exp target linkage env)
  (let ((address (find-variable exp env)))
    (end-with-linkage
     linkage
     (if (eq? address 'not-found)
         (make-instruction-sequence
          '() (list-union '(env) (list target))
          `((assign env (op get-global-environment))
            (assign ,target
                    (op lookup-variable-value)
                    (const ,exp)
                    (reg env))))
         (make-instruction-sequence
          '(env) (list target)
          `((assign ,target
                    (op lexical-address-lookup)
                    (const ,address)
                    (reg env))))))))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
;;; Test for new compile-variable
(pp (compile
     '((lambda (x y)
         (lambda (a b c d e)
           ((lambda (y z) (* x y z))
            (* a b x)
            (+ c d x))))
       3
       4)
     'val 'next the-empty-compile-time-env))

((env)
 (env proc argl continue val)
 ((assign proc (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))
  entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (x y)) (reg argl) (reg env))
  (assign val (op make-compiled-procedure) (label entry4) (reg env))
  (goto (reg continue))
  entry4
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (a b c d e)) (reg argl) (reg env))
  (assign proc (op make-compiled-procedure) (label entry6) (reg env))
  (goto (label after-lambda5))
  entry6
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (y z)) (reg argl) (reg env))
  (assign arg2 (op lexical-address-lookup) (const (0 1)) (reg env))
  (assign arg1 (op lexical-address-lookup) (const (0 0)) (reg env))
  (assign arg2 (op *) (reg arg1) (reg arg2))
  (assign arg1 (op lexical-address-lookup) (const (2 0)) (reg env))
  (assign val (op *) (reg arg1) (reg arg2))
  (goto (reg continue))
  after-lambda5
  (assign arg2 (op lexical-address-lookup) (const (1 0)) (reg env))
  (assign arg1 (op lexical-address-lookup) (const (0 3)) (reg env))
  (assign arg2 (op +) (reg arg1) (reg arg2))
  (assign arg1 (op lexical-address-lookup) (const (0 2)) (reg env))
  (assign val (op +) (reg arg1) (reg arg2))
  (assign argl (op list) (reg val))
  (assign arg2 (op lexical-address-lookup) (const (1 0)) (reg env))
  (assign arg1 (op lexical-address-lookup) (const (0 1)) (reg env))
  (assign arg2 (op *) (reg arg1) (reg arg2))
  (assign arg1 (op lexical-address-lookup) (const (0 0)) (reg env))
  (assign val (op *) (reg arg1) (reg arg2))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch9))
  compiled-branch8
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch9
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
  after-call7
  after-lambda3
  after-lambda1
  (assign val (const 4))
  (assign argl (op list) (reg val))
  (assign val (const 3))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch12))
  compiled-branch11
  (assign continue (label after-call10))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch12
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call10))
#+END_SRC

Looks fine. Let's implement the other one also:
#+BEGIN_SRC scheme
(define (compile-assignment exp target linkage env)
  (let* ((var (assignment-variable exp))
         (get-value-code
          (compile (assignment-value exp) 'val 'next env))
         (address (find-variable var env)))
    (end-with-linkage
     linkage
     (if (eq? address 'not-found)
         (append-instruction-sequences
          get-value-code
          (make-instruction-sequence
           '(val) (list-union (list target) '(env))
           `((assign env (op get-global-environment))
             (perform (op set-variable-value!)
                      (const ,var)
                      (reg val)
                      (reg env))
             (assign ,target (const ok)))))
         (preserving
          '(env)
          get-value-code
          (make-instruction-sequence
           '(env val) (list target)
           `((perform (op lexical-address-set!)
                      (const ,address)
                      (reg val)
                      (reg env))
             (assign ,target (const ok)))))))))
#+END_SRC

Then do the test:
#+BEGIN_SRC scheme
;;; Test for new compile-assignment
(pp (compile
     '((lambda (x y)
         (lambda (a b c d e)
           ((lambda (y z)
              (set! a 5)
              (* x y z))
            (* a b x)
            (+ c d x))))
       3
       4)
     'val 'next the-empty-compile-time-env))

((env)
 (env proc argl continue val)
 ((assign proc (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))
  entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (x y)) (reg argl) (reg env))
  (assign val (op make-compiled-procedure) (label entry4) (reg env))
  (goto (reg continue))
  entry4
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (a b c d e)) (reg argl) (reg env))
  (assign proc (op make-compiled-procedure) (label entry6) (reg env))
  (goto (label after-lambda5))
  entry6
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (y z)) (reg argl) (reg env))
  (assign val (const 5))
  (perform (op lexical-address-set!) (const (1 0)) (reg val) (reg env))
  (assign val (const ok))
  (assign arg2 (op lexical-address-lookup) (const (0 1)) (reg env))
  (assign arg1 (op lexical-address-lookup) (const (0 0)) (reg env))
  (assign arg2 (op *) (reg arg1) (reg arg2))
  (assign arg1 (op lexical-address-lookup) (const (2 0)) (reg env))
  (assign val (op *) (reg arg1) (reg arg2))
  (goto (reg continue))
  after-lambda5
  (assign arg2 (op lexical-address-lookup) (const (1 0)) (reg env))
  (assign arg1 (op lexical-address-lookup) (const (0 3)) (reg env))
  (assign arg2 (op +) (reg arg1) (reg arg2))
  (assign arg1 (op lexical-address-lookup) (const (0 2)) (reg env))
  (assign val (op +) (reg arg1) (reg arg2))
  (assign argl (op list) (reg val))
  (assign arg2 (op lexical-address-lookup) (const (1 0)) (reg env))
  (assign arg1 (op lexical-address-lookup) (const (0 1)) (reg env))
  (assign arg2 (op *) (reg arg1) (reg arg2))
  (assign arg1 (op lexical-address-lookup) (const (0 0)) (reg env))
  (assign val (op *) (reg arg1) (reg arg2))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch9))
  compiled-branch8
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch9
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
  after-call7
  after-lambda3
  after-lambda1
  (assign val (const 4))
  (assign argl (op list) (reg val))
  (assign val (const 3))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch12))
  compiled-branch11
  (assign continue (label after-call10))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch12
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call10))
#+END_SRC
*** Exercise 5.43
Like =cond->if=, this one is also just one of the derived form! So we can reuse
the previous =scan-out-defines=. Here we modified the previous definition using
the continuation for the efficiency and to return the body if there is no
internal definitions rather than transforming to =let= expression:
#+BEGIN_SRC scheme
(define (scan-out-defines proc-body)
  (let loop
      ((exps proc-body)
       (accept
        (lambda (internal-defs rest-body)
          (if (null? internal-defs)
              rest-body
              (let ((vars (map definition-variable internal-defs))
                    (exps (map definition-value internal-defs)))
                (let ((bindings
                       (map (lambda (var) (list var (list 'quote '*unassigned*)))
                            vars))
                      (set-exps
                       (map (lambda (var val)
                              (make-assignment var val))
                            vars
                            exps)))
                  (make-let bindings (append set-exps rest-body))))))))
    (if (null? exps)
        (accept '() '())
        (let ((exp (car exps))
              (rest (cdr exps)))
          (loop
           rest
           (lambda (defs rest-body)
             (if (definition? exp)
                 (accept (cons exp defs)
                         rest-body)
                 (if (null? defs)
                     (accept defs
                             (cons exp rest-body))
                     (error "Internal defintions intertwines with others" proc-body)))))))))
#+END_SRC

Then =compile-lambda-body= got
#+BEGIN_SRC scheme
(define (compile-lambda-body exp proc-entry env)
  (let* ((formals (lambda-parameters exp))
         (env (extend-compile-time-env formals env)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (let ((scanned (scan-out-defines (lambda-body exp))))
       (if (let? scanned)
           (compile scanned 'val 'return env)
           (compile-sequence scanned 'val 'return env))))))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
;;; test for new feature!
(pp (compile
     '(lambda (x y)
        (define (test-internal x y z) z)
        (define y 5)
        (+ y (test-internal x y 3)))
     'val 'next the-empty-compile-time-env))

((env)
 (val)
 ((assign val (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))
  entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (x y)) (reg argl) (reg env))
  (assign proc (op make-compiled-procedure) (label entry4) (reg env))
  (goto (label after-lambda3))
  entry4
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (test-internal y)) (reg argl) (reg env))
  (assign val (op make-compiled-procedure) (label entry10) (reg env))
  (goto (label after-lambda9))
  entry10
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (x y z)) (reg argl) (reg env))
  (assign val (op lexical-address-lookup) (const (0 2)) (reg env))
  (goto (reg continue))
  after-lambda9
  (perform (op lexical-address-set!) (const (0 0)) (reg val) (reg env))
  (assign val (const ok))
  (assign val (const 5))
  (perform (op lexical-address-set!) (const (0 1)) (reg val) (reg env))
  (assign val (const ok))
  (save continue)
  (save env)
  (assign proc (op lexical-address-lookup) (const (0 0)) (reg env))
  (assign val (const 3))
  (assign argl (op list) (reg val))
  (assign val (op lexical-address-lookup) (const (0 1)) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (assign val (op lexical-address-lookup) (const (1 0)) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch7))
  compiled-branch6
  (assign continue (label proc-return8))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  proc-return8
  (assign arg2 (reg val))
  (goto (label after-call5))
  primitive-branch7
  (assign arg2 (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call5
  (restore env)
  (assign arg1 (op lexical-address-lookup) (const (0 1)) (reg env))
  (assign val (op +) (reg arg1) (reg arg2))
  (restore continue)
  (goto (reg continue))
  after-lambda3
  (assign val (const *unassigned*))
  (assign argl (op list) (reg val))
  (assign val (const *unassigned*))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch13))
  compiled-branch12
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch13
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
  after-call11
  after-lambda1))
#+END_SRC

Looks fine!
*** Exercise 5.44
The reasoning behind what we trying to implement is follows: If the given open
coded primitive procedure found in the given compile time environment (with
=find-variable= procedure), then we should hand over given expression to the
=compile-application=; otherwise, it means either given procedure variable bound
in global environment which is dynamic one so we can not access that in compile
time or not bound at all (to be used compile time).

This analysis means the only case we can not cope with in this scheme is the one
defined in global environment by =define= or through =set!= what primitive
procedure bound in the global environment for the interpreter.

Well, enough for word; let's implement it:
#+BEGIN_SRC scheme
(define (not-bound? var env)
  (eq? (find-variable var env) 'not-found))
#+END_SRC

And then
#+BEGIN_SRC scheme
,*** in compile clause
        ((and (not-bound? (operator exp) env)
              (+? exp))
         (compile-+ exp target linkage env))
        ((and (not-bound? (operator exp) env)
              (*? exp))
         (compile-* exp target linkage env))
        ((and (not-bound? (operator exp) env)
              (open-coded-prims? exp)) =>
         (lambda (op-binding)
           (compile-open-coded-prim exp target linkage env (cadr op-binding))))
        ((application? exp)
         (compile-application exp target linkage env))
#+END_SRC

We just delegated if the given operator is rebound.

Then test!
#+BEGIN_SRC scheme
;; Test for this new feature
(pp (compile
     '(lambda (+ * a b x y)
        (+ (* a x) (* b y)))
     'val 'next the-empty-compile-time-env))

((env)
 (val)
 ((assign val (op make-compiled-procedure) (label entry13) (reg env))
  (goto (label after-lambda12))
  entry13
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment) (const (+ * a b x y)) (reg argl) (reg env))
  (assign proc (op lexical-address-lookup) (const (0 0)) (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc (op lexical-address-lookup) (const (0 1)) (reg env))
  (assign val (op lexical-address-lookup) (const (0 5)) (reg env))
  (assign argl (op list) (reg val))
  (assign val (op lexical-address-lookup) (const (0 3)) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
  compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch19
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call17
  (assign argl (op list) (reg val))
  (restore env)
  (save argl)
  (assign proc (op lexical-address-lookup) (const (0 1)) (reg env))
  (assign val (op lexical-address-lookup) (const (0 4)) (reg env))
  (assign argl (op list) (reg val))
  (assign val (op lexical-address-lookup) (const (0 2)) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch16))
  compiled-branch15
  (assign continue (label after-call14))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch16
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  after-call14
  (restore argl)
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
  compiled-branch21
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
  primitive-branch22
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
  after-call20
  after-lambda12))
#+END_SRC

Works well.
