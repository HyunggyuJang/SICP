#+TITLE: SICP Study Note
* Building Abstractions with Data
** Hierarchical Data and the Closure Property
*** Repersenting Sequences
- Does it prints same as list to construct a sequence by conses?
  #+BEGIN_SRC scheme
(cons 1 (cons 2 (cons 3 (cons 4 '()))))
  #+END_SRC

  #+RESULTS:
  | 1 | 2 | 3 | 4 |

  #+BEGIN_SRC scheme
(list 1 2 3 4)
  #+END_SRC

  #+RESULTS:
  | 1 | 2 | 3 | 4 |

  →Yeah, looks same.
**** Exercise 2.17
#+BEGIN_SRC scheme
(define (last-pair items)               ;assume items is non empty list
  (let ((next-p (cdr items)))
    (if (null? next-p)
        items
        (last-pair next-p))))
#+END_SRC

#+RESULTS:
: #<unspecified>

Let's test with it
#+BEGIN_SRC scheme
(last-pair (list 23 72 149 34))
#+END_SRC

#+RESULTS:
| 34 |

It works.

**** Exercise 2.18
#+BEGIN_SRC scheme
(define (reverse l)
  (define (iter l r)
    (if (null? l)
        r
        (iter (cdr l) (cons (car l) r))))
  (iter l nil))                         ; we don't know what nil is but assume we have
#+END_SRC
Or do not use nil explicitly analogous to last-pair.
#+BEGIN_SRC scheme
(define (reverse l)                     ;assume that l is not empty
  (let ((next-p (cdr l)))
    (if (null? next-p)
        l
        (append (reverse next-p) (list (car l))))))
(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))
#+END_SRC

#+RESULTS:
: #<unspecified>

**** Exercise 2.19
Let's review the change-counting program. We know that the number of
change-count can be reduced as follows:
- Exchange the change using the first coin and
- not using the first coin


The above states the reductive process. To complete the whole process of it, we
need to specify the base case:
- when the amount is zero, then we have only one way to change.


It is quite tricky at first why this is true; but think it this way: simulate
the situation with some simple case,e.g. the amount is 6 cents or like that.
Then we come to realize it really need to count as 1 when amount is zero in this
recursive process.

That's not the only base case; by the reductive process we have only two cases left to consider:
- when we have 0 coins to change, we count this as 0 and
- when we have negative amount to change, there is no way to change the amount; 0.


Again, we can got the guts by simulating the simple cases or more formally we
should reason this argument using induction. I think it is reasonable to use the
computer aided proof check like this situation because humankind inherited the
error-prone property. Nonetheless let's code.

Then we can code this recursive process:
#+BEGIN_SRC scheme
(define us-coins (list 50 25 10 5 1))   ;examples of how the parameter, coin-values, constructed
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((< amount 0) 0)
        ((no- wjmore? coin-values) 0)         ;↑base cases
        (else (+ (cc (- amount
                        (first-denomination coin-values)) ;first reduction branch
                     coin-values)
                 (cc amount             ;second (last) reduction branch
                     (except-first-denomination coin-values))))))

(define (no-more? coin-values)
  (null? coin-values)) ;we could (define no-more? null?) but we don't like to mess up the debugger

(define (first-denomination coin-values)
  (car coin-values))                 ;we provided that the coin-values not empty

(define (except-first-denomination coin-values)
  (cdr coin-values))                 ;we provided that the coin-values not empty
#+END_SRC

#+RESULTS:

We can reason that the order of the list ~coin-values~ does not affect the
answer produced by cc; it just only takes more times to evaluate it.

We can assure that by experimenting with some examples:
#+BEGIN_SRC scheme :returns value
(define us-reverse (reverse us-coins))
(cc 100 us-reverse)
(cc 100 us-coins)
(cc 112 us-reverse)
(cc 112 us-coins)
#+END_SRC

#+RESULTS:

The ~us-reverse~ results to same as ~us-coins~. Why should it be?: The reductive
process and base case I've wrote above does not mention about the order of
coins; it should behave as same whatever order is.

Then how about the efficiency (complexity) of space and times? We can guess the
reversed order should be more complex than the previous case; but it is not
obvious.

Let's do some trick. While we have not studied the ~set!~ statement, but it is
useful to estimate the complexity and get some intuition about the general case:
#+BEGIN_SRC scheme
(define (cc amount coin-values)
  (define (cc-counter amount coin-values)
    (cond ((= amount 0)
           (set! count (1+ count))
           1)
          ((< amount 0)
           (set! count (1+ count))
           0)
          ((no-more? coin-values)
           (set! count (1+ count))
           0)                           ;↑base cases
          (else
           (set! count (1+ count))
           (+ (cc-counter (- amount
                     (first-denomination coin-values)) ;first reduction branch
                  coin-values)
              (cc-counter amount                ;second (last) reduction branch
                  (except-first-denomination coin-values))))))
  (define count 0)                      ;count the steps needed to evaluate cc
  (cons count (cc-counter amount coin-values))) ;return the pair of count and number of cc ways
#+END_SRC

Then we can inspect by using that:
#+BEGIN_SRC scheme
(cc 100 us-reverse)                     ;=> (38901 . 292)
(cc 100 us-coins)                       ;=> (15499 . 292)
#+END_SRC

Yeah, as we expected, the reversed version needs more than double steps than original.
How can we reason this? Let's we do some simulation with simple argument using
substitution model. After some experiment, I've realized it is hard to prove
that the reversed one has more step complexity than previous in asymptotic notation.
To prove that the reversed one has more step & space complextity, we should
prove that using inequality sign not asymptotic notation; it will convolve more
subtle argument. We should use proof assistant otherwise it become really tricky
to prove.
**** Exercise 2.20
I've started not to think about the structure. It's the evidence that I've
exhausted completely. Anyway here is the code:
#+BEGIN_SRC scheme
(define (same-parity first . rest)
  (let ((same? (if (even? first)
                   even?
                   odd?)))
    (cons first (filter same? rest))))  ;wishful tinking

(define (filter include? l)
  (if (null? l)
      l
      (let ((hd (car l))                ;it would be clearer if I use the let* notation.
            (tl (cdr l)))               ;but I've not learned yet.
        (let ((filtered
               (filter include? tl)))
          (if (include? hd)
              (cons hd filtered)
              filtered)))))
#+END_SRC
Isn't this obvious to explain? Anyway, I'll skip that.
**** Mapping over lists
#+BEGIN_SRC scheme
(define (map proc items)
  (if null? items)
  nil
  (cons (proc (car items))
        (map proc (cdr items))))
#+END_SRC
**** Exercise 2.21
#+BEGIN_SRC scheme
(define (square-list items)
  (if (null? items)
      nil
      (cons (square (car items) (square-list (cdr items))))))

(define (square-list items)
  (map square items))
#+END_SRC
**** Exercise 2.22
1. Because the structure of the helper procedure iter is same as our first
   definition of [[Exercise 2.18][reverse]].
2. List is, by definition, sequence of pairs. But the tried implementation
   returns something other than list: ~(cons answer (square (car things)))~ is
   not chained pairs.


**** Exercise 2.23
*First try*
#+BEGIN_SRC scheme
(define (for-each proc items)
  (if (null? items)                     ;base case
      true                              ;done case (termination)
.....
#+END_SRC
↑ We can not use if clause for evaluation of sequenced statement.
So we should use cond clause instead.
#+BEGIN_SRC scheme
(define (for-each proc items)
  (cond ((null? items) true)            ;termination (base) case return true, which can be arbitrary value.
        (else
         (proc (car items))
         (for-each proc (cdr items))))
#+END_SRC
Let's test it:
#+BEGIN_SRC scheme
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
#+END_SRC
Yeah works well.
*** Hierarchical Structures
Let's implement the ~count-leaves~. It should behave like follows:
#+BEGIN_SRC scheme
(define x (cons (list 1 2) (list 3 4)))
(length x)                              ;3
(count-leaves x)                        ;4
(list x x)                              ;(((1 2) 3 4) ((1 2) 3 4))
(length (list x x))                     ;2
(count-leaves (list x x))               ;8
#+END_SRC
The implementation of ~count-leaves~ is analogous to ~length~:
- ~count-leaves~ of the empty list is 0.


But in the reduction step, we should take a count the ~car~ part:
- ~count-leaves~ of tree ~x~ is ~count-leaves~ of the ~car~ of ~x~ plus
  ~count-leaves~ of the ~cdr~ of ~x~.


After repeatedly apply the reduction step, we reach the another base case:
- ~count-leaves~ of a leaf is 1.


And we can test whether it is leaf by using the primitive predicate ~pair?~ we
test whether it is pair or not.

Then we can complete the procedure:
#+BEGIN_SRC scheme
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
#+END_SRC
**** Exercise 2.24
I've drawn assigned task in Digital Papper.
**** Exercise 2.25
1. ~(cadaddr (list 1 3 (list 5 7) 9))~ results to 7.
   The notation ~(cadaddr x)~ is abbreviation for ~(car (cdr (car (cdr (cdr x)))))~.
   Let we use this notation from this point for the space.
2. ~(caar (list (list 7)))~.
3. ~(cadadadadadadr x)~, where ~x~ is ~(1 (2 (3 (4 (5 (6 7))))))~.


**** Exercise 2.26
1. ~(append x y)~ would result to ~(1 2 3 4 5 6)~.
2. ~(cons x y)~ would result to ~((1 2 3) 4 5 6)~.
3. ~(list x y)~ would result to ~((1 2 3) (4 5 6))~.


We can verify those by evaluating:
#+BEGIN_SRC scheme
(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y)
(cons x y)
(list x y)
#+END_SRC

Yeah the results are same as above.
**** Exercise 2.27
We should implement, so called, ~deep-reverse~. It behaves as follows:
#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4))) ;((1 2) (3 4))
(reverse x)                             ;((3 4) (1 2))
(deep-reverse x)                        ;((4 3) (2 1))
#+END_SRC

It is obvious that we should use, so called, tree recursion for it. Or wishful
thinking so to say.

Let's start with reduction step:
- We assume that subtrees are /deep reversed/. Then we can complete the whole
  procedure:
  #+BEGIN_SRC scheme
(reverse (cons (deep-reverse (car x)) (deep-reverse (cdr x))))
  #+END_SRC
- Then the results are reduced to the subproblem whose argument is subtree of ~x~.


There are two base case with which the reduction step end up:
- By cdring down the list, we optain nil at the very end.
- Or, we could encounter the leaf, not the pair by caring the list.


As consequence, we can complete the procedure analogous to ~count-leaves~:
#+BEGIN_SRC scheme
(define (deep-reverse x)
  (cond ((null? x) x)
        ((not (pair? x)) x)
        (else (reverse (cons
                        (deep-reverse (car x))
                        (deep-reverse (cdr x)))))))
#+END_SRC
**** Exercise 2.28
Implement ~fringe~. Whose behavior are the followings:
#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4)))
(fringe x)                              ;(1 2 3 4)
(fringe (list x x))                     ;(1 2 3 4 1 2 3 4)
#+END_SRC

The strategy is similar with [[Exercise 2.27][above]]:
#+BEGIN_SRC scheme
(define (fringe x)
  (cond ((null? x) x)
        ((not (pair? x)) (list x))
        (else (append (fringe (car x))
                      (fringe (cdr x))))))
#+END_SRC

Note that we return the singleton list in the case of leaf; it is necessary at
the reduction step.
**** Exercise 2.29
Here we model the binary mobile, which consists of two branches--a left branch
and right branch. Each branch is a rod of a certain length, from which hangs
either a weight or another binary mobile.

We can construct it by using ~list~:
#+BEGIN_SRC scheme
(define (make-mobile left right)
  (list left right))
#+END_SRC

A branch is constructed from a ~length~, which must be a number, together with a
~structure~, which may be either a number--a simple weight-- or another mobile:
#+BEGIN_SRC scheme
(define (make-branch length structure)
  (list length structure))
#+END_SRC

***** a.
Then we can implement the selectors, namely ~left-branch~ and ~right-branch~:
#+BEGIN_SRC scheme
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cadr mobile))
#+END_SRC
And the branch' structure:
#+BEGIN_SRC scheme
(define (branch-structure branch)
  (cadr branch))
#+END_SRC

***** b.
The procedure that returns weight of mobile, ~total-weight~, is similar with
above tree recursion processes:[fn::We sense more and more replicative patterns
here]
- Reduction process:
  #+BEGIN_SRC scheme
(+ (total-weight (branch-structure (left-branch mobile)))
   (total-weight (branch-structure (right-branch mobile))))
  #+END_SRC
  which end up with
- Base case:
  #+BEGIN_SRC scheme
(if (not (mobile? x)) x)                ;a simple weight case
  #+END_SRC
  And the ~mobile?~ test whether it is mobile:
  #+BEGIN_SRC scheme
(define (mobile? x) (pair? x))
  #+END_SRC


And then we complete the procedure:
#+BEGIN_SRC scheme
(define (total-weight mobile)
  (if (not (mobile? mobile))
      mobile
      (+ (total-weight (branch-structure (left-branch mobile)))
         (total-weight (branch-structure (right-branch mobile))))))
#+END_SRC
***** c. Design the predicate that tests whether a binary mobile is balanced.
Here we also exploit the wishful thinking about the tree structure:
- Reduction process:
  #+BEGIN_SRC scheme
(let ((left (left-branch mobile))
      (right (right-branch mobile)))
  (let ((mobile-l (branch-structure left))
        (mobile-r (branch-structure right)))
    (if (and (balanced? mobile-l)
             (balanced? mobile-r))
        (= (* (branch-length left)
              (total-weight mobile-l))
           (+ (branch-length right)
              (total-weight mobile-r)))
        false)))
  #+END_SRC
  Here we used the ~branch-length~ whose definition is
  #+BEGIN_SRC scheme
(define (branch-length branch)
  (car branch))
  #+END_SRC
  Yeah, it's quite dirty; but straight forward. We can revise the if clause as
  follow:
  #+BEGIN_SRC scheme
(and (balanced? mobile-l)
     (balanced? mobile-r)
     (= (* (branch-length left)
              (total-weight mobile-l))
           (+ (branch-length right)
              (total-weight mobile-r))))
  #+END_SRC
  as the consequence and alternative of if clause are boolean. This end up with
- Base case (a simple weight):
  #+BEGIN_SRC scheme
(if (not (mobile? x)) true)
  #+END_SRC
  which can be reduced to
  #+BEGIN_SRC scheme
(not (mobile? x))
  #+END_SRC


The complete code:
#+BEGIN_SRC scheme
(define (blanced? mobile)
  (and (not (mobile? mobile))
       (let ((left (left-branch mobile))
             (right (right-branch mobile)))
         (let ((mobile-l (branch-structure left))
               (mobile-r (branch-structure right)))
           (and (balanced? mobile-l)
                (balanced? mobile-r)
                (= (* (branch-length left)
                      (total-weight mobile-l))
                   (+ (branch-length right)
                      (total-weight mobile-r))))))))
#+END_SRC
***** d.
Suppose we change the representation of mobiles so that the constructors are
#+BEGIN_SRC scheme
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
#+END_SRC

Then we should change only the followings:
#+BEGIN_SRC scheme
(define (right-branch mobile)
  (cdr mobile))
(define (branch-structure branch)
  (cdr branch))
#+END_SRC
Boom! That's it. The power of abstract barrier!

**** Mapping over trees
We can define the ~scale-tree~ procedure analogous to ~scale-list~ using ~map~:
#+BEGIN_SRC scheme
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
#+END_SRC
**** Exercise 2.30
Define a procedure ~square-tree~ analogous to the ~square-list~ procedure of [[Exercise
2.21][exercise 2.21]].
That is, ~square-tree~ should behave as follows:
#+BEGIN_SRC scheme
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))                     ;(1 (4 (9 16) 25) (36 49))
#+END_SRC

***** Define ~square-tree~ without higher-order procedures
We can do this by analogy to ~scale-tree~:
#+BEGIN_SRC scheme
(define (square-tree tree)
  (cond ((null? tree) tree)
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree (car tree))
                    (square-tree (cdr tree))))))
#+END_SRC
***** Define ~square-tree~ using ~map~
#+BEGIN_SRC scheme
(define (square-tree tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree sub-tree)
             (square sub-tree)))
       tree))
#+END_SRC

**** Exercise 2.31
Define ~tree-map~ that behave as follows:
#+BEGIN_SRC scheme
(define (square-tree tree) (tree-map square tree))
#+END_SRC
It is easy:
#+BEGIN_SRC scheme
(define (tree-map proc tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (tree-map proc sub-tree)
             (proc sub-tree)))
       tree))
#+END_SRC
**** Exercise 2.32
We can get the whole subsets of ~s~ by reducing that:
- The subsets that include the element ~a~ of ~s~ plus
- The subsets that do not include the element ~a~.


Then we can complete the code:
#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list s)
      (let ((rest (subsets (cdr s))))
        (append rest
                (map (lambda (subset)
                       (cons (car s) subset))
                     rest)))))
#+END_SRC
*** Sequences as Conventional Interfaces
**** Sequence Operations
The main procedures that complete the signal processing interfaces are
followings:
- [[Mapping over lists][map]]
- [[Exercise 2.20][filter]]
- accumulate
  #+BEGIN_SRC scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
  #+END_SRC


All that remains to implement signal-flow diagrams is to enumerate the sequence
of elements to be processed. That is, to make signals which processed afterward.
- make initial signal; produces list.
  To enumerate the interval of integers, we can code
  #+BEGIN_SRC scheme
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
  #+END_SRC

  For tree, we can transform the tree as follows[fn::In fact, it is same
  procedure as [[Exercise 2.28][fringe]].]:
  #+BEGIN_SRC scheme
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
  #+END_SRC

**** Exercise 2.33
By comparing the ~map~ procedure and ~accumulate~ we can define the ~map~ as follows:
#+BEGIN_SRC scheme
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y))
              nil
              sequence))
#+END_SRC
And the others also can be implemented analogous to above:
#+BEGIN_SRC scheme
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (1+ y)) 0 sequence))
#+END_SRC
**** Exercise 2.34
Horner's rule.
#+BEGIN_SRC scheme
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              coefficient-sequence))
;; test
(horner-eval 2 (list 1 3 0 5 0 1))      ;79
#+END_SRC
Actually I've used this in the exercise in [[github:HyunggyuJang/Isabelle][Isabelle]].
**** Exercise 2.35
We can redefine ~count-leaves~ from [[Hierarchical Structures][this]] using ~accumulate~, which means that we
can formulate ~count-leaves~ as signal processing interface.

At first, let's try out without lingering over it; just compare those structure
and code it appropriately:
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate (lambda (x y)
                (if (not (pair? x))
                    (1+ y)
                    (+ (count-leaves x)
                       y)))
              0
              t))
#+END_SRC

It works; but it is not the one the text wanted: Text want we process the ~t~
with ~map~ before feed it to ~accumulate~:
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate <??> <??> (map <??> <??>)))
#+END_SRC
And more, it is no more clear than we did previously; just cramming all of the
messy things from ~count-leaves~ into the ~op~ of ~accumulate~.

We can do better than that. Let's follow text's intention; but how we get the
~count-leaves~ coded? As we trying to formulate this as signal processing
interface, first we need to processing the input ~t~ as 'signal'--list--so that
we can use conventional interfaces for this.

Then the remain is simple:
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate + 0 (map (lambda (x) 1)
                       (enumerate-tree t))))
#+END_SRC

Yeah, who even said that we shouldn't use ~enumerate-tree~ here? I think the
intention of this exercise was in that capturing recursive process in signal
processing framework. It looks silly when we map all the list items into number
~1~ like this; but it will compensate someday I think. Whatever, let's move on.

**** Exercise 2.36
The generalized version of ~accumulate~, ~accumulate-n~ deal with sequence of
sequences that all have same number of elements. The behavior is as follows:
#+BEGIN_SRC scheme
(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
;(22 26 30)
#+END_SRC

Here we use wishful thinking as usual:
- Reduction process:
  Let we assume that we were given the results of
  ~accumulate-n~ with sequence of sequences except the first element of each.
  Then we can complete the process by ~accumulate~ the first element of each and
  then consing it with the given:
  #+BEGIN_SRC scheme
(cons (accumulate op init (map car seqs))
      (accumulate-n op init (map cdr seqs)))
  #+END_SRC

  After repeatedly applying this process we get
- Base case:
  we end up with sequence of ~nil~:
  #+BEGIN_SRC scheme
(if (null? (car seqs))
    (car seqs))
  #+END_SRC
  This is the only base case because ~nil~ is not the sequence of sequences.

Then the complete code can be synthesized as usual:
#+BEGIN_SRC scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      (car seqs)
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))
#+END_SRC

**** Exercise 2.37
From now on, I'll pace up because I've already designed the strucutre of these
exercises on my note.
#+BEGIN_SRC scheme
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map (lambda (m_i) (dot-product m_i u))
       m))
(define (transpose mat)
  (accumulate-n cons '() mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (m_i)
           (matrix-*-vector cols m_i))
         m)))
#+END_SRC

**** Exercise 2.38
To get equal value from both ~fold-right~ and ~fold-left~, ~op~ should satisfy
the associative law of algebra and also commutative law with repect to ~init~.

**** Exercise 2.39
#+BEGIN_SRC scheme
(define (snoc x y)
  (append y (list x)))
(define (reverse sequence)
  (fold-right (lambda (x y)
                (snoc x y))
              '()
              sequence))
(define (reverse sequence)
  (fold-left (lambda (x y)
               (cons y x))
             '()
             sequence))
#+END_SRC

**** Exercise 2.40
#+BEGIN_SRC scheme
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))
(define (unique-pairs n)
  (flatmap
   (lambda (i)
     (map (lambda (j) (list i j))
          (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 n)))
#+END_SRC

**** Exercise 2.41
#+BEGIN_SRC scheme
(define (triple-sum-to-s n s)
  (filter (lambda (triple)
            (= s (fold-right + 0 triple)))
          (flatmap (lambda (k)
                     (map (lambda (p)
                            (snoc k p))
                          (unique-pairs (- k 1))))
                   (enumerate-interval 1 n))))
#+END_SRC

**** Exercise 2.42
#+BEGIN_SRC scheme
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval i board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(define empty-board '())

(define (adjoin-position new-row k rest-of-queens)
  (cons new-row rest-of-queens))

(define (safe? k positions)
  (define (equal-not-to? nr rest)
    (or (null? rest)
        (and (not (= nr (car rest)))
             (equal-not-to? nr (cdr rest)))))
  (define (pm-i-not-equal-to? nr i rest)
    (or (null? rest)
        (and (not (or (= (+ nr i) (car rest))
                      (= (- nr i) (car rest))))
             (pm-i-not-equal-to? nr (1+ i) (cdr rest)))))
  (let ((new-row (car positions))
        (rest-queens (cdr positions)))
    (and (equal-not-to? new-row rest-queens) ;provided that positions not empty
         (pm-i-not-equal-to? new-row 1 rest-queens))))
#+END_SRC
Note that here we didn't use the parameter ~k~ none of helper procedures--
~adjoin-position~ and ~safe?~ -- because we don't need to; I've thought it is
natural to think /the first k-1 columns/ as counted from the rightmost.
#+RESULTS:
: #<unspecified>

**** Exercise 2.43
Because by exchange the order of ~flatmap~ and ~map~ in the procedure
~queen-cols~ now the procedure call ~(queen-cols (- k 1))~ become evaluated
duplicately every ~new-row~ of ~(enumerate-interval 1 board-size)~, i.e
~board-size~ times.

We can reason the asymptotic time complexity of both cases:
- The original one is \theta(n^{3})
- The troubled one is \theta(n^{n})


Here we used the n as ~board-size~. As consequence, when ~board-size~ is 8 and
let the time taken by original one /T/, then the Louis's one takes approximately
more than 8^{5} \times /T/.
*** Example: A Picture Language
**** The picture language
- Primitives: /painter/
- Means of combination: ~beside~, ~below~
  - Create new painter from existing one: ~filp-vert~, ~flip-horiz~
- Means of abstraction: ~define~ in scheme language; As means of combination are
  all procedure in scheme, we can abstract them like any other procedure in scheme.


The results of combination of painter are also painters; by this closure
property with scheme's picture language inherit closure property in complete
sense.

I've tried to configure the picture language framework in mit-scheme; but to no vail.
I've searched the github of mit-scheme, which has the directory named "6001"
that contains ~6001.pkg~; to use that package, I've read the relevant content of
MIT scheme's user manual, also to no use; I've complied it with ~sf~ method in
edwin editor--this package depends on the edwin package, so I have no choice to
use emacs in this case--, and I found myself it is useless I need to put more
time in configuration than solving the exercises. The easiest alternative was to
use racket's sicp package, which I knew but have stuck with using *pure*
mit-scheme as I felt it is more canonical. Well, whatever, I've given up with
that; let's go with racket.
**** Exercise 2.44
We can define ~up-split~ analogous to ~right-split~.
#+BEGIN_SRC scheme
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))
#+END_SRC
**** Exercise 2.45
We can easily abstract this by higher order function:
#+BEGIN_SRC scheme
(define (split tran1 tran2)
  (lambda (painter n)
    (if (= n 0)
        painter
        (let ((smaller ((split tran1 tran2) painter (- n 1))))
          (tran1 painter (tran2 smaller smaller))))))
#+END_SRC
**** Exercise 2.46
Note that I implement ~sub-vect~ using the ~scale-vect~ and ~add-vect~; it is
subtle matter but I thought this definition is more canonical in algebraical
sense:
#+BEGIN_SRC scheme
(define (make-vect x y)
  (cons x y))

(define (xcor-vect v)
  (car v))

(define (ycor-vect v)
  (cdr v))

(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1)
                (xcor-vect v2))
             (+ (ycor-vect v1)
                (ycor-vect v2))))
(define (scale-vect s v)
  (make-vect (* (xcor-vect v) s)
             (* (ycor-vect v) s)))
(define (sub-vect v1 v2)
  (add-vect v1 (scale-vect -1 v2)))
#+END_SRC
**** Exercise 2.47
For first representation, we can implement selectors accordingly:
#+BEGIN_SRC scheme
(define (origin-frame f)
  (car f))
(define (edge1-frame f)
  (cadr f))
(define (edge2-frame f)
  (caddr f))
#+END_SRC
For the latter, similarly:
#+BEGIN_SRC scheme
(define (origin-frame f)
  (car f))
(define (edge1-frame f)
  (cadr f))
(define (edge2-frame f)
  (cddr f))
#+END_SRC
**** Exercise 2.48
Didn't we solved this in exercise 2.2? In there, we made segment using points
not vector but the representation axiom is same in both; we can reuse that
definiiton:
#+BEGIN_SRC scheme
;; Constructor make-segment
(define (make-segment start-pt end-pt)
  (cons start-pt end-pt))
;; Selector start-segment
(define (start-segment segment)
  (car segment))
;; Selector end-segment
(define (end-segment segment)
  (cdr segment))
#+END_SRC
**** Exercise 2.49
***** a.
The painter that draws the outline of the designated frame.
#+BEGIN_SRC scheme
(define outliner
  (let ((o (make-vect 0 0))
        (br (make-vect 1 0))
        (tr (make-vect 1 1))
        (tl (make-vect 0 1)))
    (segments->painter (list (make-segment o br)
                             (make-segment br tr)
                             (make-segment tr tl)
                             (make-segment tl o)))))
#+END_SRC
***** b.
The painter that draws an "X" by connecting opposite corners of the frame.
#+BEGIN_SRC scheme
(define x-liner
  (let ((o (make-vect 0 0))
        (br (make-vect 1 0))
        (tr (make-vect 1 1))
        (tl (make-vect 0 1)))
    (segments->painter (list (make-segment o tr)
                             (make-segment br tl)))))
#+END_SRC
***** c.
The painter that draws a diamond shape by connecting the midpoints of the sides
of the frame.
#+BEGIN_SRC scheme
(define dia-liner
  (let ((o (make-vect 0 0))
        (br (make-vect 1 0))
        (tr (make-vect 1 1))
        (tl (make-vect 0 1)))
    (let ((left (scale-vect 0.5 tl))
          (bottom (scale-vect 0.5 br)))
      (let ((right (add-vect br left))
            (top (add-vect tl bottom)))
        (segments->painter (list (make-segment left top)
                                 (make-segment top right)
                                 (make-segment right bottom)
                                 (make-segment bottom left)))))))
#+END_SRC
***** DONE d.
The wave painter.
#+BEGIN_SRC scheme
(define wave
  (let ((lhl (make-vect 0 0.65))         ;left hand
        (lhh (make-vect 0 0.8))
        (rhh (make-vect 1 0.35))
        (rhl (make-vect 1 0.2))
        (lal (make-vect 0.24 0.45))     ;left arm joint
        (lah (make-vect 0.24 0.6))
        (lsl (make-vect 0.4 0.6))       ;left shoulder
        (lsh (make-vect 0.4 0.65))
        (ln (make-vect 0.45 0.65))
        (rn (make-vect 0.55 0.65))
        (rs (make-vect 0.6 0.65))
        (lfa (make-vect 0.43 0.8))
        (rfa (make-vect 0.57 0.8))
        (lh (make-vect 0.45 1))
        (rh (make-vect 0.55 1))
        (lv (make-vect 0.43 0.55))
        (rv (make-vect 0.57 0.55))
        (lfo (make-vect 0.3 0))
        (rfo (make-vect 0.7 0))
        (lfo1 (make-vect 0.4 0))
        (rfo1 (make-vect 0.6 0))
        (cl (make-vect 0.5 0.3)))
    (segments->painter (list (make-segment lhh lah)
                             (make-segment lah lsh)
                             (make-segment lsh ln)
                             (make-segment ln lfa)
                             (make-segment lfa lh) ;from left hand high to left head
                             (make-segment lhl lal)
                             (make-segment lal lsl)
                             (make-segment lsl lv)
                             (make-segment lv lfo) ;from left hand low to left foot
                             (make-segment lfo1 cl)
                             (make-segment cl rfo1) ;from left foot1 to right foot1
                             (make-segment rfo rv)
                             (make-segment rv rhl) ;from left foot to right hand low
                             (make-segment rhh rs)
                             (make-segment rs rn)
                             (make-segment rn rfa)
                             (make-segment rfa rh)))        ;from left hand high left head
    ))
#+END_SRC
**** Transforming and combining painters
As we noted in the introductive session of this section, the combinators created
new painter element using the existing ones. Now we implement the combinators
using more general procedure, ~transform-painter~:
#+BEGIN_SRC scheme
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter
         (make-frame new-origin
                     (sub-vect (m corner1) new-origin)
                     (sub-vect (m corner2) new-origin)))))))
#+END_SRC
Here we exploit the fact that ~painter~ is actually just procedure, which takes
~frame~ for its arguemnt, so to transform the ~painter~ all we need to do is
transform the ~frame~ appropriately. Also note that we could have chosen ~edge1~
and ~edge2~ for transformation instead ~corner1~ and ~corner2~; we just found
from the use case it is more convenient.

Then we can implement a lot of combinators:
- ~filp-vert~
  #+BEGIN_SRC scheme
(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
  #+END_SRC
- We can also shrink the frame:
  #+BEGIN_SRC scheme
(define (shrink-to-upper-right painter)
  (transform-painter painter
                     (make-vect 0.5 0.5)
                     (make-vect 1.0 0.5)
                     (make-vect 0.5 1.0)))
  #+END_SRC
- Also we can rotate the frame:
  #+BEGIN_SRC scheme
(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
  #+END_SRC
- We can combine two or more paitners
  #+BEGIN_SRC scheme
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              split-point
                              (make-point 0.0 1.0)))
          (paint-right
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.0)
                              (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
  #+END_SRC
**** Exercise 2.50
We can define ~flip-horiz~ analogous to ~flip-vert~:
#+BEGIN_SRC scheme
(define (flip-horiz painter)
  (transform-painter painter
                     (make-vect 1.0 0.0) ;new origin
                     (make-vect 0.0 0.0) ;new end of edge1
                     (make-vect 0.0 1.0))) ;new end of edge2
#+END_SRC
We can define rotating frames in either way, using ~rotate90~ or directly:
- Using ~rotate90~:
  #+BEGIN_SRC scheme
(define (rotate180 painter)
  (rotate90 (rotate90 painter)))
(define (rotate270 painter)
  (rotate90 (rotate180 painter)))
  #+END_SRC
- define directly:
  #+BEGIN_SRC scheme
(define (rotate180 painter)
  (transform-painter painter
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 0.0)))
(define (rotate270 painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
  #+END_SRC
**** Exercise 2.51
- Define ~below~ analogous to ~beside~:
  #+BEGIN_SRC scheme
(define (below painter1 painter2)
  (let ((split-point (make-vect 0.0 0.5)))
    (let ((paint-bottom
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              (make-point 1.0 0.0)
                              split-point))
          (paint-top
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.5)
                              (make-vect 0.0 1.0))))
      (lambda (frame)
        (paint-bottom frame)
        (paint-top frame)))))
  #+END_SRC
- Using ~beside~:
  #+BEGIN_SRC scheme
(define (below painter1 painter2)
  (rotate270 (beside (rotate90 painter2)
                     (rotate90 painter1))))
  #+END_SRC
**** Exercise 2.52
***** a.
Let's add some smile to our ~wave~:
#+BEGIN_SRC scheme
(define wave
  (let ((lhl (make-vect 0 0.65))         ;left hand
        (lhh (make-vect 0 0.8))
        (rhh (make-vect 1 0.35))
        (rhl (make-vect 1 0.2))
        (lal (make-vect 0.24 0.45))     ;left arm joint
        (lah (make-vect 0.24 0.6))
        (lsl (make-vect 0.4 0.6))       ;left shoulder
        (lsh (make-vect 0.4 0.65))
        (ln (make-vect 0.45 0.65))
        (rn (make-vect 0.55 0.65))
        (lm (make-vect 0.48 0.77))      ;smile~
        (rm (make-vect 0.52 0.77))
        (cm (make-vect 0.5 0.75))
        (rs (make-vect 0.6 0.65))
        (lfa (make-vect 0.43 0.8))
        (rfa (make-vect 0.57 0.8))
        (lh (make-vect 0.45 1))
        (rh (make-vect 0.55 1))
        (lv (make-vect 0.43 0.55))
        (rv (make-vect 0.57 0.55))
        (lfo (make-vect 0.3 0))
        (rfo (make-vect 0.7 0))
        (lfo1 (make-vect 0.4 0))
        (rfo1 (make-vect 0.6 0))
        (cl (make-vect 0.5 0.3)))
    (segments->painter (list (make-segment lhh lah)
                             (make-segment lah lsh)
                             (make-segment lsh ln)
                             (make-segment ln lfa)
                             (make-segment lfa lh) ;from left hand high to left head
                             (make-segment lhl lal)
                             (make-segment lal lsl)
                             (make-segment lsl lv)
                             (make-segment lv lfo) ;from left hand low to left foot
                             (make-segment lfo1 cl)
                             (make-segment cl rfo1) ;from left foot1 to right foot1
                             (make-segment rfo rv)
                             (make-segment rv rhl) ;from left foot to right hand low
                             (make-segment rhh rs)
                             (make-segment rs rn)
                             (make-segment rn rfa)
                             (make-segment rfa rh) ;from left hand high left head
                             (make-segment lm cm)
                             (make-segment cm rm))) ;smile~
    ))
#+END_SRC
***** b.
Change ~corner-split~ using only one copy of the ~up-split~ and ~right-split~:
#+BEGIN_SRC scheme
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left up)
              (bottom-right right))
          (beside (below painter top-left)
                  (below bottom-right (corner-split painter (- n 1))))))))
#+END_SRC
***** c.
Modify ~square-limit~ so that the big Mr. Rogers look outward from each corner
of the square:
#+BEGIN_SRC scheme
(define (squre-limit painter n)
  (let ((combine4 (square-of-four flip-vert
                                  rotate180
                                  identity
                                  flip-horiz)))))
#+END_SRC
#+CAPTION: Finale
[image]
