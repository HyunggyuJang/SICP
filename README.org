#+TITLE: Computing with Register Machines
So far we have learned the meanings of procedures using a succession of models
of evaluation: The substitution model, the environment model, the metacircular
evaluator. But none of these evaluation model did not dispel how the evaluation
of subexpression manages to return a value to the expression that uses this
value, nor does the evaluator explain how some recursive procedures generate
iterative processes.

In this chapter we are going to learn so called "linking" process, which link
the callee and caller with the returning value.

Further more, as it is the last chapter of this text book, this chapter
organized as the canonical structure in that we've learned so far: By wishful
thinking,
1. Design or specify what we want to implement or the behavior that we want from
   the application -- section 5.1;
2. implement the high level procedures using the low level procedure's
   specifications, by wishful thinking -- we haven't yet implemented the low
   level procedure but we can specify what we want from the perspective of high
   level procedure implementor --, section 5.2;
3. then we implement the very low procedures using only the primitives --
   section 5.3;
4. a variation or application of what we implemented -- section 5.4;
5. deep dive what we have assumed as primitive or "as given" -- section 5.5;


So by learning through this chapter, we can learn not just the contents it
contains but also the general strategy to embody the ideas into the real world
program. This general strategy would be applied to any of design process one
would encounter with when try to create something that isn't yet in the world
that solves the given specific kind of problem.

We'd better to be engraved in our mind the general strategy through out this chapter.

* Designing Register Machines
*** Exercise 5.1
I've drawn this with my digital paper. But you should be careful that our switch
is not just simple switch, which we probably used in electrical experiment in
middle or like that age, but a switch that has memorizing feature so that one
can clobber the contents of given register.

So we can use the result signal or value of operator -- multiply, addition, etc.
-- to clobber the operand register directly without intervening the
intermediate register.

It is not deducible from the contents before this exercise, that is, from the
=gcd= machine; but we can do from the later example machines. It is quite unfair
they did not specify what feature the switches possesses exactly -- only in a
context that even not appear until this exercise.

** A Language for Describing Register Machines
So far our language for the design of machines was diagrams -- one for data
paths and one for controller; now through this chapter we extends our tools for
designing register machines to more powerful programming like language that we
can simulate easily by restricting the freedom of design -- only the finite
number of instructions can be used in the designing.

*** Exercise 5.2
#+BEGIN_SRC scheme
(controller
    (assign p (const 1))
    (assign c (const 1))
 test-c
    (test (op >) (reg c) (reg n))
    (branch (label fact-done))
    (assign p (op *) (reg p) (reg c))
    (assign c (op +) (reg c) (const 1))
    (goto (label test-c))
 fact-done)
#+END_SRC
** Abstraction in Machine Design
*** Exercise 5.3
The first version that assume the internal definitions are available as
primitive procedure in the =sqrt-iter=.
#+BEGIN_SRC scheme
(controller
    (assign g (const 1.0))
 test-g
    (test (op g-e?) (reg g))
    (branch (label sqrt-done))
    (assign g (op imp) (reg g))
    (goto (label test-g))
 sqrt-done)
#+END_SRC

Note that we haven't even mentioned the =x= in above controller description.

Now we are going to implement the second task -- unwind the internal definitions
into the primitive ones.

#+BEGIN_SRC scheme
;;; Version 2
;;; middle level procedures

;;;; good-enough?
(assign s-q (op sq) (reg g))
(assign d (op -) (reg s-q) (reg x))
(assign ad (op abs) (reg d))
(test (op <) (reg ad) (const 0.001))

;;;; improve
(assign x/g (op /) (reg x) (reg g))
(assign imped (op avg) (reg g) (reg x/g))

;;; low level procedures
;;;; square
(assign cp (reg g))
(assign squared (op *) (reg cp) (reg g))

;;;; abs
(test (op <) (reg d) (const 0))
(branch (label abs-fetch))
(assign absed (op neg) (reg d))
(goto (label abs-done))
abs-fetch
(assign absed (reg d))
abs-done

;;;; average
(assign s (op +) (reg x) (reg g))
(assing aved (op /) (reg s) (const 2))

;;; And linking all together
(controller
    (assign g (const 1.0))
 test-g
;;; good-enough? {
    ;; sq {
    (assign d (reg g))
    (assign t (op *) (reg d) (reg g))
    ;; }
    (assign d (op -) (reg t) (reg x))
    ;; abs {
    (test (op <) (reg d) (const 0))
    (branch (label abs-fetch))
    (assign t (op neg) (reg d))
    (goto (label abs-done))
 abs-fetch
    (assign t (reg d))
 abs-done
    ;; }
    (test (op <) (reg t) (const 0.001))
;;; }
    (branch (label sqrt-done))
;;; improve {
    (assign d (op /) (reg x) (reg g))
    ;; average {
    (assign t (op +) (reg x) (reg g))
    (assing g (op /) (reg t) (const 2))
    ;; }
;;; }
    (goto (label test-g))
 sqrt-done)
#+END_SRC

For the data paths diagrams, I've drawn in digital paper.
** Subroutines
** Using a Stack to Implement Recursion
*** Exercise 5.4
**** a.
#+BEGIN_SRC scheme
(controller
    (assign continue (label expt-done))
 expt-loop
    (test (op =) (reg n) (const 0))
    (branch (label base-case))
 ;; setup to compute b^{n-1}
    (save continue)
    (assign continue (label after-expt-recur))
    (assign n (op -) (reg n) (const 1))
    (goto (label expt-loop))
 after-expt-recur
    (restore continue)
    (assign val (op *) (reg b) (reg val))
    (goto (reg continue))
 base-case
    (assign val (const 1))
    (goto (reg continue))
 expt-done)
#+END_SRC
**** b.
#+BEGIN_SRC scheme
(controller
    (assign c (reg n))
    (assign p (const 1))
 expt-loop
    (test (op =) (reg c) (const 0))
    (branch (label expt-done))
    (assign c (op -) (reg c) (const 1))
    (assign p (op *) (reg b) (reg p))
    (goto (label expt-loop))
 expt-done)
#+END_SRC
*** Exercise 5.5
I've done this in our text book (with digital paper).
*** Exercise 5.6
We can remove the pair before and after
#+BEGIN_SRC scheme
;; set up to compute Fib(n - 2)
(assign n (op -) (reg n) (const 2))
#+END_SRC
** Instruction Summary
In this section, the specifications we need to implement are summarized.
* A Register-Machine Simulator
Now we implement or learn what they implemented step by step for the
specifications of preceding design. Here they implement through by using wishful
thinking as we outlined in the beginning of this chapter.
*** Exercise 5.7
#+BEGIN_SRC scheme
(define expt-recur-machine
  (make-machine
   '(n b val)
   `((= ,=) (- ,-) (* ,*))
   '(
        (assign continue (label expt-done))
     expt-loop
        (test (op =) (reg n) (const 0))
        (branch (label base-case))
        ;; setup to compute b^{n-1}
        (save continue)
        (assign continue (label after-expt-recur))
        (assign n (op -) (reg n) (const 1))
        (goto (label expt-loop))
     after-expt-recur
        (restore continue)
        (assign val (op *) (reg b) (reg val))
        (goto (reg continue))
     base-case
        (assign val (const 1))
        (goto (reg continue))
     expt-done)))
#+END_SRC

And
#+BEGIN_SRC scheme
(define expt-iter-machine
  (make-machine
   '(n b c p)
   `((= ,=) (- ,-) (* ,*))
   '(
        (assign c (reg n))
        (assign p (const 1))
    expt-loop
        (test (op =) (reg c) (const 0))
        (branch (label expt-done))
        (assign c (op -) (reg c) (const 1))
        (assign p (op *) (reg b) (reg p))
        (goto (label expt-loop))
    expt-done)))
#+END_SRC

Then run:
#+BEGIN_SRC scheme
(set-register-contents! expt-recur-machine 'b 2)

;Value: done

(set-register-contents! expt-recur-machine 'n 5)

;Value: done

(start expt-recur-machine)

;Value: done

(get-register-contents expt-recur-machine 'val)

;Value: 32
#+END_SRC

And
#+BEGIN_SRC scheme
;; Run expt-iter-machine
(set-register-contents! expt-iter-machine 'b 2)
(set-register-contents! expt-iter-machine 'n 5)
(start expt-iter-machine)

(get-register-contents expt-iter-machine 'p)
;Value: 32
#+END_SRC

** The Machine Model
This subsection implements the middle-high level procedures.
** The Assembler
The assembler is like the analyzer in section 4.1.7. It transforms the text
instructions (expressions) into execution procedures. The idea behind this
process is much of the works the simulator would do otherwise can be processed
without knowing the actual contents of machine registers. For example, they
replaced the references to registers by pointers to the register objects -- as
we did in the last exercise in the [[org:../MEGAsync/MIT Challenge/6.001/Chapter4.org][previous chapter]], and replace references to
labels by pointers to the place in the instruction sequence that the label
designates -- like the variable bound to pair actually bound to pointer to that
pair.

*** Exercise 5.8
Since we construct the label entries from the very end to the start point (using
continuation), when we =lookup-label= with label =here=, the first label =here=
in the controller text returned by the contract of =assoc=.

So =a= would be 3 when it reaches =there=.

To modify this behavior as specified in the statement, we need to construct ADT
barrier for adding the newly constructed label entry to the given labels.

Specifically it should =lookup-label= to check whether the given =label-name= is
already in the labels; if it is, signal error.

#+BEGIN_SRC scheme
(define (add-label-entry entry labels)
  (if (get-label labels (label-name entry))
      (error "Given label name already exists in the labels" (list entry labels))
      (cons entry labels)))

(define (label-name entry) (car entry))

(define (get-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        false)))
#+END_SRC

Then
#+BEGIN_SRC scheme
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts (add-label-entry
                               (make-label-entry next-inst
                                                 insts)
                               labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
#+END_SRC

And we can test this feature:
#+BEGIN_SRC scheme
(define test-5.8-machine
  (make-machine
   '(a)
   '()
   '(start
     (goto (label here))
     here
     (assign a (const 3))
     (goto (label there))
     here
     (assign a (const 4))
     (goto (label there))
     there)
   ))

;Given label name already exists in the labels ((here ((assign a (const 3))) ((goto (label there))) . #0=(((assign a (const 4))) ((goto (label there))))) ((here . #0#) (there)))
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC
** Generating Execution Procedures for Instructions
=Assemble= procedure uses =make-execution-procedure=. This is has many analogy
with =analyze= procedure in section 4.1.7; these uses dispatch on data type, and
produce execution procedure that is analyzed using informations other than
actual contents.

*** Exercise 5.9
We can use either of following strategies:
- Define the procedure analogous to =make-primitive-exp=; or
- filter the label expression before calling the =make-primitive-exp=.


Here we are going to use the latter since it elicit what we meant more
specifically than the former.

#+BEGIN_SRC scheme
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (if (label-exp? e)
                    (error "Operation can not operate on label expression" e))
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
#+END_SRC
*** Exercise 5.10
We can do that other than the instructions should have type notation in its
=car= part since =make-execution-procedure= depends on this fact directly. For the
rest we are good to modify whatever we like since there are no restriction at all.

It means we should fence around dispatch on data type in the =make-execution-procedure=.

But for now let we stick what granted for us.

What we requested is not to create new syntax that has new semantic per se but
change one of the existing syntax to new one. We could change the register
syntax as post-fix notation like =(n reg)= by modifying as
#+BEGIN_SRC scheme
(define (register-exp? exp)
  (and (pair? exp)
       (pair? (cdr exp))
       (eq? (cadr exp) 'reg)))

(define (register-exp-reg exp) (car exp))
#+END_SRC

Then it works as expected:
#+BEGIN_SRC scheme
(define expt-iter-machine
  (make-machine
   '(n b c p)
   `((= ,=) (- ,-) (* ,*))
   '(
     (assign c (n reg))
     (assign p (const 1))
     expt-loop
     (test (op =) (c reg) (const 0))
     (branch (label expt-done))
     (assign c (op -) (c reg) (const 1))
     (assign p (op *) (b reg) (p reg))
     (goto (label expt-loop))
     expt-done)))

;Value: expt-iter-machine

(set-register-contents! expt-iter-machine 'b 2)

;Value: done

(set-register-contents! expt-iter-machine 'n 5)

;Value: done

(start expt-iter-machine)

;Value: done

(get-register-contents expt-iter-machine 'p)

;Value: 32
#+END_SRC
*** Exercise 5.11
First let us code the test machine:
#+BEGIN_SRC scheme
(define test-5.11-machine
  (make-machine
   '(x y)
   '()
   '((save y)
     (save x)
     (restore y))))
#+END_SRC
**** a.
We can reduce the following two lines
#+BEGIN_SRC scheme
,*** in Fibonacci controller
    (assign n (reg val))                ;n now contains Fib(n - 2)
    (restore val)                       ;val now contains Fib(n - 1)
#+END_SRC
into one line:
#+BEGIN_SRC scheme
    (restore n)                         ;n now contains Fib(n - 1)
#+END_SRC
**** b.
Now =save= has to construct new data structure that associate value with the
name of register. For now let's just use pair for to do this work:
#+BEGIN_SRC scheme
(define (make-save inst machine stack pc)
  (let ((reg-name (stack-inst-reg-name inst)))
    (let ((reg (get-register machine reg-name)))
      (lambda ()
        (push stack (cons reg-name (get-contents reg)))
        (advance-pc pc)))))

(define (make-restore inst machine stack pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine reg-name)))
    (lambda ()
      (let* ((assoc-entry (pop stack))
             (assoc-name (car assoc-entry)))
        (if (eq? assoc-name reg-name)
            (set-contents! reg (pop stack))
            (error "Tried to restore value from register which is not one saved -- MAKE-RESTORE"))
        (advance-pc pc)))))
#+END_SRC

And test:
#+BEGIN_SRC scheme
(set-register-contents! test-5.11-machine 'y 6)
(set-register-contents! test-5.11-machine 'x 3)
(start test-5.11-machine)

;Tried to restore value from register which is not one saved -- MAKE-RESTORE
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

**** c.
Whenever =allocate-register= to machine it should also add new stack to the
stacks -- =Alist<reg-name x stack>=; then =save= & =restore= first lookup the
specific stack associated with given register and do usual stack manipulations.

To initialize, it sends =initialize= messages each of stack in stacks.

#+BEGIN_SRC scheme
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stacks '())
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stacks
                       (lambda () (for-each (lambda (stack) (stack 'initialize))
                                            stacks)))
...
              ((eq? message 'stacks) stacks)
...
))))))

(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stacks (machine 'stacks))
        (ops (machine 'operations)))
     ...)

(define (make-save inst machine stacks pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine reg-name)))
    (lambda ()
      (let ((stack (cadr (assoc reg-name stacks))))
        (push stack (get-contents reg)))
      (advance-pc pc))))

(define (make-restore inst machine stacks pc)
  (let* ((reg-name (stack-inst-reg-name inst))
         (reg (get-register machine
                            (stack-inst-reg-name inst))))
    (lambda ()
      (let ((stack (cadr (assoc reg-name stacks))))
        (set-contents! reg (pop stack)))
      (advance-pc pc))))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(set-register-contents! test-5.11-machine 'y 6)
(set-register-contents! test-5.11-machine 'x 3)
(start test-5.11-machine)

;Value: done

(get-register-contents test-5.11-machine 'y)

;Value: 6

(get-register-contents test-5.11-machine 'x)

;Value: 3
#+END_SRC

Works as expected.
*** Exercise 5.12
- a list of all instructions without duplicates, sorted by instruction type;

  We need to implement constructing procedure that is analogous to
  =merge-weighted= or ordered. We could have chosen to sort the instructions
  in alphabetical order without bothered by the instruction type, but I felt it
  is more canonical to order the result in the order of dispatch on type in
  =make-execution-procedure=.

  Here is one possible solution:
  #+BEGIN_SRC scheme
(define type-dict
  '((assign 1) (test 2) (branch 3) (goto 4)
    (save 5) (restore 6) (perform 7)))

(define (adjoin-ordered precede? item ordered)
  (if (null? ordered)
      (list item)
      (let ((first (first ordered)))
        (cond ((precede? item first)
               (cons item ordered))
              ((precede? first item)
               (cons first
                     (adjoin-ordered
                      precede? item (cdr ordered))))
              (else
               ;; given item already in the ordered
               ordered)))))

(define (inst-precede? inst1 inst2)
  (let ((type1 (car inst1))
        (type2 (car inst2)))
    (let ((mapped1 (cadr (assoc type1 type-dict)))
          (mapped2 (cadr (assoc type2 type-dict))))
      (cond ((< mapped1 mapped2) true)
            ((> mapped1 mapped2) false)
            (else
             ;; same number
             (not (equal? inst1 inst2)) ;just exclude the same one
             )))))

;; First request
(define (assemble controller-text machine receive)
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      (receive
          insts
          (fold-right (lambda (inst ordered)
                        (adjoin-ordered inst-precede? inst ordered))
                      '()
                      (map (lambda (inst) (instruction-text inst))
                           insts))))))
  #+END_SRC

  Here we used the continuation to hand over the updated instructions with the
  newly constructed a list of all instructions:
  #+BEGIN_SRC scheme
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) register-name))
              register-names)
    ((machine 'install-operations) ops)
    (assemble controller-text machine
               (lambda (instructions all-instructions)
                 ((machine 'install-instruction-sequence)
                  instructions)
                 ((machine 'install-all-instructions)
                  all-instructions)))
    machine))
  #+END_SRC

  And modify the =make-new-machine= accordingly. Then test with Fibonacci
  machine:
  #+BEGIN_SRC scheme
(pp (fib-machine 'all-instructions))
((assign continue (label fib-done))
 (assign continue (label afterfib-n-1))
 (assign n (op -) (reg n) (const 1))
 (assign n (op -) (reg n) (const 2))
 (assign continue (label afterfib-n-2))
 (assign n (reg val))
 (assign val (op +) (reg val) (reg n))
 (assign val (reg n))
 (test (op <) (reg n) (const 2))
 (branch (label immediate-answer))
 (goto (label fib-loop))
 (goto (reg continue))
 (save continue)
 (save n)
 (save continue)
 (save val)
 (restore n)
 (restore continue)
 (restore val)
 (restore continue))
;Unspecified return value
  #+END_SRC

  Unfortunately, our implementation was wrong! the duplicates appear in the
  result. So we need to arrange in strict order:
  #+BEGIN_SRC scheme
(define (inst-precede? inst1 inst2)
  (let ((type1 (car inst1))
        (type2 (car inst2)))
    (let ((mapped1 (cadr (assoc type1 type-dict)))
          (mapped2 (cadr (assoc type2 type-dict))))
      (cond ((< mapped1 mapped2) true)
            ((> mapped1 mapped2) false)
            (else
             ;; same number
             ;; (not (equal? inst1 inst2)) ;just exclude the same one
             (symbol<? (hash-symbol-list (cdr inst1))
                       (hash-symbol-list (cdr inst2)))
             )))))

(define (hash-symbol-list slst)
  (fold-right
   (lambda (s appended)
     (symbol-append s appended))
   '||
   (flatten slst)))

;; Test hash-symbol-list
;; (hash-symbol-list '(a b (c d e) f g))
;; ;Value: abcdefg


;; Tree<A> -> List<A>
(define (flatten tree)
  (tree-map list append '() tree))

;; Test flatten
;; (flatten '(1 (2 3) (4 (5 6) 7)))
;; ;Value: (1 2 3 4 5 6 7)


;; (Leaf<A> -> B), (B, B -> B), B, Tree<A>
;; -> B
(define (tree-map leaf-op combine-op initial tree)
  (cond ((null? tree) initial)
        ((not (pair? tree)) (leaf-op tree))
        (else                           ;pair
         (combine-op
          (tree-map leaf-op combine-op initial
                    (car tree))
          (tree-map leaf-op combine-op initial
                    (cdr tree))))))
  #+END_SRC

  For the reminding purpose, we implemented other high order procedure also.
  Then let's re-test
  #+BEGIN_SRC scheme
(pp (fib-machine 'all-instructions))
((assign continue (label afterfib-n-1))
 (assign continue (label afterfib-n-2))
 (assign continue (label fib-done))
 (assign n (op -) (reg n) (const 1))
 (assign n (op -) (reg n) (const 2))
 (assign n (reg val))
 (assign val (op +) (reg val) (reg n))
 (assign val (reg n))
 (test (op <) (reg n) (const 2))
 (branch (label immediate-answer))
 (goto (label fib-loop))
 (goto (reg continue))
 (save continue)
 (save n)
 (save val)
 (restore continue)
 (restore n)
 (restore val))
;Unspecified return value
  #+END_SRC

  Now it returns what we expected.
- a list (without duplicates) of the registers used to hold entry points (these
  are the registers referenced by =goto= instructions);

  To do this task, we reuse what the result from the previous task. Here is the
  strategy:
  1. Filter the all instructions with =goto-exp?=;

  2. using =map=, extract the =goto-dest= part;

  3. filter that with =register-exp?=;

  4. and lastly, extract the =register-exp-reg= part and that is what we wanted.

    Here is the code do this idea:
    #+BEGIN_SRC scheme
  ,*** in assemble
  (let* ((all-insts
          (fold-right (lambda (inst ordered)
                        (adjoin-ordered inst-precede? inst ordered))
                      '()
                      (map (lambda (inst) (instruction-text inst))
                           insts)))
         (entry-regs
          (filter-map
           (lambda (goto-inst)
             (let ((dest (goto-dest goto-inst)))
               (and (register-exp? dest)
                    (register-exp-reg dest))))
           (take-while
            (lambda (inst)
              (eq? (car inst) 'goto))
            (drop-while
             (lambda (inst)
               (not (eq? (car inst) 'goto)))
             all-insts)))))
    (accept
     insts
     all-insts
     entry-regs))
    #+END_SRC

    We've integrate *2.* to *4.* part using =filter-map=; and for the first one,
    we used =take-while= and =drop-while= exploiting the fact that all
    instructions are sorted in types.

    Then test:
    #+BEGIN_SRC scheme
  (pp (fib-machine 'registers-with-entry))
  (continue)
  ;Unspecified return value
    #+END_SRC
- a list (without duplicates) of the registers that are =save= d or =restore= d;

  This is analogous to the preceding one:
  #+BEGIN_SRC scheme
,*** in let expression of assemble
(stack-related-regs
 (map
  (lambda (inst)
    (stack-inst-reg-name inst))
  (take-while
   (lambda (inst)
     (or (eq? (car inst) 'save)
         (eq? (car inst) 'restore)))
   (drop-while
    (lambda (inst)
      (not (eq? (car inst) 'save)))
    all-insts))))
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(pp (fib-machine 'stack-instruction-registers))
(continue n val continue n val)
;Unspecified return value
  #+END_SRC

  Huh! It's not what we expected. It is due to that we count one for the =save=
  and one for the =restore=, which usually end up with duplicates names.

  So let's fix it using the =adjoin-ordered=:
  #+BEGIN_SRC scheme
(stack-related-regs
 (fold-right
  (lambda (reg-name regs)
    (adjoin-ordered
     symbol<?
     reg-name
     regs))
  '()
  (map (lambda (inst)
         (stack-inst-reg-name inst))
       (take-while
        (lambda (inst)
          (or (eq? (car inst) 'save)
              (eq? (car inst) 'restore)))
        (drop-while
         (lambda (inst)
           (not (eq? (car inst) 'save)))
         all-insts)))))
  #+END_SRC

  Then we got
  #+BEGIN_SRC scheme
(pp (fib-machine 'stack-instruction-registers))
(continue n val)
;Unspecified return value
  #+END_SRC

- for each register, a list (without duplicates) of the sources from which it is
  assigned.

  Notice that the register source relations can be deduced directly from the
  =assign= expressions. So here we attempt to solve this task using the
  following strategy:
  1. Assume we have table data structure that has key /values/ entries. That is,
     if one insert key value pair into the given table, the value adjoined into
     the value list of given key.

  2. Then filter out the all instructions into =assign= expressions, and then
     insert the =assign-reg-name= as key and the =assign-value-exp= as value
     into the above table.

  3. The rest is interfacing this with the machine object; one can retrieve the
     sources of given register using the message, =sources-of=.

  Here is the code:
  #+BEGIN_SRC scheme
,*** in assemble let expression
(reg-sources-table
 (let ((tbl (make-multivalues-table)))
   (for-each
    (lambda (inst)
      ((tbl 'insert!)
       (assign-reg-name inst)
       (assign-value-exp inst)))
    (take-while
     (lambda (inst)
       (eq? (car inst) 'assign))
     all-insts))
   tbl))
  #+END_SRC

  Then what assumed:
  #+BEGIN_SRC scheme
(define (make-multivalues-table)
  (let ((local-table '(*table*)))
    (define (lookup-vals key)
      (cond ((assoc key (cdr local-table)) => cdr)
            (else false)))
    (define (insert-value! key value)
      (let ((entry (assoc key (cdr local-table))))
        (if entry
            (set-cdr! entry
                      (cons value (cdr entry)))
            (set-cdr! local-table
                      (cons (cons key (list value))
                            (cdr local-table))))))
    (lambda (m)
      (case m
        ((lookup) lookup-vals)
        ((insert!) insert-value!)
        (else
         (error "Unknown request -- MAKE-MULTIVALUES-TABLE" m))))))

;; Test for make-multivalues-table
;; (define x (make-multivalues-table))
;; ((x 'insert!) 'a 5)
;; ((x 'lookup) 'a)
;; ;; (5)
;; ((x 'insert!) 'a 2)
;; ((x 'lookup) 'a)
;; ;; (2 5)
;; ((x 'insert!) 'b 2)
;; ((x 'lookup) 'b)
;; ;; (2)
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(pp ((fib-machine 'sources-of) 'n))
(((reg val)) ((op -) (reg n) (const 2)) ((op -) (reg n) (const 1)))
;Unspecified return value
  #+END_SRC
*** Exercise 5.13
We can what we want by modifying =get-register= procedure, which called in the
=make-execution-procedure= to reference the register object allocated in given
machine.

But it is not good idea to alter the existing =get-register= procedure since it
may interface with other process also as its contract is not just for the
=make-execution-procedure=.

So it would be better to make procedure that is analogous to =get-register= but
it allocates given register name whenever it has not been allocated in given
machine. If given register name already allocated in given machine, then it
should works like =get-register=.

With this idea, we can do the task what we requested. After implementing this
idea, we are good to discard the preallocating process in the =make-machine=.

#+BEGIN_SRC scheme
,*** within make-new-machine
(define (try-allocate-and-return-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (begin (allocate-register name)
                     (lookup-register name)))))
,*** in the dispatch
((eq? message 'try-allocate-and-get-register)
               try-allocate-and-return-register)
#+END_SRC

Then
#+BEGIN_SRC scheme
(define (make-sure-allocate-register-and-get machine reg-name)
  ((machine 'try-allocate-and-get-register) reg-name))
#+END_SRC

And we should replace all the subprocesses of =assemble= to use
=make-sure-allocate-register-and-get= instead of =get-register=:
#+BEGIN_SRC scheme
(define (make-assign inst machine labels operations pc)
  (let ((target
         (make-sure-allocate-register-and-get machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()                ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))

(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (make-sure-allocate-register-and-get machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction -- ASSEMBLE"
                       inst)))))

(define (make-save inst machine stack pc)
  (let ((reg (make-sure-allocate-register-and-get machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (make-sure-allocate-register-and-get machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))

(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (make-sure-allocate-register-and-get machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type -- ASSEMBLE" exp))))
#+END_SRC

Now =make-machine= gets
#+BEGIN_SRC scheme
(define (make-machine ops controller-text)
  (let ((machine (make-new-machine)))
    ((machine 'install-operations) ops)
    (assemble controller-text machine
              (lambda (instructions
                       all-instructions registers-with-entry
                       stack-inst-regs reg-sources-table)
                ((machine 'install-instruction-sequence)
                 instructions)
                ((machine 'install-all-instructions)
                 all-instructions)
                ((machine 'install-registers-with-entry)
                 registers-with-entry)
                ((machine 'install-stack-instruction-registers)
                 stack-inst-regs)
                ((machine 'install-register-sources-table)
                 reg-sources-table)))
    machine))
#+END_SRC

And let's test:
#+BEGIN_SRC scheme
(define fib-machine
  (make-machine
   `((< ,<) (- ,-) (+ ,+))
   '((assign continue (label fib-done))
     fib-loop
     (test (op <) (reg n) (const 2))
     (branch (label immediate-answer))
     ;; set up to compute Fib(n-1)
     (save continue)
     (assign continue (label afterfib-n-1))
     (save n)                            ; save old value of n
     (assign n (op -) (reg n) (const 1)) ; clobber n to n-1
     (goto (label fib-loop))             ; perform recursive call
     afterfib-n-1                        ; upon return, val contains Fib(n-1)
     (restore n)
     (restore continue)
     ;; set up to compute Fib(n-2)
     (assign n (op -) (reg n) (const 2))
     (save continue)
     (assign continue (label afterfib-n-2))
     (save val)                         ; save Fib(n-1)
     (goto (label fib-loop))
     afterfib-n-2                       ; upon return, val contains Fib(n-2)
     (assign n (reg val))               ; n now contains Fib(n-2)
     (restore val)                      ; val now contains Fib(n-1)
     (restore continue)
     (assign val                        ; Fib(n-1)+Fib(n-2)
             (op +) (reg val) (reg n))
     (goto (reg continue))              ; return to caller, answer is in val
     immediate-answer
     (assign val (reg n))               ; base case: Fib(n)=n
     (goto (reg continue))
     fib-done)))

;Value: fib-machine

(set-register-contents! fib-machine 'n 4)

;Value: done

(start fib-machine)

;Value: done

(get-register-contents fib-machine 'val)

;Value: 3
#+END_SRC

Works well.
** Monitoring Machine Performance
*** Exercise 5.14
#+BEGIN_SRC scheme
 (define fact-machine
  (make-machine
   `((= ,=) (- ,-) (* ,*))
   '(
     (perform (op initialize-stack))
     (assign continue (label fact-done)) ; set up final return address
     fact-loop
     (test (op =) (reg n) (const 1))
     (branch (label base-case))
     ;; Set up for the recursive call by saving n and continue.
     ;; Set up continue so that the computation will continue
     ;; at after-fact when the subroutine returns.
     (save continue)
     (save n)
     (assign n (op -) (reg n) (const 1))
     (assign continue (label after-fact))
     (goto (label fact-loop))
     after-fact
     (restore n)
     (restore continue)
     (assign val (op *) (reg n) (reg val)) ; val now contains n(n-1)!
     (goto (reg continue))                 ; return to caller
     base-case
     (assign val (const 1))             ; base case: 1!=1
     (goto (reg continue))              ; return to caller
     fact-done
     (perform (op print-stack-statistics)))))
#+END_SRC

Then here is the experiment cases:
#+BEGIN_SRC scheme
(set-register-contents! fact-machine 'n 10)

;Value: done

(start fact-machine)

(total-pushes = 18 maximum-depth = 18)
;Value: done

(set-register-contents! fact-machine 'n 20)

;Value: done

(start fact-machine)

(total-pushes = 38 maximum-depth = 38)
;Value: done

(set-register-contents! fact-machine 'n 2)

;Value: done

(start fact-machine)

(total-pushes = 2 maximum-depth = 2)
;Value: done
#+END_SRC

From this data, we can deduce that =total-pushes= and =maximum-depth= are same
and the general formula for this in terms of =n= is $T(n) = 2n-2$.

Or using =read=:
#+BEGIN_SRC scheme
(start fact-machine)
5

(total-pushes = 8 maximum-depth = 8)
;Value: done

(start fact-machine)
35

(total-pushes = 68 maximum-depth = 68)
;Value: done
#+END_SRC
*** Exercise 5.15
We need to modify the =make-new-machine= procedure to include =number-execs= to
accommodate new feature specified in the statement.

And define as internal definition of that procedure the following print method:
#+BEGIN_SRC scheme
(define (print-statistics)
        (newline)
        (display
         `(tatal-executions = ,number-execs)))
#+END_SRC

And modify =execute=:
#+BEGIN_SRC scheme
(define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (set! number-execs (1+ number-execs))
                (execute)))))
#+END_SRC

And interface with the rest:
#+BEGIN_SRC scheme
,*** in dispatch
              ((eq? message 'print-statistics) (print-statistics))
              ((eq? message 'initialize-statistics) (set! number-execs 0))
#+END_SRC

Now we can use as follows:
#+BEGIN_SRC scheme
(set-register-contents! fib-machine 'n 10)

;Value: done

(start fib-machine)

;Value: done

(fib-machine 'print-statistics)

(tatal-executions = 2029)
;Unspecified return value

(fib-machine 'initialize-statistics)

;Value: 2029

(set-register-contents! fib-machine 'n 20)

;Value: done

(start fib-machine)

;Value: done

(fib-machine 'print-statistics)

(tatal-executions = 251740)
;Unspecified return value
#+END_SRC

Exponential growth verified!
*** Exercise 5.16
1. Make =make-new-machine= have =trace?= as state variable, which can be on and
   off by the message =trace-on= and =trace-off=.
2. Then in the =execute= procedure, if =trace?= then it should print out the
   instruction text -- by using the =instruction-text= selector.


Then test
#+BEGIN_SRC scheme
(fib-machine 'trace-on)

;Value: #f

(set-register-contents! fib-machine 'n 3)

;Value: done

(start fib-machine)

(assign continue (label fib-done))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(save continue)
(assign continue (label afterfib-n-1))
(save n)
(assign n (op -) (reg n) (const 1))
(goto (label fib-loop))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(save continue)
(assign continue (label afterfib-n-1))
(save n)
(assign n (op -) (reg n) (const 1))
(goto (label fib-loop))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(assign val (reg n))
(goto (reg continue))
(restore n)
(restore continue)
(assign n (op -) (reg n) (const 2))
(save continue)
(assign continue (label afterfib-n-2))
(save val)
(goto (label fib-loop))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(assign val (reg n))
(goto (reg continue))
(assign n (reg val))
(restore val)
(restore continue)
(assign val (op +) (reg val) (reg n))
(goto (reg continue))
(restore n)
(restore continue)
(assign n (op -) (reg n) (const 2))
(save continue)
(assign continue (label afterfib-n-2))
(save val)
(goto (label fib-loop))
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(assign val (reg n))
(goto (reg continue))
(assign n (reg val))
(restore val)
(restore continue)
(assign val (op +) (reg val) (reg n))
(goto (reg continue))
;Value: done
#+END_SRC
*** Exercise 5.17
Here we should think of what abstraction level we are going to modify. Since the
tracing things is about in the =make-new-machine= procedure, we may need to the
machine object to possess label information.

But we do not want break the ADT about the label data, it would be better to
offer lookup method with the label data from outside of machine object.

And also construct additional ADT:
#+BEGIN_SRC scheme
;;; ADT for labels package which going to be installed into machine object
(define (make-labels-package find-from-key find-from-val labels)
  (list find-from-key find-from-val labels))
(define (find-from-key-proc labels-pack)
  (car labels-pack))
(define (find-from-val-proc labels-pack)
  (cadr labels-pack))
(define (labels-data labels-pack)
  (caddr labels-pack))

;; operate on labels-package
(define (find-from-val labels-pack)
  (lambda (val)
    ((find-from-val-proc labels-pack)
     val
     (labels-data labels-pack))))

(define (find-from-key labels-pack)
  (lambda (key)
    ((find-from-key-proc labels-pack)
     key
     (labels-data labels-pack))))
#+END_SRC

Then define the retriever:
#+BEGIN_SRC scheme
;; selector of labels
(define retrive-label-from-insts
  (association-procedure eq? cdr))
#+END_SRC

The rest is interface with the others:
#+BEGIN_SRC scheme
,*** in assemble
(accept
 insts
 (make-labels-package
  get-label
  retrive-label-from-insts
  labels)
 all-insts
 entry-regs
 stack-related-regs
 reg-sources-table)

,*** in make-machine
((machine 'install-labels-package)
 labels-package)

,*** in execute in the make-new-machine
(let ((inst (car insts)))
  (if trace?
      (let ((label-entry ((find-from-val labels-package)
                          insts)))
        (if label-entry
            (begin (newline)
                   (display (label-name label-entry))))
        (begin (newline)
               (display (instruction-text inst)))))
  ((instruction-execution-proc inst))
  (set! number-execs (1+ number-execs))
  (execute))
#+END_SRC

=Label-name= and =get-label= are defined in [[Exercise 5.8][exercise 5.8]].

Then test
#+BEGIN_SRC scheme
(start fib-machine)

(assign continue (label fib-done))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(save continue)
(assign continue (label afterfib-n-1))
(save n)
(assign n (op -) (reg n) (const 1))
(goto (label fib-loop))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
(save continue)
(assign continue (label afterfib-n-1))
(save n)
(assign n (op -) (reg n) (const 1))
(goto (label fib-loop))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
immediate-answer
(assign val (reg n))
(goto (reg continue))
afterfib-n-1
(restore n)
(restore continue)
(assign n (op -) (reg n) (const 2))
(save continue)
(assign continue (label afterfib-n-2))
(save val)
(goto (label fib-loop))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
immediate-answer
(assign val (reg n))
(goto (reg continue))
afterfib-n-2
(assign n (reg val))
(restore val)
(restore continue)
(assign val (op +) (reg val) (reg n))
(goto (reg continue))
afterfib-n-1
(restore n)
(restore continue)
(assign n (op -) (reg n) (const 2))
(save continue)
(assign continue (label afterfib-n-2))
(save val)
(goto (label fib-loop))
fib-loop
(test (op <) (reg n) (const 2))
(branch (label immediate-answer))
immediate-answer
(assign val (reg n))
(goto (reg continue))
afterfib-n-2
(assign n (reg val))
(restore val)
(restore continue)
(assign val (op +) (reg val) (reg n))
(goto (reg continue))
;Value: done
#+END_SRC
*** Exercise 5.18
It is analogous to the previous one:
#+BEGIN_SRC scheme
(define (make-register name)
  (let ((contents '*unassigned*)
        (trace? #f))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value)
               (if trace?
                   (begin (newline)
                          (display `(Register ,name gets ,value from ,contents))))
               (set! contents value)))
            ((eq? message 'trace-on)
             (set! trace? #t))
            ((eq? message 'trace-off)
             (set! trace? #f))
            (else
             (error "Unknown request -- REGISTER" message))))
    dispatch))
#+END_SRC

Then unit test:
#+BEGIN_SRC scheme
(define x (make-register 'x))
(x 'trace-on)
((x 'set) 5)

(register x gets 5 from *unassigned*)
;Value: *unassigned*
#+END_SRC

All the rest is to interface in the =make-new-machine=:
#+BEGIN_SRC scheme
,*** in make-new-machine
              ((eq? message 'trace-on-register)
               (lambda (reg-name)
                 ((lookup-register reg-name) 'trace-on)))
              ((eq? message 'trace-off-register)
               (lambda (reg-name)
                 ((lookup-register reg-name) 'trace-off)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
((fib-machine 'trace-on-register) 'n)

;Value: #f

(set-register-contents! fib-machine 'n 3)

(register n gets 3 from *unassigned*)
;Value: done

(start fib-machine)

(register n gets 2 from 3)
(register n gets 1 from 2)
(register n gets 2 from 1)
(register n gets 0 from 2)
(register n gets 0 from 0)
(register n gets 3 from 0)
(register n gets 1 from 3)
(register n gets 1 from 1)
;Value: done
#+END_SRC
*** Exercise 5.19
This is a analogous feature to =start= procedure; but use =label= data. The
specifications on the procedures that manipulate break points indicates we need
to define new data structure that keeps track of all the break points.

As we noted before, our machine now has the information about the label as its
state variable, we can transform the specifications of where the break point
should be into the actual instruction. So here we are going to store this
transformed information as the break points data structure -- so called internal
data.

For the break points data structure, we need to remove the specified break point
from the structure; it means we should mutate the data structure. So we'd better
to give the data structure identity. For this purpose, we'll implement the break
points as headed list to possess identity.

And more, we should keep track of the current break point since we should
support the =proceed-machine= procedure. We can exploit dummy head of the headed
list possessing this additional information. Or

Then here is the code
#+BEGIN_SRC scheme
,*** as state variable of make-new-machine
        (break-points '(#f))
...
,*** internal defintions of make-new-machine
      (define (cdring-down lst n)
        (if (= n 1)
            lst
            (cdring-down (cdr lst)
                         (-1+ n))))
      (define (add-break-point label n)
        (let ((break-point
               (cdring-down ((find-from-key labels-package) label)
                            n)))
          (if (memq break-point (cdr break-points))
              (error "Given break point already in break points -- ADD-BREAK-POINT"
                     (list label n))
              (set-cdr! break-points (cons break-point
                                           (cdr break-points))))))
      (define (remove-break-point label n)
        (let ((break-point
               (cdring-down ((find-from-key labels-package) label)
                            n)))
          (let loop ((items break-points))
            (cond ((null? (cdr items))
                   (error "Given break point not in break points -- REMOVE-BREAK-POINT"
                          (list label n)))
                  ((eq? (cadr items) break-point)
                   (set-cdr! items (cddr items)))
                  (else (loop (cdr items)))))))
#+END_SRC

Then =execute= gets complicated than before:
#+BEGIN_SRC scheme
(define (execute)
  (let ((insts (get-contents pc)))
    (cond ((null? insts) 'done)
          ((car break-points) ;the right after instruction from the broken
           (set-car! break-points #f)
           (execute))
          ((and (not (eq? (car break-points) insts)) ;ensure this is not the point broken
                (memq insts (cdr break-points)))
           (set-car! break-points insts) ;save the broken point
           'broken)
          (else
           (let ((inst (car insts)))
             (if trace?
                 (let ((label-entry ((find-from-val labels-package)
                                     insts)))
                   (if label-entry
                       (begin (newline)
                              (display (label-name label-entry))))
                   (begin (newline)
                          (display (instruction-text inst)))))
             ((instruction-execution-proc inst))
             (set! number-execs (1+ number-execs))
             (execute))))))
#+END_SRC

And interfaces:
#+BEGIN_SRC scheme
,*** in dispatch
              ((eq? message 'proceed-machine)
               (if (car break-points)
                   (begin (set-contents! pc (car break-points))
                          (execute))
                   (error "There in no broken point to proceed from -- PROCEED-MACHINE")))
              ((eq? message 'set-breakpoint)
               add-break-point)
              ((eq? message 'cancel-breakpoint)
               remove-break-point)
              ((eq? message 'cancel-all-breakpoints)
               (set! break-points '(#f)))
#+END_SRC

To procedural syntax:
#+BEGIN_SRC scheme
(define (set-breakpoint machine label n)
  ((machine 'set-breakpoint) label n))

(define (cancel-breakpoint machine label n)
  ((machine 'cancel-breakpoint) label n))

(define (proceed-machine machine)
  (machine 'proceed-machine))

(define (cancel-all-breakpoints machine)
  (machine 'cancel-all-breakpoints))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
(set-breakpoint gcd-machine 'test-b 4)

;The object test-b, passed as an argument to assoc, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

It is due to that the =find-from-val= and =find-from-key= does not agree in
where the =labels= should position. Let us make them consist along with
=loopup-label=.

Then re-run the test:
#+BEGIN_SRC scheme
(set-register-contents! gcd-machine 'a 202)

;Value: done

(set-register-contents! gcd-machine 'b 43)

;Value: done

(set-breakpoint gcd-machine 'test-b 4)

;Unspecified return value

(gcd-machine 'trace-on)

;Value: #f

(start gcd-machine)

test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
;Value: broken

(proceed-machine gcd-machine)

;Value: broken
#+END_SRC

Unfortunately our =proceed-machine= does not work as expected.

We should have defined as follows
#+BEGIN_SRC scheme
(define (execute)
        (let ((insts (get-contents pc)))
          (cond ((null? insts) 'done)
                ((and (car break-points) ;the right after instruction from the broken
                      (not (eq? (car break-points) insts)))
                 (set-car! break-points #f)
                 (execute))
                ((and (not (eq? (car break-points) insts)) ;ensure this is not the point broken
                      (memq insts (cdr break-points)))
                 (set-car! break-points insts) ;save the broken point
                 'broken)
                (else
                 (let ((inst (car insts)))
                   (if trace?
                       (let ((label-entry ((find-from-val labels-package)
                                           insts)))
                         (if label-entry
                             (begin (newline)
                                    (display (label-name label-entry))))
                         (begin (newline)
                                (display (instruction-text inst)))))
                   ((instruction-execution-proc inst))
                   (set! number-execs (1+ number-execs))
                   (execute))))))
#+END_SRC

Now it works as expected:
#+BEGIN_SRC scheme
(start gcd-machine)

test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
;Value: broken

(proceed-machine gcd-machine)

(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
;Value: broken

(cancel-breakpoint gcd-machine 'test-b 4)

;Unspecified return value

(proceed-machine gcd-machine)

(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
(assign t (op rem) (reg a) (reg b))
(assign a (reg b))
(assign b (reg t))
(goto (label test-b))
test-b
(test (op =) (reg b) (const 0))
(branch (label gcd-done))
;Value: done

#+END_SRC
* Storage Allocation and Garbage Collection
** Memory as Vectors
*** Exercise 5.20
I've drawn this diagram with my digital paper.
*** Exercise 5.21
**** a.
#+BEGIN_SRC scheme
(controller
 (assign continue (label count-done))
 count-leaves-loop
 (test (op null?) (reg tree))
 (branch (label base-case))
 ;; (test (op pair?) (reg tree))
 ;; (test (op not) (reg flag))
 (assign t (op pair?) (reg tree))
 (test (op not) (reg t))
 (branch (label count-case))
 (save continue)          ;setup recursive call -- (count-leaves (car tree))
 (assign continue (label after-car-tree))
 (save tree)
 (assign tree (op car) (reg tree))
 (goto (label count-leaves-loop))
 after-car-tree
 (assign continue (label after-cdr-tree))
 (restore tree)                     ;setup recursive call -- (count-leaves (cdr tree))
 (save val)
 (assign tree (op cdr) (reg tree))
 (goto (label count-leaves-loop))
 after-cdr-tree
 (restore t)
 (assign val (op +) (reg val) (reg t))
 (restore continue)
 (goto (reg continue))
 base-case
 (assign val (const 0))
 (goto (reg continue))
 count-case
 (assign val (const 1))
 (goto (reg continue))
 count-done)
#+END_SRC

To implement above register machine program, you need to use the wishful
thinking as we did in higher level procedure. For the commented code, it would
work if we use the commented code other than using intermediate register t, but
in anyway we will need =t= in later in the code, so it would be better not to
use the =flag= directly.

Then test:
#+BEGIN_SRC scheme
(define count-leaves-machine-a
  (make-machine
   `((null? ,null?)
     (pair? ,pair?)
     (not ,not)
     (+ ,+)
     (car ,car)
     (cdr ,cdr))
   '(
     (assign continue (label count-done))
     count-leaves-loop
     (test (op null?) (reg tree))
     (branch (label base-case))
     ;; (test (op pair?) (reg tree))
     ;; (test (op not) (reg flag))
     (assign t (op pair?) (reg tree))
     (test (op not) (reg t))
     (branch (label count-case))
     (save continue)          ;setup recursive call -- (count-leaves (car tree))
     (assign continue (label after-car-tree))
     (save tree)
     (assign tree (op car) (reg tree))
     (goto (label count-leaves-loop))
     after-car-tree
     (assign continue (label after-cdr-tree))
     (restore tree)                     ;setup recursive call -- (count-leaves (cdr tree))
     (save val)
     (assign tree (op cdr) (reg tree))
     (goto (label count-leaves-loop))
     after-cdr-tree
     (restore t)
     (assign val (op +) (reg val) (reg t))
     (restore continue)
     (goto (reg continue))
     base-case
     (assign val (const 0))
     (goto (reg continue))
     count-case
     (assign val (const 1))
     (goto (reg continue))
     count-done)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(set-register-contents! count-leaves-machine-a 'tree '(1 2 (3 4 (5 6) (7))))

(start count-leaves-machine-a)

;Value: done

(get-register-contents count-leaves-machine-a 'val)

;Value: 7
#+END_SRC
**** b.
The next one:
#+BEGIN_SRC scheme
(controller
 (assign n (const 0))
 (assign continue (label count-done))
 count-loop
 (test (op null?) (reg tree))
 (branch (label base-case))
 (test (op pair?) (reg tree))
 (test (op not) (reg flag))
 (branch (label count-case))
 (save continue)                    ;else clause
 (assign continue (label after-car))
 (save tree)
 (assign tree (op car) (reg tree))
 (goto (label count-loop))
 after-car
 (restore tree)
 (assign tree (op cdr) (reg tree))
 (assign continue (label after-cdr))
 (goto (label count-loop))
 after-cdr
 (restore continue)
 (goto (reg continue))
 base-case
 (goto (reg continue))
 count-case
 (assign n (op 1+) (reg n))
 (goto (reg continue))
 count-done)
#+END_SRC

Note that here we done need to use any additional register than =n= for
returning value.

And test:
#+BEGIN_SRC scheme
(set-register-contents! count-leaves-machine-b 'tree '(1 2 (3 4 (5) (6 (7)))))

;Value: done

(start count-leaves-machine-b)

;Value: done

(get-register-contents count-leaves-machine-b 'n)

;Value: 7
#+END_SRC
*** Exercise 5.22
The functional version of =append=:
#+BEGIN_SRC scheme
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
#+END_SRC

Then the trasformed version:
#+BEGIN_SRC scheme
(define append-machine
  (make-machine
   '(x continue y)
   `((null? ,null?) (pair? ,pair?)
     (car ,car) (cdr ,cdr) (cons ,cons))
   '((assign continue (label append-done))
     append-loop
     (test (op null?) (reg x))
     (branch (label base-case))
     (save continue)
     (assign continue (label after-recur))
     (save x)
     (assign x (op cdr) (reg x))
     (goto (label append-loop))
     after-recur
     (restore x)
     (assign x (op car) (reg x))
     (assign y (op cons) (reg x) (reg y))
     (restore continue)
     (goto (reg continue))
     base-case
     (goto (reg continue))
     append-done)))
#+END_SRC

Now let's test this machine in this machine -- the result in the =y= register:
#+BEGIN_SRC scheme
(set-register-contents! append-machine 'x '(1 2 3))

;Value: done

(set-register-contents! append-machine 'y '(4 5 6))

;Value: done

(start append-machine)

;Value: done

(get-register-contents append-machine 'x)

;Value: 1

(get-register-contents append-machine 'y)

;Value: (1 2 3 4 5 6)
#+END_SRC

Then imperative version:
#+BEGIN_SRC scheme
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

#+END_SRC

Then here is the transformation in step:
#+BEGIN_SRC scheme
;; High level description -- assume last-pair as primitive
'(
  (assign l-p (op last-pair) (reg x))
  (perform (op set-cdr!) (reg l-p) (reg y))
  )

;;; last-pair unwinded
'(
  test-l-p
  (assign t (op cdr) (reg x))
  (test (op null?) (reg t))
  (branch (label last-pair-done))
  (assign x (reg t))
  (goto (label test-l-p))
  last-pair-done
  )

;; Then link together
'(
  test-l-p
  (assign t (op cdr) (reg l-p))
  (test (op null?) (reg t))
  (branch (label last-pair-done))
  (assign l-p (reg t))
  (goto (label test-l-p))
  last-pair-done
  (perform (op set-cdr!) (reg l-p) (reg y))
  )
#+END_SRC

Now we can construct machine we do this simulation; the result in =x= register.
#+BEGIN_SRC scheme
(define append!-machine
  (make-machine
   '(x y l-p t)
   `((set-cdr! ,set-cdr!) (cdr ,cdr) (null? ,null?))
   '(
     (assign l-p (reg x))
     test-l-p
     (assign t (op cdr) (reg l-p))
     (test (op null?) (reg t))
     (branch (label last-pair-done))
     (assign l-p (reg t))
     (goto (label test-l-p))
     last-pair-done
     (perform (op set-cdr!) (reg l-p) (reg y))
     )))
#+END_SRC

#+BEGIN_SRC scheme
(set-register-contents! append!-machine 'x '(1 2 3))

;Value: done

(set-register-contents! append!-machine 'y '(4 5 6))

;Value: done

(start append!-machine)

;Value: done

(get-register-contents append!-machine 'x)

;Value: (1 2 3 4 5 6)
#+END_SRC

Note that in this version, we haven't used any stack operation, that means this
is iterative process unlike the preceding implementation.
** Maintaining the Illusion of Infinite Memory
In this section, we are going to learn how our evaluator manage the memory under
the hood. This is quite simple and compact algorithm that we are going to see;
but it resolves a lot of difficulties otherwise we encountered with (or should
concern about).

To keep track of the contents of this section, you should draw diagram along with
emerging controller sequence as if you were a machine; otherwise you'll get feel
like you understood the core concept of this simple and compact algorithm but
only in spurious manner.
* The Explicit-Control Evaluator
Now we turn into the application of this new language. Actually this is not an
application but in more presentation about what's going on under the hood --
this is meant to explain what they assumed or omitted to describe in preceding
chapter, [[org:../MEGAsync/MIT Challenge/6.001/Chapter4.org][Metacircular Evaluator]].

Through this material, we will get the ability to implement meta circular
evaluator or even the other variants in hardware in principal. That is, if we
are patient enough to gathering all the stuffs to implement what we planned to
do, say the query language we developed in preceding chapter, we got the machine
in real world only for that purpose.

So for start, here they are going to /unwind/ the metacircular evaluator in
sections 4.1.1 through 4.1.4.

From this point, we can get some intuition behind this concept through the
[[youtube:ikvAQ_lu31s?list=PL7BcsI5ueSNFPCEisbaoQ0kXIDX9rR5FF][lectures]] available in [[youtube:cIc8ZBMcqAc?list=PLE18841CABEA24090][online]]. So for recapitulation or to understand what concepts
the authors consider as core, before to go through this section, we'd better to
go through all the material before this section -- Register Machines.

Actually we can deduce a lot of useful informations using contraction as we did
in procedural definition (or module) in static sense -- analogous to the type
contraction rather than behavior specifications. The [[youtube:1eQpcms7c98&t=635s][lecture]] explains this
concept consistently through this term of lectures.

So using the static information (deduced by static analysis by human not the
machine; thus for human), we can put together all the relevant parts into one
chuck along with the contracts not only in the high level language also in this
very low level assembly language uniformly.
** The Core of the Explicit-Control Evaluator
** Sequence Evaluation and Tail Recursion
To deal with the tail recursion, we need to handle the last expression in the
evaluation of sequence differently.
** Conditionals, Assignments, and Definitions
*** Exercise 5.23
#+BEGIN_SRC scheme
,*** in explicit control evaluator controller
    ;; Exercise 5.23 -- derived forms
    (test (op cond?) (reg exp))
    (branch (label ev-cond))
    (test (op let?) (reg exp))
    (branch (label ev-let))
    (test (op let*?) (reg exp))
    (branch (label ev-let*))
    ;; end of exercise 5.23
...
    (branch (label ev-application))
    (goto (label unknown-expression-type))


    ;; derived forms
    ev-cond
    (assign exp (op cond->if) (reg exp))
    (goto (label ev-if))
    ev-let
    (assign exp (op let->combination) (reg exp))
    (goto (label ev-application))
    ev-let*
    (assign exp (op let*->let) (reg exp))
    (goto (label ev-let))
    ;;
#+END_SRC

Here we used the assumption or "cheat," which isn't actually cheat according to
the footnote in the text. This is due to the analysis phase in our interpreter
as noted in section 4.1.4; all the expression analyzed statically and the source
level transformation is one of the static process, it is done at that phase. We
can verify this fact -- our interpreter do the static analysis before execution
-- with the following example:
#+BEGIN_SRC scheme
(lambda (x) (define y 5) (define y 2) x)

;duplicate internal definitions for (#[uninterned-symbol 38 y]) in |#[unnamed-procedure]|
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

If it were not doing the static analysis, it couldn't the duplicated internal
definitions since it is the body of lambda expression, which is not supposed to
be evaluated until it is applied.

Then test:
#+BEGIN_SRC scheme
(start eceval)

;;; EC-Eval input:
(cond (false 5) (false 2) (true 3) (else 1))

(total-pushes = 9 maximum-depth = 3)
;;; EC-Eval value:
3

;;; EC-Eval input:
(let* ((x 5) (y (+ x 2))) (+ x y))

(total-pushes = 26 maximum-depth = 8)
;;; EC-Eval value:
12

#+END_SRC
*** Exercise 5.24
=Cond= special form is like combination of =ev-if= and =ev-application=. That is
it need to loop through the clauses and for each clause like =evl-application=
loop through in =ev-appl-operand-loop=, and within that loop, it need to branch
depending on the evaluation of =cond-predicate= of each clause as =ev-if= did,
if it were true, it need to setup to call =ev-sequence= as
=ev-appl-accum-last-arg= did.

Here is the register code do the works:
#+BEGIN_SRC scheme
ev-cond
;; Input exp env continue
;; Output val
;; Write all (call the ev-sequence)
;; Stack unchanged
    (assign unev (op cond-clauses) (reg exp))
    (save continue)
cond-clause-loop
;; Input unev env stack (top as return point)
;; Output val
;; Write all
;; Stack top value removed
    (assign exp (op cond-first-clause) (reg unev))
    (test (op cond-else-clause?) (reg exp))
    (branch (label cond-else-clause))
    (test (op cond-last-clause?) (reg unev))
    (branch (label cond-last-clause))
cond-pred
    (save unev)
    (save exp)
    (save env)
    (assign exp (op cond-predicate) (reg exp))
    (assign continue (label cond-pred-decide))
    (goto (label eval-dispatch))
cond-pred-decide
    (restore env)
    (restore exp)
    (restore unev)
    (test (op true?) (reg val))
    (branch (label cond-actions))
    (assign unev (op cond-rest-clauses) (reg unev))
    (goto (label cond-clause-loop))
cond-actions
;; Input exp, env
;; Output val
;; Write all
;; Stack top removed
    (assign unev (op cond-actions) (reg exp))
    (goto (label ev-sequence))
cond-else-clause
    (test (op cond-last-clause?) (reg unev))
    (test (op not) (reg flag))
    (branch (label bad-cond-syntax))
    (goto (label cond-actions))
cond-last-clause
    (save exp)
    (save env)
    (assign exp (op cond-predicate) (reg exp))
    (assign continue (label cond-last-decide))
    (goto (label eval-dispatch))
cond-last-decide
    (restore env)
    (restore exp)
    (test (op true?) (reg val))
    (branch (label cond-actions))
    (restore continue)
    (goto (reg continue))
#+END_SRC

Now it works as expected:
#+BEGIN_SRC scheme
(start eceval)


;;; EC-Eval input:
(cond (false 5) (false 2) (true 3) (else 1))

(total-pushes = 10 maximum-depth = 4)
;;; EC-Eval value:
3

#+END_SRC

Now test the tail recursion problem:
#+BEGIN_SRC scheme
;;; from recitation 26 of 2004
(define (list? x)
  (cond ((null? x) true)
        ((pair? x) (list? (cdr x)))))
(define z (list 1))
(set-cdr! z z)
(list? z)
#+END_SRC

Then
#+BEGIN_SRC scheme
;;; EC-Eval input:
(define z (list 1))

(total-pushes = 8 maximum-depth = 6)
;;; EC-Eval value:
ok

;;; EC-Eval input:
(set-cdr! z z)

(total-pushes = 8 maximum-depth = 5)
;;; EC-Eval value:
#!unspecific

;;; EC-Eval input:
(list? z)
  C-c C-c;Quit!
#+END_SRC

Works as expected.
*** Exercise 5.25
As we learned from section 4.2, the only change is the application from the
applicative Scheme.

That is, rather than evaluating all the operands before application, we need to
hand over the operands without evaluating since the operands needed are
different in primitive procedure's from compound procedure's.

We also need to support additional data structure called thunk since it is
needed to distinguish the delayed object from the normal values.

Also we need to handle the =if= expression somewhat differently from the
applicative one since it need =actual-value= for value of its predicate part.

Note that we can not assume the =actual-value= (implicitly =force-it= too) is
available as machine operations as the text did; we need to unwind those
procedure explicitly into register subroutines since =actual-value= and
=force-it= wrapping around the =eval= process in it. So we need to unwrap those
until we got the procedures that does not inherit the any other process that is
implemented as subroutines in our register machine (but we are good to use the
=delay-it= procedure since it is just syntactic procedure or representation of
thunk ADT).

So to summarize, we can assume the following procedures as machine operators:
#+BEGIN_SRC scheme
;; Exercise 5.25 delayed one
(define (delay-it exp env)
  (list 'thunk exp env))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

;; "thunk" that has been forced and is storing its (memoized) value
(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
#+END_SRC

But we should implement the following ones as subroutines:
#+BEGIN_SRC scheme
(define (actual-value exp env)
  (force-it (eval exp env)))

(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)  ; replace exp with its value
           (set-cdr! (cdr obj) '())     ; forget unneeded env
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
#+END_SRC

Here is the code translated. Observe the similarity of the accumulation argument
loop between the primitive and compound one -- it is more easy to see in above
high level language description; if we want to do, we could have modulate the
duplicate code into one general subroutine which will accept more arguments as
input registers or on stack. We will come back this issue in later.

#+BEGIN_SRC scheme
ev-application
    (save continue)
    (save env)
    (assign unev (op operands) (reg exp))
    (save unev)
    (assign exp (op operator) (reg exp))
    (assign continue (label ev-appl-did-operator))
    (goto (label actual-value))
ev-appl-did-operator
    (restore unev)
    (restore env)
    (assign proc (reg val))
    (branch (label apply-dispatch))

apply-dispatch
    (assign argl (op empty-arglist))
;; Input proc, unev, env, stack -- top value is return point
;; Output val
;; Write all
;; Stack top value removed
    (test (op primitive-procedure?) (reg proc))
    (branch (label primitive-apply))
    (test (op compound-procedure?) (reg proc))
    (branch (label compound-apply))
    (goto (label unknown-procedure-type))

primitive-apply
    (test (op no-operands?) (reg unev))
    (branch (label exec-primitive-apply))
    (save proc)
primitive-operand-loop
    (save argl)
    (assign exp (op first-operand) (reg unev))
    (test (op last-operand?) (reg unev))
    (branch (label prim-last-arg))
    (save env)
    (save unev)
    (assign continue (label prim-accumulate-arg))
    (goto (label actual-value))
prim-accumulate-arg
    (restore unev)
    (restore env)
    (restore argl)
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (assign unev (op rest-operands) (reg unev))
    (goto (label primitive-operand-loop))
prim-last-arg
    (assign continue (label prim-accum-last-arg))
    (goto (label actual-value))
prim-accum-last-arg
    (restore argl)
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (restore proc)
    (goto (label exec-primitive-apply))
exec-primitive-apply
    (assign val (op apply-primitive-procedure)
        (reg proc)
        (reg argl))
    (restore continue)
    (goto (reg continue))

compound-apply
    (test (op no-operands?) (reg unev))
    (branch (label exec-compound-apply))
compound-operand-loop
    (assign exp (op first-operand) (reg unev))
    (test (op last-operand?) (reg unev))
    (branch (label compound-last-arg))
    (assign val (op delay-it) (reg exp) (reg env))
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (assign unev (op rest-operands) (reg unev))
    (goto (label compound-operand-loop))
compound-last-arg
    (assign val (op delay-it) (reg exp) (reg env))
compound-accum-last-arg
    (assign argl (op adjoin-arg) (reg val) (reg argl))
    (goto (label exec-compound-apply))

exec-compound-apply
    (assign unev (op procedure-parameters) (reg proc))
    (assign env (op procedure-environment) (reg proc))
    (assign env (op extend-environment)
        (reg unev) (reg argl) (reg env))
    (assign unev (op procedure-body) (reg proc))
    (goto (label ev-sequence))

ev-if
    (save exp)
    (save env)
    (save continue)
    (assign continue (label ev-if-decide))
    (assign exp (op if-predicate) (reg exp))
    (goto (label actual-value))
ev-if-decide
    (restore continue)
    (restore env)
    (restore exp)
    (test (op true?) (reg val))
    (branch (label ev-if-consequent))
ev-if-alternative
    (assign exp (op if-alternative) (reg exp))
    (goto (label eval-dispatch))
ev-if-consequent
    (assign exp (op if-consequent) (reg exp))
    (goto (label eval-dispatch))

actual-value
;; contract is same as eval-dispatch
    (save continue)
    (assign continue (label after-eval))
    (goto (label eval-dispatch))
after-eval
    (restore continue)
    (goto (label force-it))

force-it
;; Input val continue
;; Output val
;; Write all
;; Stack unchanged
    (test (op thunk?) (reg val))
    (branch (label force-thunk))
    (test (op evaluated-thunk?) (reg val))
    (branch (label force-evaluated))
    (goto (reg continue))

force-thunk
    (save continue)
    (save val)                              ;need later -- obj
    (assign continue (label force-result))
    (assign exp (op thunk-exp) (reg val))
    (assign env (op thunk-env) (reg val))
    (goto (label actual-value))

force-result
    (restore exp)                           ;clobbering the exp as obj
    (restore continue)
    (perform (op set-car!) (reg exp) (const evaluated-thunk))
    (assign exp (op cdr) (reg exp))
    (perform (op set-car!) (reg exp) (reg val))
    (perform (op set-cdr!) (reg exp) (const ()))
    (goto (reg continue))

force-evaluated
    (assign val (op thunk-value) (reg val))
    (goto (reg continue))
#+END_SRC

Now let's test:
#+BEGIN_SRC scheme
(start eceval)


;;; EC-Eval input:
(define (try a b)
  (if (= a 0) 1 b))

(total-pushes = 3 maximum-depth = 3)
;;; EC-Eval value:
ok

;;; EC-Eval input:
(try 0 (/ 1 0))

(total-pushes = 22 maximum-depth = 12)
;;; EC-Eval value:
1

#+END_SRC

It works as expected.
** Running the Evaluator
*** Exercise 5.26
**** a.
Since the defined procedure captured iterative process, we expect, if our
register machine handles the tail recursion correctly, the maximum stack depth
would not change:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(factorial 5)

(total-pushes = 204 maximum-depth = 10)
;;; EC-Eval value:
120

;;; EC-Eval input:
(factorial 3)

(total-pushes = 134 maximum-depth = 10)
;;; EC-Eval value:
6

;;; EC-Eval input:
(factorial 30)

(total-pushes = 1079 maximum-depth = 10)
;;; EC-Eval value:
265252859812191058636308480000000

#+END_SRC

And it turns out 10.
**** b.
From those data, and as it is linear, we can deduce the formular as $P(n) = 35n+29$.
*** Exercise 5.27
Here is the data:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(factorial 3)

(total-pushes = 80 maximum-depth = 18)
;;; EC-Eval value:
6

;;; EC-Eval input:
(factorial 10)

(total-pushes = 304 maximum-depth = 53)
;;; EC-Eval value:
3628800

;;; EC-Eval input:
(factorial 30)

(total-pushes = 944 maximum-depth = 153)
;;; EC-Eval value:
265252859812191058636308480000000

#+END_SRC

From this fact, we can deduce the =maximum-depth= as $5n + 3$, and
=total-pushes= as $32n - 16$.

So the table gets as

|           | Maximum depth | Number of pushes |
|-----------+---------------+------------------|
| Recursive | 5n + 3        | 32n - 16         |
| factorial |               |                  |
|-----------+---------------+------------------|
| Iterative | 10            | 35n + 29         |
| factorial |               |                  |
*** Exercise 5.28
Let's modify our register machine not to be tail recursive. Then let's re-run
[[Exercise 5.26][exercise 5.26]]'s factorial -- iterative one:
#+BEGIN_SRC scheme
;;; EC-Eval input:
(factorial 5)

(total-pushes = 218 maximum-depth = 29)
;;; EC-Eval value:
120

;;; EC-Eval input:
(factorial 3)

(total-pushes = 144 maximum-depth = 23)
;;; EC-Eval value:
6

;;; EC-Eval input:
(factorial 30)

(total-pushes = 1143 maximum-depth = 104)
;;; EC-Eval value:
265252859812191058636308480000000
#+END_SRC

Now the =maximum-depth= gets $3n+14$ not the constant 10 and =total-pushes= gets
$37n + 33$, which is definitely large number than previous one.

How about the recurvise definition?
#+BEGIN_SRC scheme
;;; EC-Eval input:
(factorial 3)

(total-pushes = 86 maximum-depth = 27)
;;; EC-Eval value:
6

;;; EC-Eval input:
(factorial 10)

(total-pushes = 324 maximum-depth = 83)
;;; EC-Eval value:
3628800

;;; EC-Eval input:
(factorial 30)

(total-pushes = 1004 maximum-depth = 243)
;;; EC-Eval value:
265252859812191058636308480000000
#+END_SRC

As expected this one also has involved more stack operations than previous since
this version of evaluator execute instructions that is useless.
