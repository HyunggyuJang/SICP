#+TITLE: Metalinguistic Abstraction
/Metalinguistic Abstraction/ -- establishing new languages -- plays an important
role in all branches of engineering design. It is particularly important to
computer programming, because in programming /not only can we formulate new
languages but we can also implement these languages by constructing evaluators/.

* The Metacircular Evaluator
** The Core of the Evaluator
In this section we use the syntax operations (the representation for the syntax
of language being implemented) to implement the =eval= and =apply= process. Our
evaluator uses several ADTs each for syntax for language being implemented and the
internal representations for internal evaluation model -- environment.
*** Exercise 4.1
We can force the order by using =let= statement -- since it is just syntactic
sugar for lambda application, the value of each bindings of =let= expression
evaluated before evaluating the body of it.
#+BEGIN_SRC scheme
;;; Left to Right
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((first (eval (first-operand exps) env)))
        (cons first
              (list-of-values (rest-operands exps) env)))))
;;; Right to Left
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((rest (list-of-values (rest-operands exps) env)))
        (cons (eval (first-operand exps) env)
              rest))))
#+END_SRC
** Representing Expressions
It is reminiscent of the symbolic differentiation program discussed in section
2.3.2; each expression has its own type tag in it, so our evaluator dispatch on
this type and recursively evaluate the nested expression.
*** Exercise 4.2
**** a.
It will deal the assignment expression as if it is procedure application since
procedure application expression doesn't have any type for specifying it so any
the pairs not sifted by the =cond= clauses before that clause treated as
procedure application. So =(define x 3)= are treated procedure application and,
in turn, evaluator lookup the =define= variable; since it couldn't find any it
will signal error -- undefined variable.
**** b.
Here is the fix:
#+BEGIN_SRC scheme
(define (application? exp) (tagged-list? exp 'call))
#+END_SRC
*** Exercise 4.3
We can rely on the data-directed style only for the tagged expressions:
#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        (else
         (let ((op (and (tagged-exp? exp)
                        (get 'eval (type-tag exp)))))
           (cond (op (op exp env))
                 ((application? exp)
                  (apply (eval (operator exp) env)
                         (list-of-values (operands exp) env)))
                 (else
                  (error "Unknown expression type -- EVAL" exp)))))))
#+END_SRC

The procedures of =tagged-exp= ADT:
#+BEGIN_SRC scheme
(define (type-tag exp)
  (car exp))
(define (tagged-exp? exp)
  (pair? exp))
#+END_SRC

Then install the contents:
#+BEGIN_SRC scheme
(define (install-eval-clauses)
  (put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
  (put 'eval 'set! eval-assignment)
  (put 'eval 'define eval-definition)
  (put 'eval 'if eval-if)
  (put 'eval 'lambda (lambda (exp env)
                       (make-procedure (lambda-parameters exp)
                                       (lambda-body exp)
                                       env)))
  (put 'eval 'begin (lambda (exp env)
                      (eval-sequence (begin-actions exp) env)))
  (put 'eval 'cond (lambda (exp env)
                     (eval (cond->if exp) env)))
  'done)
#+END_SRC

I've implemented the type tags directly for simplicity.
*** Exercise 4.4
**** As special expression
#+BEGIN_SRC scheme
(define (install-eval-and-or-direct)
  ;; and eval
  (define (eval-and exp env)
    (eval-and-subs (subexps exp) env))
  (define (eval-and-subs subs env)
    (cond ((null? subs) (eval 'true env))
          ((last-sub? subs) (eval (first subs) env))
          (else
           (if (true? (eval (first-sub subs) env))
               (eval-and-subs (rest-subs subs) env)
               (eval 'false env)))))

  ;; or eval
  (define (eval-or exp env)
    (eval-or-subs (subexps exp) env))
  (define (eval-or-subs subs env)
    (cond ((null? subs) (eval 'false env))
          ((last-sub? subs) (eval (first subs) env))
          (else
           (let ((current
                  (eval (first-sub subs) env)))
             (if (false? current)
                 (eval-or-subs (rest-subs subs) env)
                 current)))))

  ;; selector on And or Or expression
  (define (subexps exp) (cdr exp))
  ;; sub ADT
  (define (last-sub? subs)
    (and (pair? subs) (null? (cdr subs))))
  (define first-sub car)
  (define rest-subs cdr)

  ;; interface with eval procedure
  (put 'eval 'and eval-and)
  (put 'eval 'or eval-or)
  'done)
#+END_SRC

Here we used data-directed style =eval= from [[Exercise 4.3][ex 4.3]].

Then setup for test:
#+BEGIN_SRC scheme
(define eval-table (make-hash-table))
(define (put op type item)
  (if (eq? op 'eval)
      (hash-table-set! eval-table type item)
      (error "Unallowed operation -- PUT" op)))
(define (get op type)
  (if (eq? op 'eval)
      (hash-table-ref eval-table type (lambda () #f))
      (error "Unknown operation -- GET" op)))
#+END_SRC

Let's run!
#+BEGIN_SRC scheme
1 ]=> (install-eval-clauses)

;Value: done

1 ]=> (install-eval-and-or-direct)

;Value: done

1 ]=> (driver-loop)

;;; M-Eval input:
(and)

;;; M-Eval value:
#t

;;; M-Eval input:
(and 5)

;;; M-Eval value:
5

;;; M-Eval input:
(and false)

;;; M-Eval value:
#f

;;; M-Eval input:
(and false 5 2)

;;; M-Eval value:
#f

;;; M-Eval input:
(and 5 2)

;;; M-Eval value:
2

;;; M-Eval input:
(and 5 false)

;;; M-Eval value:
#f

;;; M-Eval input:
(or)

;;; M-Eval value:
#f

;;; M-Eval input:
(or 5)

;;; M-Eval value:
5

;;; M-Eval input:
(or false 5 false flase)

;;; M-Eval value:
5

;;; M-Eval input:
(or false 5 false)

;;; M-Eval value:
5

;;; M-Eval input:
(or false false 5)

;;; M-Eval value:
5

#+END_SRC

Or we could test this in unit:
#+BEGIN_SRC scheme
(install-eval-clauses)

;Value: done

(install-eval-and-or-direct)

;Value: done

(eval '(and 5) the-global-environment)

;Value: 5

(eval '(and false 5) the-global-environment)

;Value: #f

(eval '(or 5 false) the-global-environment)

;Value: 5
#+END_SRC
**** As derived expression
This is analogous to =cond=:
#+BEGIN_SRC scheme
define (install-eval-and-or-derived)
  (define (expand-or-subs subs)
    (cond ((null? subs) 'false)
          ((null? (cdr subs)) (car subs))
          (else
           (let ((first (car subs)))
             (make-let
              (list (list 'first first))
              (list (make-if 'first
                        'first
                        (expand-or-subs (cdr subs)))))))))
  (define (expand-and-subs subs)
    (cond ((null? subs) 'true)
          ((null? (cdr subs)) (car subs))
          (else
           (make-if (car subs)
                    (expand-and-subs (cdr subs))
                    'false))))

  (define (and->if exp)
    (expand-and-subs (cdr exp)))

  (define (or->if exp)
    (expand-or-subs (cdr exp)))

  (put 'eval 'and (lambda (exp env)
                    (eval (and->if exp) env)))
  (put 'eval 'or (lambda (exp env)
                   (eval (or->if exp) env)))
  'done)
#+END_SRC
For =or=, we used =make-let= to reuse the result of evaluation of first
subexpression in case where it turns out true.

Here is =make-let= syntax procedure that is analogous to =make-lambda=
#+BEGIN_SRC scheme
;; List<binding>, List<expression> -> Let
(define (make-let bindings body)
  (cons 'let (cons bindings body)))
#+END_SRC

Then test!
#+BEGIN_SRC scheme
(install-eval-and-or-derived)

;Value: done

(eval '(and 5) the-global-environment)

;Value: 5

(eval '(and false 5) the-global-environment)

;Value: #f

(eval '(and true 2 true) the-global-environment)

;Value: #t
#+END_SRC

For the =or= part, we delegate the test until we implement the =let= expression
in our evaluator ([[Exercise 4.6][ex 4.6]])
*** Exercise 4.5
We can support this new feature through either special form or derived form. The
key issue is that is it okay re-evaluate the =<test>= expression twice?
- If it is okay, the only change that we should make is the =sequence->exp= part
  of =expand-clauses= into
  #+BEGIN_SRC scheme
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (cond-actions->exp first)
                     (expand-clauses rest))))))

(define (cond-actions->exp clause)
  (let ((actions (cond-actions clause)))
    (if (eq? (car actions) '=>)
        (if (and (pair? (cdr actions))
                 (null? (cddr actions)))
            (list (cadr actions) (cond-predicate clause))
            (error "Illformed expression -- COND-MAP" clause))
        (sequence->exp actions))))
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr)
                         (else false)) the-global-environment)

;Value: 4

(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Illformed expression -- COND-MAP ((cons 3 4) => cdr 3)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC
- If it is not, in other word, we are constrained to evaluate the =cond-predicate=
  only once, we do use =make-let= as we did in the previous exercise.
  #+BEGIN_SRC scheme
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (let ((pred (cond-predicate first)))
              (make-let
               (list (list 'pred pred))
               (list (make-if 'pred
                              (map-or-sequence->exp
                               (cond-actions first) 'pred)
                              (expand-clauses rest)))))))))

(define (map-or-sequence->exp actions pred)
  (if (eq? (car actions) '=>)
      (if (and (pair? (cdr actions))
               (null? (cddr actions)))
          (list (cadr actions) pred)
          (error "Illformed expression -- COND-MAP" clause))
      (sequence->exp actions)))
  #+END_SRC
*** Exercise 4.6
#+BEGIN_SRC scheme
(define (install-eval-let)
  (define (let->combination exp)
    (let* ((bindings (bindings exp))
           (unziped-b
            (fold-right
             (lambda (var-exp vars-exps)
               (cons (cons (car var-exp) (car vars-exps))
                     (cons (cadr var-exp) (cdr vars-exps))))
             (cons '() '())
             bindings))
           (params (car unziped-b))
           (exps (cdr unziped-b)))
      (cons (make-lambda params (body exp))
            exps)))

  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let (lambda (exp env)
                    (eval (let->combination exp) env)))
  'done)
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(eval '(let ((x 1)) (cons x 2)) the-global-environment)

;Value: (1 . 2)

(eval '(let ((x 1)) (cons x 2) (cons 2 x)) the-global-environment)

;Value: (2 . 1)
#+END_SRC

Then now we can test the =or= of derived version:
#+BEGIN_SRC scheme
(install-eval-and-or-derived)

;Value: done

(eval '(or 5 false) the-global-environment)

;Value: 5

(eval '(or false 5 false) the-global-environment)

;Value: 5
#+END_SRC

And derived =cond='s new feature:
#+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr)
                         (else false)) the-global-environment)

;Value: 4

(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Unbound variable: clause
#+END_SRC
By test it we found the bug in our previous error handling. It is easy to fix.
After fixing,
#+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Illformed expression -- COND-MAP (=> cdr 3)
#+END_SRC
It works as expected.
*** Exercise 4.7
#+BEGIN_SRC scheme
(define (install-eval-let*)
  (define (let*->let exp)
    (define (expand-let* bindings)
      (if (null? bindings)
          (body exp)
          (let ((first (car bindings))
                (rest (cdr bindings)))
            (make-let
             (list first)
             ((if (null? rest)
                  identity-procedure
                  list) ;for the type contraction of make-let
              (expand-let* rest))))))
    (expand-let* (bindings exp)))
  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let* (lambda (exp env)
                     (eval (let*->let exp) env)))
  'done)
#+END_SRC
It suffices to define =let*= as derived expression since subsequent derived
expression reduced to non-derived expression by =eval= and =apply= loop, which
in turn reduced to primitive expressions.

Then test:
#+BEGIN_SRC scheme
(install-eval-let*)

;Value: done

(eval
 '(let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))
 the-global-environment)

;Value: 39
#+END_SRC
*** Exercise 4.8
First let we code the test:
#+BEGIN_SRC scheme
(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)
;; ok
(eval
 '(fib 3)
 the-global-environment)
;; 1
#+END_SRC

And note that by using the environment model, we can deduce named let expression
=(let <var> <bindings> <body>)= is equivalent to
#+BEGIN_SRC scheme
(let ((<var> undef))
  (set! <var>
    (lambda <params of bindings> body))
  (apply <var> <exps of bindings>))
#+END_SRC

So we convert named let expression above equivalent expression.

Here is the result:
#+BEGIN_SRC scheme
(define (install-eval-let-with-named)
  ;; ADT for named
  (define (named? exp)
    (and (pair? exp)
         (pair? (cdr exp))
         (symbol? (cadr exp))))

  (define (named exp)
    (cadr exp))

  (define (except-name-let exp)
    (cdr exp))

  (define (let->combination exp)
    (let* ((bindings (bindings exp))
           (unziped-b
            (fold-right
             (lambda (var-exp vars-exps)
               (cons (cons (car var-exp) (car vars-exps))
                     (cons (cadr var-exp) (cdr vars-exps))))
             (cons '() '())
             bindings))
           (params (car unziped-b))
           (exps (cdr unziped-b)))
      (cons (make-lambda params (body exp))
            exps)))

  (define (named->let-combination exp)
    (let ((var (named exp))
          (comb (let->combination
                 (except-name-let exp))))
      (let ((lambda-part (car comb))
            (exps (cdr comb)))
        (make-let
         (list (list var (list 'quote undef)))
         (list
          (make-assignment var
                           lambda-part)
          (cons var
                exps))))))

  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let (lambda (exp env)
                    (eval (if (named? exp)
                              (named->let-combination exp)
                              (let->combination exp)) env)))
  'done)
#+END_SRC

And the auxiliary parts:
#+BEGIN_SRC scheme
(define undef '*unassigned*)
(define (make-assignment var val)
  (list 'set! var val))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
(install-eval-let-with-named)

;Value: done

(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)

;Value: ok

(eval
 '(fib 3)
 the-global-environment)

;Unbound variable =
#+END_SRC

Huh, we should set ~=~ (and also =-=) as primitive procedure in our environment.
Do that and re-run:
#+BEGIN_SRC scheme
(install-eval-clauses)

;Value: done

(install-eval-let-with-named)

;Value: done

(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)

;Value: ok

(eval
 '(fib 3)
 the-global-environment)

;Value: 2

(eval
 '(fib 2)
 the-global-environment)

;Value: 1
#+END_SRC

Oh-huh there are good news and bad news:
- Our test code was wrong! =(fib 3)= should return 2 not 1 as it count from 0!
- Our code works right!

*** Exercise 4.9
For example, here we try to implement typical imperative control structure,
=while=. Let us think about the what syntax should it be? Analogous to any other
imperative programming language, let we make our syntax as follows:
#+BEGIN_SRC scheme
(while <pred>
  <exp1>
  ...
  <expN>)
#+END_SRC

The semantic of this control structure are followings:
1. Evaluate =<pred>= first.
2. If it true, execute from =<exp1>= until =<expN>= sequentially; Then go to *1.*
3. If it was false, then return the control to consequent structure (return
   undefined value).


All of the above expressions should be evaluated in a same environment; we don't
need to extend the given environment.

Then here is the code:
#+BEGIN_SRC scheme
(define (install-eval-while)
  (define pred cadr)
  (define body cddr)
  (define (eval-while exp env)
    (let ((bexp (sequence->exp (body exp))))
      (let loop ()
        (if (true? (eval (pred exp) env))
            (begin (eval bexp env)
                   (loop))
            'done))))
  (put 'eval 'while eval-while)
  'done)
#+END_SRC

Then here is the test code:
#+BEGIN_SRC scheme
(eval '(begin
         (define x 5)
         (define sum 0)
         (while (> x 0)
           (set! sum (+ x sum))
           (set! x (-1+ x)))
         sum)
      the-global-environment)
;Should return 15
#+END_SRC

And run:
#+BEGIN_SRC scheme
(eval '(begin
         (define x 5)
         (define sum 0)
         (while (> x 0)
           (set! sum (+ x sum))
           (set! x (-1+ x)))
         sum)
      the-global-environment)

;Value: 15
#+END_SRC

Sweet!
*** Exercise 4.10
Here we will use dispatch on type rather than data-directed style since we are
going to mix the infix expressions with prefix expressions. Specifically we will
transform the assignment notation and that of definition into infix notation:
- From =(set! <var> <exp>)= to =(<var> <- <exp>)=;
- From =(define <var> <exp>)= to =(<var> = <exp>)=.


All we need to change is the detectors and selectors:
- From
  #+BEGIN_SRC scheme
;; detector
(define (assignment? exp)
  (tagged-list? exp 'set!))

;; selectors
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
  #+END_SRC
  to
  #+BEGIN_SRC scheme
;; detector
(define (assignment? exp)
  (infix-tag-list? exp '<-))

;; selectors
(define (assignment-variable exp) (car exp))
(define (assignment-value exp) (caddr exp))
  #+END_SRC
- From
  #+BEGIN_SRC scheme
;; detector
(define (definition? exp)
  (tagged-list? exp 'define))

;; selectors
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))
  #+END_SRC
  to
  #+BEGIN_SRC scheme
;; detector
(define (definition? exp)
  (infix-tag-list? exp '=))

;; selectors
(define (definition-variable exp)
  (if (symbol? (car exp))
      (car exp)
      (caar exp)))
(define (definition-value exp)
  (if (symbol? (car exp))
      (caddr exp)
      (make-lambda (cdar exp)
                   (cddr exp))))
  #+END_SRC


Then the test code:
#+BEGIN_SRC scheme
;; Test infix defintion
(eval '(begin (x = 2)
              x)
      the-global-environment)
;; 2
;; procedure definition
(eval
 '((factorial n) = (if (= n 1)
                       1
                       (* n (factorial (-1+ n)))))
 the-global-environment)
;; ok
(eval '(factorial 3) the-global-environment)
;; 6


;; test infix assignment
(eval '(begin (x <- 5)
              x)
      the-global-environment)
;; 5
#+END_SRC

Then let's run
#+BEGIN_SRC scheme
(eval '(begin (x = 2)
              x)
      the-global-environment)

;Value: 2

(eval
 '((factorial n) = (if (= n 1)
                       1
                       (* n (factorial (-1+ n)))))
 the-global-environment)

;Value: ok

(eval '(factorial 3) the-global-environment)

;Value: 6

(eval '(begin (x <- 5)
              x)
      the-global-environment)

;Value: 5
#+END_SRC
** Evaluator Data Structures
*** Exercise 4.11
This is same as replace our frame data structure with table as we did in section
3.3. Then the changes are trivial:
#+BEGIN_SRC scheme
;; For extend-environment
(define (make-frame vars vals)
  (let ((bindings
         ;; provided that the length of both arguments match
         (fold-right
          (lambda (var val bindings)
            (cons (list var val) bindings))
          '()
          vars
          vals))
        (tbl (make-table)))
    (set-bindings! tbl bindings)
    tbl))

;; Table ADT
;; constructor
(define (make-table)
  (list '*table*))
;; mutator
(define set-bindings! set-cdr!)
;; selector
(define bindings cdr)

;; For lookup-variable-value
(define (lookup-variable-value var env)
  (let env-loop ((env env))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (cond ((assoc var (bindings frame)) => cadr)
                (else (env-loop
                       (enclosing-environment env))))))))

;; For set-variable-value!
(define (set-variable-value! var val env)
  (let env-loop ((env env))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (cond ((assoc var (bindings frame))
                 => (lambda (b) (set-car! (cdr b) val)))
                (else (env-loop
                       (enclosing-environment env))))))))

;; For define-variable!
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (cond ((assoc var (bindings frame))
                 => (lambda (b) (set-car! (cdr b) val)))
          (else (set-bindings! frame
                               (cons (list var val)
                                     (bindings frame)))))))
#+END_SRC

By using the built in procedures about the alist structure, we could write our
procedures more succinctly; this leads that we recognize the common patterns in
above procedures more obviously, which we revisit in the next exercise.

Return to our discourse, let we code the test:
#+BEGIN_SRC scheme
;; test definition
(eval '(define test-def 0) the-global-environment)
;; ok

;; test assignment in nested frame
(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)
;; ok

(eval 'test-def the-global-environment)
;; 0

(eval '(test-assignment) the-global-environment)
;; ok

;; test lookup-variable-value
(eval 'test-def the-global-environment)
;; 5

;; verify that we using the new data structure for frame
(caar the-global-environment)
;; *table*
#+END_SRC

Then run:
#+BEGIN_SRC scheme
(eval '(define test-def 0) the-global-environment)

;Value: ok

(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 0

(eval '(test-assignment) the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 5

(caar the-global-environment)

;Value: *table*
#+END_SRC
*** Exercise 4.12
We can capture the common pattern first by recognizing the same code in those
code and then refine them with their role of behavior, namely traversing given
frame and traversing given environment:
#+BEGIN_SRC scheme
;; Var, (Vals -> Any) -> FrameOp
(define (find-var-and-apply-in-frame var vals-op)
  (lambda (null-op frame)
    (let scan ((vars (frame-variables frame))
               (vals (frame-values frame)))
      (cond ((null? vars)
             (null-op))
            ((eq? var (car vars))
             (vals-op vals))
            (else (scan (cdr vars) (cdr vals)))))))

;; FrameOp, void -> Any, Env
;; -> Any
(define (traverse-env-using frame-op empty-env-op env)
  (if (eq? env the-empty-environment)
      (empty-env-op)
      (frame-op (first-frame env)
                (lambda () (traverse-env-using frame-op empty-env-op
                                               (enclosing-environment env))))))
#+END_SRC
Here we, for interfacing the traverser on environment with traverser on frame,
defined new data type, namely =FrameOp= -- ~FrameOp := Frame, NullOp -> Any~,
~NullOp := void -> Any~.

Then our operations on environments get
#+BEGIN_SRC scheme
(define (lookup-variable-value var env)
  (traverse-env-using
   (find-var-and-apply-in-frame var car)
   (lambda () (error "Unbound variable" var))
   env))

(define (set-variable-value! var val env)
  (traverse-env-using
   (find-var-and-apply-in-frame
    var
    (lambda (vals) (set-car! vals val)))
   (lambda () (error "Unbound variable -- SET!" var))
   env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    ((find-var-and-apply-in-frame
      var
      (lambda (vals) (set-car! vals val)))
     (lambda ()
       (add-binding-to-frame! var val frame))
     frame)))
#+END_SRC

Then test using the test code of previous exercise:
#+BEGIN_SRC scheme
...
(eval 'test-def the-global-environment)

;The object #[compound-procedure 38], passed as the first argument to cdr, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 2) => Specify an argument to use in its place.
; (RESTART 1) => Return to read-eval-print level 1.

2 error> (pp #@38)
(lambda ()
  (traverse-env-using frame-op empty-env-op (enclosing-environment env)))
;Unspecified return value
#+END_SRC

Got error! It is due to the ill-ordered argument in =traverse-env-using=. After
fixing that we got:
#+BEGIN_SRC scheme
(eval '(define test-def 0) the-global-environment)

;Value: ok

(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 0

(eval '(test-assignment) the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 5
#+END_SRC

Our code got more cleaner and easier for us to read.
*** Exercise 4.13
As we can think of this new special form as counter expression against =define=,
let we make =make-unbound!= remove only the binding in the first frame of the
environment. To implement this feature, that is to remove specific binding in the
frame, we need to do nearly what we did in =remove-first-item= in agenda data
structure. So, we would not reuse the abstract procedure of previous exercise,
=find-var-and-apply-in-frame=; but the resulting procedure would be nearly same
as that.

To encompass this pattern, we extend =find-var-and-apply-in-frame= with:
#+BEGIN_SRC scheme
(define (find-var-and-apply-to-bindings var find-op bindings-op)
  (lambda (null-op frame)
    (let scan ((vars (frame-variables frame))
               (vals (frame-values frame)))
      (cond ((null? vars)
             (null-op))
            ((eq? var (find-op vars))
             (bindings-op vars vals))
            (else (scan (cdr vars) (cdr vals)))))))
#+END_SRC

Then we can define
#+BEGIN_SRC scheme
(define (find-var-and-apply-in-frame var vals-op)
  (find-var-and-apply-to-bindings
   var car (lambda (vars vals) (vals-op vals))))
#+END_SRC

Or it would better to refine our frame data structure by making the
=frame-variables= and =frame-values= to be headed list respectively to encompass
=make-unbound!= in our scheme uniformly.

As we defined our frame data structure abstractly, all we need to change is the
representation of frame:
#+BEGIN_SRC scheme
;; Change the representation of frame
(define (make-frame variables values)
  (cons (cons '*variables* variables)
        (cons '*values* values)))

(define (frame-variables frame) (cdar frame))
(define (frame-values (cddr frame)))
#+END_SRC

Then we exploit this idea by amending the =find-var-and-apply-to-bindings=
allowing even the selectors and detector for frame:
#+BEGIN_SRC scheme
(define (find-var-and-apply-to-bindings
         var find-op bindings-op frame-vars frame-vals empty-vars?)
  (lambda (null-op frame)
    (let scan ((vars (frame-vars frame))
               (vals (frame-vals frame)))
      (cond ((empty-vars? vars)
             (null-op))
            ((eq? var (find-op vars))
             (bindings-op vars vals))
            (else (scan (cdr vars) (cdr vals)))))))

(define (find-var-and-apply-in-frame var vals-op)
  (find-var-and-apply-to-bindings
   var car (lambda (vars vals) (vals-op vals))
   frame-variables frame-values null?))
#+END_SRC

Then we can define what we wanted:
#+BEGIN_SRC scheme
(define (unbound-variable! var val env)
  (let ((frame (first-frame env)))
    ((find-var-and-apply-to-bindings
      var cadr
      (lambda (h-vars h-vals)
        (set-cdr! h-vars (cddr h-vars))
        (set-cdr! h-vals (cddr h-vals)))
      car cdr (lambda (h-vars) (null? (cdr h-vars))))
     (lambda ()
       (error "Unbound variable in the given frame -- MAKE-UNBOUND!" var))
     frame)))

(define (install-eval-make-unbound)
  (define var cadr)
  (define val caddr)
  (put 'eval 'make-unbound!
       (lambda (exp env)
         (unbound-variable! (var exp)
                            (val exp)
                            env))))
#+END_SRC

Then let we first test the new frame data structure:
#+BEGIN_SRC scheme
(eval '(test-assignment) the-global-environment)

;Unbound variable test-assignment
#+END_SRC
Error! This is due to the =add-binding-to-frame!= as we did not updated that
procedure, which is mutator of frame structure!

Then refine the data structure for frame:
#+BEGIN_SRC scheme
;; Change the representation of frame
(define (make-frame variables values)
  (cons (cons '*variables* variables)
        (cons '*values* values)))

;; selectors for frame
(define (frame-variables frame) (cdar frame))
(define (frame-values frame) (cddr frame))

;; mutators of frame
(define (add-binding-to-frame! var val frame)
  (set-cdr! (car frame) (cons var (frame-variables frame)))
  (set-cdr! (cdr frame) (cons val (frame-values frame))))

(define (remove-binding-from-frame! var frame exception)
  ((find-var-and-apply-to-bindings
      var cadr
      (lambda (h-vars h-vals)
        (set-cdr! h-vars (cddr h-vars))
        (set-cdr! h-vals (cddr h-vals)))
      car cdr (lambda (h-vars) (null? (cdr h-vars))))
     exception
     frame))
#+END_SRC

Then our procedure get clarified as
#+BEGIN_SRC scheme
(define (unbound-variable! var env)
  (remove-binding-from-frame!
   var
   (first-frame env)
   (lambda ()
     (error "Unbound variable in the given frame -- MAKE-UNBOUND!" var))))
#+END_SRC

Re-run our test code:
#+BEGIN_SRC scheme
(eval '(define test-def 0) the-global-environment)

;Value: ok

(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 0

(eval '(test-assignment) the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 5

(eval '(make-unbound! test-def) the-global-environment)

;ok

(eval '(make-unbound! test-def) the-global-environment)

;Unbound variable in the given frame -- MAKE-UNBOUND! test-def
#+END_SRC

Works sweetly!
** Running the Evaluator as a Program
*** Exercise 4.14
1. It is because our evaluator uses data abstraction for decouple the semantics
   from syntaxes of language.
2. Combined with the *1.*, it is due to the difference of how evaluator treats
   application of compound procedure from that of primitive procedure.
3. =Map= needs to apply evaluated procedure to the each element of given list;
   but the value of that procedure is wrapped around by type-tag and it handled
   underlying Scheme's evaluator which don't know how to handle our type-tagged data.
4. So namely, it is not the procedure, which handed over to =map=, in
   implementation language but in language being implemented.
** Data as Programs
*** Exercise 4.15
We can prove this by case analysis with /reductio ad absurdum/:
- =(try try)= \to ='halted=:
  By definition of =try=, it implies that =(halts? try try)= evaluated as
  =false=. Which in turn means =(try try)= raises error or run forever by the
  definition of =halts?=; this is contradiction with our assumption -- =(try
  try)= returns ='halted=, which means it halted.
- =(try try)= \to /run forever/ or /raise error/:
  With the same argument from the previous one, it leads to contradiction with
  assumption in any case -- whether it evaluated as /run forever/ or /raise error/.
** Internal Definitions
*** Exercise 4.16
**** a.
#+BEGIN_SRC scheme
(define (lookup-variable-value var env)
  (traverse-env-using
   (find-var-and-apply-in-frame
    var
    (lambda (vals)
      (let ((val (car vals)))
        (if (eq? val undef)
            (error "Unassigned variable" var)
            val))))
   (lambda () (error "Unbound variable" var))
   env))
#+END_SRC
**** b.
I've designed in the text book with my digital paper:
#+BEGIN_SRC scheme
(define (scan-out-defines proc-body)
  (let ((extrated-exps
         ;; List<Exp> (proc-body) -> List<Exp> x List<Exp>
         ;; We implement this a little bit complicate procedure since
         ;; we want to examine possible user error --
         ;; defenstive programming.
         (fold-right
          (lambda (exp extracted)
            (if (definition? exp)
                (cons (cons exp (car extracted)) (cdr extracted))
                (if (null? (car extracted))
                    (cons (car extracted) (cons exp (cdr extracted)))
                    ;; intertwined internal definitions with others
                    (error "Internal defintions intertwins with others" proc-body))))
          (cons '() '())
          proc-body)))
    (let ((internal-defs (car extrated-exps))
          (rest-body (cdr extrated-exps)))
      (let ((vars (map definition-variable internal-defs))
            (exps (map definition-value internal-defs)))
        (let ((bindings
               (map (lambda (var) (list var (list 'quote undef)))
                    vars))
              (set-exps
               (map (lambda (var val)
                      (make-assignment var val))
                    vars
                    exps)))
          (make-let bindings (append set-exps rest-body)))))))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
;; test for scan-out-defines
(scan-out-defines
 '((define u <e1>)
   (define v <e2>)
   <e3>))
;; should return
(let ((u '*unassigned*)
      (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
#+END_SRC

Then the results:
#+BEGIN_SRC scheme
(pretty-print (scan-out-defines
               '((define u <e1>)
                 (define v <e2>)
                 <e3>)))
(let ((u '*unassigned*) (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
;Unspecified return value
#+END_SRC
as expected.
**** c.
The construction time is better. Note that it is analogous to the choice we made
when we comes with rational number arithmetic package. Since procedure is
"captured common computational process," it is supposed to be applied more than
defining ones; so by make =scan-out-defines= run in the construction time, we'll
get more efficient implementation dynamically.

Then here is the code:
#+BEGIN_SRC scheme
(define (make-procedure parameters body env)
  (list 'procedure parameters
        (scan-out-defines body)
        env))
#+END_SRC
*** Exercise 4.17
I've drawn the required diagram with my digital paper.

For the second question, first we need to recognize what the correct program is;
as jotted in the text book, correct program means what program obeyed the
described restriction -- the defined variables' values can be evaluated without
using any of variables' values. Then we can answer given question: Variables
that can be looked up in evaluating =<e3>= is same in both environment
structure; as an evaluation of any statement can not inspect the environment
directly, the behavior of both should equals among both. More formally, we can
prove the argument using the structure induction on eval/apply; that is,
evaluation of statement achieved by eval/apply, so we need to prove if all the
behavior of the program before the transformation are same, then after that
transformation the evaluation result of each clause should results in same as
before the transformation.

Lastly, we can fix this different environment structure by transforming the
internal definitions into
- Define the variables of them with =*unassigned*= then =set!= the value by
  corresponding expressions afterward, which would do not make any extra frame
  and also satisfy all the specifications described above.
- Note that this fixation does not involve any ill-defined procedure, that is
  the infinite loop where calls itself again and again.


The code:
#+BEGIN_SRC scheme
(define (scan-out-defines2 proc-body)
  (let ((extrated-exps
         ;; List<Exp> (proc-body) -> List<Exp> x List<Exp>
         ;; We implement this a little bit complicate procedure since
         ;; we want to examine possible user error --
         ;; defenstive programming.
         (fold-right
          (lambda (exp extracted)
            (if (definition? exp)
                (cons (cons exp (car extracted)) (cdr extracted))
                (if (null? (car extracted))
                    (cons (car extracted) (cons exp (cdr extracted)))
                    ;; intertwined internal definitions with others
                    (error "Internal defintions intertwines with others" proc-body))))
          (cons '() '())
          proc-body)))
    (let ((internal-defs (car extrated-exps))
          (rest-body (cdr extrated-exps)))
      (let ((vars (map definition-variable internal-defs))
            (exps (map definition-value internal-defs)))
        (let ((def-vars
               (map (lambda (var) (make-definition var (list 'quote undef)))
                    vars))
              (set-exps
               (map (lambda (var val)
                      (make-assignment var val))
                    vars
                    exps)))
          (append def-vars (append set-exps rest-body)))))))

(define (make-definition var val)
  (list 'define var val))
#+END_SRC


Then test again:
#+BEGIN_SRC scheme
(pretty-print (scan-out-defines2
               '((define u <e1>)
                 (define v <e2>)
                 <e3>)))
((define u '*unassigned*) (define v '*unassigned*) (set! u <e1>) (set! v <e2>) <e3>)
#+END_SRC
*** Exercise 4.18
This new version would not work; whereas the version in the text works. We can
reason this as follows:
#+BEGIN_SRC scheme
(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt)) ;does not evaluate dy until it need
  ;; ↑ in this block structure it never needed.
  (define dy (stream-map f y))          ;does evaluate y
  y)
#+END_SRC
1. As noted above annotation, the value expression of =dy= involves =y= and need
   to evaluate that to return the value.
2. Since in this transformation strategy does not change all the occurrence of
   =u= and =v= into =a= and =b= respectively in the =<e1>= and =<e2>= as it
   assume the restriction is obeyed, when it comes to evaluate =y= it lookup and
   signal error as it found =*unassigned*=.
3. This malfunction is due to the modification of the name of definition without
   changing all the expressions that depend on the name of internal definitions
   as we noted above.
*** Exercise 4.19
1. I myself couldn't yet be convinced by why we need to treat internal
   definitions especially; so I support Ben's view since it make me (and
   possibly other people too) easy to understand the behavior of internal
   definition in consistent manner.

   However it is trickier than it seems since the difference between procedure
   and other data. And because of the limitation of text editor environment: We
   are forced to write code in sequential manner; so it forces us to think as if
   we are dealing with sequential events. But it isn't as we discuss below.

   The above discussion is not consistent with that of mutual recursive
   procedures -- it works as if the defines evaluated simultaneously. So in
   theory Eva's view point is the most consistent one.

2. For the second question; yes, we can but it should be implemented in a error
   handling manner: If we got into unassigned value error, then try to delegate
   the execution of that assignment statement (to stack another place and try
   each of them when we reach the end of assignment statement; if there are no
   reduction in stack after one-loop finally it should raise an error -- give
   up!). This algorithm is expensive since it recursively reduces the stacked
   statements until there is no change.
*** Exercise 4.20
