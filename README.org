#+TITLE: SICP Study Note
* Building Abstractions with Data
** Hierarchical Data and the Closure Property
*** Repersenting Sequences
- Does it prints same as list to construct a sequence by conses?
  #+BEGIN_SRC scheme
(cons 1 (cons 2 (cons 3 (cons 4 '()))))
  #+END_SRC

  #+RESULTS:
  | 1 | 2 | 3 | 4 |

  #+BEGIN_SRC scheme
(list 1 2 3 4)
  #+END_SRC

  #+RESULTS:
  | 1 | 2 | 3 | 4 |

  →Yeah, looks same.
**** Exercise 2.17
#+BEGIN_SRC scheme
(define (last-pair items)               ;assume items is non empty list
  (let ((next-p (cdr items)))
    (if (null? next-p)
        items
        (last-pair next-p))))
#+END_SRC

#+RESULTS:
: #<unspecified>

Let's test with it
#+BEGIN_SRC scheme
(last-pair (list 23 72 149 34))
#+END_SRC

#+RESULTS:
| 34 |

It works.

**** Exercise 2.18
#+BEGIN_SRC scheme
(define (reverse l)
  (define (iter l r)
    (if (null? l)
        r
        (iter (cdr l) (cons (car l) r))))
  (iter l nil))                         ; we don't know what nil is but assume we have
#+END_SRC
Or do not use nil explicitly analogous to last-pair.
#+BEGIN_SRC scheme
(define (reverse l)                     ;assume that l is not empty
  (let ((next-p (cdr l)))
    (if (null? next-p)
        l
        (append (reverse next-p) (list (car l))))))
(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))
#+END_SRC

#+RESULTS:
: #<unspecified>

**** Exercise 2.19
Let's review the change-counting program. We know that the number of
change-count can be reduced as follows:
- Exchange the change using the first coin and
- not using the first coin


The above states the reductive process. To complete the whole process of it, we
need to specify the base case:
- when the amount is zero, then we have only one way to change.


It is quite tricky at first why this is true; but think it this way: simulate
the situation with some simple case,e.g. the amount is 6 cents or like that.
Then we come to realize it really need to count as 1 when amount is zero in this
recursive process.

That's not the only base case; by the reductive process we have only two cases left to consider:
- when we have 0 coins to change, we count this as 0 and
- when we have negative amount to change, there is no way to change the amount; 0.


Again, we can got the guts by simulating the simple cases or more formally we
should reason this argument using induction. I think it is reasonable to use the
computer aided proof check like this situation because humankind inherited the
error-prone property. Nonetheless let's code.

Then we can code this recursive process:
#+BEGIN_SRC scheme
(define us-coins (list 50 25 10 5 1))   ;examples of how the parameter, coin-values, constructed
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((< amount 0) 0)
        ((no- wjmore? coin-values) 0)         ;↑base cases
        (else (+ (cc (- amount
                        (first-denomination coin-values)) ;first reduction branch
                     coin-values)
                 (cc amount             ;second (last) reduction branch
                     (except-first-denomination coin-values))))))

(define (no-more? coin-values)
  (null? coin-values)) ;we could (define no-more? null?) but we don't like to mess up the debugger

(define (first-denomination coin-values)
  (car coin-values))                 ;we provided that the coin-values not empty

(define (except-first-denomination coin-values)
  (cdr coin-values))                 ;we provided that the coin-values not empty
#+END_SRC

#+RESULTS:

We can reason that the order of the list ~coin-values~ does not affect the
answer produced by cc; it just only takes more times to evaluate it.

We can assure that by experimenting with some examples:
#+BEGIN_SRC scheme :returns value
(define us-reverse (reverse us-coins))
(cc 100 us-reverse)
(cc 100 us-coins)
(cc 112 us-reverse)
(cc 112 us-coins)
#+END_SRC

#+RESULTS:

The ~us-reverse~ results to same as ~us-coins~. Why should it be?: The reductive
process and base case I've wrote above does not mention about the order of
coins; it should behave as same whatever order is.

Then how about the efficiency (complexity) of space and times? We can guess the
reversed order should be more complex than the previous case; but it is not
obvious.

Let's do some trick. While we have not studied the ~set!~ statement, but it is
useful to estimate the complexity and get some intuition about the general case:
#+BEGIN_SRC scheme
(define (cc amount coin-values)
  (define (cc-counter amount coin-values)
    (cond ((= amount 0)
           (set! count (1+ count))
           1)
          ((< amount 0)
           (set! count (1+ count))
           0)
          ((no-more? coin-values)
           (set! count (1+ count))
           0)                           ;↑base cases
          (else
           (set! count (1+ count))
           (+ (cc-counter (- amount
                     (first-denomination coin-values)) ;first reduction branch
                  coin-values)
              (cc-counter amount                ;second (last) reduction branch
                  (except-first-denomination coin-values))))))
  (define count 0)                      ;count the steps needed to evaluate cc
  (cons count (cc-counter amount coin-values))) ;return the pair of count and number of cc ways
#+END_SRC

Then we can inspect by using that:
#+BEGIN_SRC scheme
(cc 100 us-reverse)                     ;=> (38901 . 292)
(cc 100 us-coins)                       ;=> (15499 . 292)
#+END_SRC

Yeah, as we expected, the reversed version needs more than double steps than original.
How can we reason this? Let's we do some simulation with simple argument using
substitution model. After some experiment, I've realized it is hard to prove
that the reversed one has more step complexity than previous in asymptotic notation.
To prove that the reversed one has more step & space complextity, we should
prove that using inequality sign not asymptotic notation; it will convolve more
subtle argument. We should use proof assistant otherwise it become really tricky
to prove.
**** Exercise 2.20
I've started not to think about the structure. It's the evidence that I've
exhausted completely. Anyway here is the code:
#+BEGIN_SRC scheme
(define (same-parity first . rest)
  (let ((same? (if (even? first)
                   even?
                   odd?)))
    (cons first (filter same? rest))))  ;wishful tinking

(define (filter include? l)
  (if (null? l)
      l
      (let ((hd (car l))                ;it would be clearer if I use the let* notation.
            (tl (cdr l)))               ;but I've not learned yet.
        (let ((filtered
               (filter include? tl)))
          (if (include? hd)
              (cons hd filtered)
              filtered)))))
#+END_SRC
Isn't this obvious to explain? Anyway, I'll skip that.
**** Mapping over lists
#+BEGIN_SRC scheme
(define (map proc items)
  (if null? items)
  nil
  (cons (proc (car items))
        (map proc (cdr items))))
#+END_SRC
**** Exercise 2.21
#+BEGIN_SRC scheme
(define (square-list items)
  (if (null? items)
      nil
      (cons (square (car items) (square-list (cdr items))))))

(define (square-list items)
  (map square items))
#+END_SRC
**** Exercise 2.22
1. Because the structure of the helper procedure iter is same as our first
   definition of [[Exercise 2.18][reverse]].
2. List is, by definition, sequence of pairs. But the tried implementation
   returns something other than list: ~(cons answer (square (car things)))~ is
   not chained pairs.


**** Exercise 2.23
*First try*
#+BEGIN_SRC scheme
(define (for-each proc items)
  (if (null? items)                     ;base case
      true                              ;done case (termination)
.....
#+END_SRC
↑ We can not use if clause for evaluation of sequenced statement.
So we should use cond clause instead.
#+BEGIN_SRC scheme
(define (for-each proc items)
  (cond ((null? items) true)            ;termination (base) case return true, which can be arbitrary value.
        (else
         (proc (car items))
         (for-each proc (cdr items))))
#+END_SRC
Let's test it:
#+BEGIN_SRC scheme
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
#+END_SRC
Yeah works well.
*** Hierarchical Structures
Let's implement the ~count-leaves~. It should behave like follows:
#+BEGIN_SRC scheme
(define x (cons (list 1 2) (list 3 4)))
(length x)                              ;3
(count-leaves x)                        ;4
(list x x)                              ;(((1 2) 3 4) ((1 2) 3 4))
(length (list x x))                     ;2
(count-leaves (list x x))               ;8
#+END_SRC
The implementation of ~count-leaves~ is analogous to ~length~:
- ~count-leaves~ of the empty list is 0.


But in the reduction step, we should take a count the ~car~ part:
- ~count-leaves~ of tree ~x~ is ~count-leaves~ of the ~car~ of ~x~ plus
  ~count-leaves~ of the ~cdr~ of ~x~.


After repeatedly apply the reduction step, we reach the another base case:
- ~count-leaves~ of a leaf is 1.


And we can test whether it is leaf by using the primitive predicate ~pair?~ we
test whether it is pair or not.

Then we can complete the procedure:
#+BEGIN_SRC scheme
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
#+END_SRC
**** Exercise 2.24
I've drawn assigned task in Digital Papper.
**** Exercise 2.25
1. ~(cadaddr (list 1 3 (list 5 7) 9))~ results to 7.
   The notation ~(cadaddr x)~ is abbreviation for ~(car (cdr (car (cdr (cdr x)))))~.
   Let we use this notation from this point for the space.
2. ~(caar (list (list 7)))~.
3. ~(cadadadadadadr x)~, where ~x~ is ~(1 (2 (3 (4 (5 (6 7))))))~.


**** Exercise 2.26
1. ~(append x y)~ would result to ~(1 2 3 4 5 6)~.
2. ~(cons x y)~ would result to ~((1 2 3) 4 5 6)~.
3. ~(list x y)~ would result to ~((1 2 3) (4 5 6))~.


We can verify those by evaluating:
#+BEGIN_SRC scheme
(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y)
(cons x y)
(list x y)
#+END_SRC

Yeah the results are same as above.
**** Exercise 2.27
We should implement, so called, ~deep-reverse~. It behaves as follows:
#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4))) ;((1 2) (3 4))
(reverse x)                             ;((3 4) (1 2))
(deep-reverse x)                        ;((4 3) (2 1))
#+END_SRC

It is obvious that we should use, so called, tree recursion for it. Or wishful
thinking so to say.

Let's start with reduction step:
- We assume that subtrees are /deep reversed/. Then we can complete the whole
  procedure:
  #+BEGIN_SRC scheme
(reverse (cons (deep-reverse (car x)) (deep-reverse (cdr x))))
  #+END_SRC
- Then the results are reduced to the subproblem whose argument is subtree of ~x~.


There are two base case with which the reduction step end up:
- By cdring down the list, we optain nil at the very end.
- Or, we could encounter the leaf, not the pair by caring the list.


As consequence, we can complete the procedure analogous to ~count-leaves~:
#+BEGIN_SRC scheme
(define (deep-reverse x)
  (cond ((null? x) x)
        ((not (pair? x)) x)
        (else (reverse (cons
                        (deep-reverse (car x))
                        (deep-reverse (cdr x)))))))
#+END_SRC
**** Exercise 2.28
Implement ~fringe~. Whose behavior are the followings:
#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4)))
(fringe x)                              ;(1 2 3 4)
(fringe (list x x))                     ;(1 2 3 4 1 2 3 4)
#+END_SRC

The strategy is similar with [[Exercise 2.27][above]]:
#+BEGIN_SRC scheme
(define (fringe x)
  (cond ((null? x) x)
        ((not (pair? x)) (list x))
        (else (append (fringe (car x))
                      (fringe (cdr x))))))
#+END_SRC

Note that we return the singleton list in the case of leaf; it is necessary at
the reduction step.
**** Exercise 2.29
Here we model the binary mobile, which consists of two branches--a left branch
and right branch. Each branch is a rod of a certain length, from which hangs
either a weight or another binary mobile.

We can construct it by using ~list~:
#+BEGIN_SRC scheme
(define (make-mobile left right)
  (list left right))
#+END_SRC

A branch is constructed from a ~length~, which must be a number, together with a
~structure~, which may be either a number--a simple weight-- or another mobile:
#+BEGIN_SRC scheme
(define (make-branch length structure)
  (list length structure))
#+END_SRC

***** a.
Then we can implement the selectors, namely ~left-branch~ and ~right-branch~:
#+BEGIN_SRC scheme
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cadr mobile))
#+END_SRC
And the branch' structure:
#+BEGIN_SRC scheme
(define (branch-structure branch)
  (cadr branch))
#+END_SRC

***** b.
The procedure that returns weight of mobile, ~total-weight~, is similar with
above tree recursion processes:[fn::We sense more and more replicative patterns
here]
- Reduction process:
  #+BEGIN_SRC scheme
(+ (total-weight (branch-structure (left-branch mobile)))
   (total-weight (branch-structure (right-branch mobile))))
  #+END_SRC
  which end up with
- Base case:
  #+BEGIN_SRC scheme
(if (not (mobile? x)) x)                ;a simple weight case
  #+END_SRC
  And the ~mobile?~ test whether it is mobile:
  #+BEGIN_SRC scheme
(define (mobile? x) (pair? x))
  #+END_SRC


And then we complete the procedure:
#+BEGIN_SRC scheme
(define (total-weight mobile)
  (if (not (mobile? mobile))
      mobile
      (+ (total-weight (branch-structure (left-branch mobile)))
         (total-weight (branch-structure (right-branch mobile))))))
#+END_SRC
***** c. Design the predicate that tests whether a binary mobile is balanced.
Here we also exploit the wishful thinking about the tree structure:
- Reduction process:
  #+BEGIN_SRC scheme
(let ((left (left-branch mobile))
      (right (right-branch mobile)))
  (let ((mobile-l (branch-structure left))
        (mobile-r (branch-structure right)))
    (if (and (balanced? mobile-l)
             (balanced? mobile-r))
        (= (* (branch-length left)
              (total-weight mobile-l))
           (+ (branch-length right)
              (total-weight mobile-r)))
        false)))
  #+END_SRC
  Here we used the ~branch-length~ whose definition is
  #+BEGIN_SRC scheme
(define (branch-length branch)
  (car branch))
  #+END_SRC
  Yeah, it's quite dirty; but straight forward. We can revise the if clause as
  follow:
  #+BEGIN_SRC scheme
(and (balanced? mobile-l)
     (balanced? mobile-r)
     (= (* (branch-length left)
              (total-weight mobile-l))
           (+ (branch-length right)
              (total-weight mobile-r))))
  #+END_SRC
  as the consequence and alternative of if clause are boolean. This end up with
- Base case (a simple weight):
  #+BEGIN_SRC scheme
(if (not (mobile? x)) true)
  #+END_SRC
  which can be reduced to
  #+BEGIN_SRC scheme
(not (mobile? x))
  #+END_SRC


The complete code:
#+BEGIN_SRC scheme
(define (blanced? mobile)
  (and (not (mobile? mobile))
       (let ((left (left-branch mobile))
             (right (right-branch mobile)))
         (let ((mobile-l (branch-structure left))
               (mobile-r (branch-structure right)))
           (and (balanced? mobile-l)
                (balanced? mobile-r)
                (= (* (branch-length left)
                      (total-weight mobile-l))
                   (+ (branch-length right)
                      (total-weight mobile-r))))))))
#+END_SRC
***** d.
Suppose we change the representation of mobiles so that the constructors are
#+BEGIN_SRC scheme
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
#+END_SRC

Then we should change only the followings:
#+BEGIN_SRC scheme
(define (right-branch mobile)
  (cdr mobile))
(define (branch-structure branch)
  (cdr branch))
#+END_SRC
Boom! That's it. The power of abstract barrier!

**** Mapping over trees
We can define the ~scale-tree~ procedure analogous to ~scale-list~ using ~map~:
#+BEGIN_SRC scheme
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
#+END_SRC
**** Exercise 2.30
Define a procedure ~square-tree~ analogous to the ~square-list~ procedure of [[Exercise
2.21][exercise 2.21]].
That is, ~square-tree~ should behave as follows:
#+BEGIN_SRC scheme
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))                     ;(1 (4 (9 16) 25) (36 49))
#+END_SRC

***** Define ~square-tree~ without higher-order procedures
We can do this by analogy to ~scale-tree~:
#+BEGIN_SRC scheme
(define (square-tree tree)
  (cond ((null? tree) tree)
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree (car tree))
                    (square-tree (cdr tree))))))
#+END_SRC
***** Define ~square-tree~ using ~map~
#+BEGIN_SRC scheme
(define (square-tree tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree sub-tree)
             (square sub-tree)))
       tree))
#+END_SRC

**** Exercise 2.31
Define ~tree-map~ that behave as follows:
#+BEGIN_SRC scheme
(define (square-tree tree) (tree-map square tree))
#+END_SRC
It is easy:
#+BEGIN_SRC scheme
(define (tree-map proc tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (tree-map proc sub-tree)
             (proc sub-tree)))
       tree))
#+END_SRC
**** Exercise 2.32
We can get the whole subsets of ~s~ by reducing that:
- The subsets that include the element ~a~ of ~s~ plus
- The subsets that do not include the element ~a~.


Then we can complete the code:
#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list s)
      (let ((rest (subsets (cdr s))))
        (append rest
                (map (lambda (subset)
                       (cons (car s) subset))
                     rest)))))
#+END_SRC
*** Sequences as Conventional Interfaces
**** Sequence Operations
The main procedures that complete the signal processing interfaces are
followings:
- [[Mapping over lists][map]]
- [[Exercise 2.20][filter]]
- accumulate
  #+BEGIN_SRC scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
  #+END_SRC


All that remains to implement signal-flow diagrams is to enumerate the sequence
of elements to be processed. That is, to make signals which processed afterward.
- make initial signal; produces list.
  To enumerate the interval of integers, we can code
  #+BEGIN_SRC scheme
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
  #+END_SRC

  For tree, we can transform the tree as follows[fn::In fact, it is same
  procedure as [[Exercise 2.28][fringe]].]:
  #+BEGIN_SRC scheme
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
  #+END_SRC

**** Exercise 2.33
By comparing the ~map~ procedure and ~accumulate~ we can define the ~map~ as follows:
#+BEGIN_SRC scheme
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y))
              nil
              sequence))
#+END_SRC
And the others also can be implemented analogous to above:
#+BEGIN_SRC scheme
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (1+ y)) 0 sequence))
#+END_SRC
**** Exercise 2.34
Horner's rule.
#+BEGIN_SRC scheme
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              coefficient-sequence))
;; test
(horner-eval 2 (list 1 3 0 5 0 1))      ;79
#+END_SRC
Actually I've used this in the exercise in [[github:HyunggyuJang/Isabelle][Isabelle]].
**** Exercise 2.35
We can redefine ~count-leaves~ from [[Hierarchical Structures][this]] using ~accumulate~, which means that we
can formulate ~count-leaves~ as signal processing interface.

At first, let's try out without lingering over it; just compare those structure
and code it appropriately:
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate (lambda (x y)
                (if (not (pair? x))
                    (1+ y)
                    (+ (count-leaves x)
                       y)))
              0
              t))
#+END_SRC

It works; but it is not the one the text wanted: Text want we process the ~t~
with ~map~ before feed it to ~accumulate~:
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate <??> <??> (map <??> <??>)))
#+END_SRC
And more, it is no more clear than we did previously; just cramming all of the
messy things from ~count-leaves~ into the ~op~ of ~accumulate~.

We can do better than that. Let's follow text's intention; but how we get the
~count-leaves~ coded? As we trying to formulate this as signal processing
interface, first we need to processing the input ~t~ as 'signal'--list--so that
we can use conventional interfaces for this.

Then the remain is simple:
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate + 0 (map (lambda (x) 1)
                       (enumerate-tree t))))
#+END_SRC

Yeah, who even said that we shouldn't use ~enumerate-tree~ here? I think the
intention of this exercise was in that capturing recursive process in signal
processing framework. It looks silly when we map all the list items into number
~1~ like this; but it will compensate someday I think. Whatever, let's move on.

**** Exercise 2.36
The generalized version of ~accumulate~, ~accumulate-n~ deal with sequence of
sequences that all have same number of elements. The behavior is as follows:
#+BEGIN_SRC scheme
(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
;(22 26 30)
#+END_SRC

Here we use wishful thinking as usual:
- Reduction process:
  Let we assume that we were given the results of
  ~accumulate-n~ with sequence of sequences except the first element of each.
  Then we can complete the process by ~accumulate~ the first element of each and
  then consing it with the given:
  #+BEGIN_SRC scheme
(cons (accumulate op init (map car seqs))
      (accumulate-n op init (map cdr seqs)))
  #+END_SRC

  After repeatedly applying this process we get
- Base case:
  we end up with sequence of ~nil~:
  #+BEGIN_SRC scheme
(if (null? (car seqs))
    (car seqs))
  #+END_SRC
  This is the only base case because ~nil~ is not the sequence of sequences.

Then the complete code can be synthesized as usual:
#+BEGIN_SRC scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      (car seqs)
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))
#+END_SRC

**** Exercise 2.37
From now on, I'll pace up because I've already designed the strucutre of these
exercises on my note.
#+BEGIN_SRC scheme
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map (lambda (m_i) (dot-product m_i u))
       m))
(define (transpose mat)
  (accumulate-n cons '() mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (m_i)
           (matrix-*-vector cols m_i))
         m)))
#+END_SRC

**** Exercise 2.38
To get equal value from both ~fold-right~ and ~fold-left~, ~op~ should satisfy
the associative law of algebra and also commutative law with repect to ~init~.

**** Exercise 2.39
#+BEGIN_SRC scheme
(define (snoc x y)
  (append y (list x)))
(define (reverse sequence)
  (fold-right (lambda (x y)
                (snoc x y))
              '()
              sequence))
(define (reverse sequence)
  (fold-left (lambda (x y)
               (cons y x))
             '()
             sequence))
#+END_SRC

**** Exercise 2.40
#+BEGIN_SRC scheme
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))
(define (unique-pairs n)
  (flatmap
   (lambda (i)
     (map (lambda (j) (list i j))
          (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 n)))
#+END_SRC

**** Exercise 2.41
#+BEGIN_SRC scheme
(define (triple-sum-to-s n s)
  (filter (lambda (triple)
            (= s (fold-right + 0 triple)))
          (flatmap (lambda (k)
                     (map (lambda (p)
                            (snoc k p))
                          (unique-pairs (- k 1))))
                   (enumerate-interval 1 n))))
#+END_SRC

**** Exercise 2.42
#+BEGIN_SRC scheme
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval i board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(define empty-board '())

(define (adjoin-position new-row k rest-of-queens)
  (cons new-row rest-of-queens))

(define (safe? k positions)
  (define (equal-not-to? nr rest)
    (or (null? rest)
        (and (not (= nr (car rest)))
             (equal-not-to? nr (cdr rest)))))
  (define (pm-i-not-equal-to? nr i rest)
    (or (null? rest)
        (and (not (or (= (+ nr i) (car rest))
                      (= (- nr i) (car rest))))
             (pm-i-not-equal-to? nr (1+ i) (cdr rest)))))
  (let ((new-row (car positions))
        (rest-queens (cdr positions)))
    (and (equal-not-to? new-row rest-queens) ;provided that positions not empty
         (pm-i-not-equal-to? new-row 1 rest-queens))))
#+END_SRC
Note that here we didn't use the parameter ~k~ none of helper procedures--
~adjoin-position~ and ~safe?~ -- because we don't need to; I've thought it is
natural to think /the first k-1 columns/ as counted from the rightmost.
#+RESULTS:
: #<unspecified>

**** Exercise 2.43
Because by exchange the order of ~flatmap~ and ~map~ in the procedure
~queen-cols~ now the procedure call ~(queen-cols (- k 1))~ become evaluated
duplicately every ~new-row~ of ~(enumerate-interval 1 board-size)~, i.e
~board-size~ times.

We can reason the asymptotic time complexity of both cases:
- The original one is \theta(n^{3})
- The troubled one is \theta(n^{n})


Here we used the n as ~board-size~. As consequence, when ~board-size~ is 8 and
let the time taken by original one /T/, then the Louis's one takes approximately
more than 8^{5} \times /T/.
*** Example: A Picture Language
**** The picture language
- Primitives: /painter/
- Means of combination: ~beside~, ~below~
  - Create new painter from existing one: ~filp-vert~, ~flip-horiz~
- Means of abstraction: ~define~ in scheme language; As means of combination are
  all procedure in scheme, we can abstract them like any other procedure in scheme.


The results of combination of painter are also painters; by this closure
property with scheme's picture language inherit closure property in complete
sense.

I've tried to configure the picture language framework in mit-scheme; but to no vail.
I've searched the github of mit-scheme, which has the directory named "6001"
that contains ~6001.pkg~; to use that package, I've read the relevant content of
MIT scheme's user manual, also to no use; I've complied it with ~sf~ method in
edwin editor--this package depends on the edwin package, so I have no choice to
use emacs in this case--, and I found myself it is useless I need to put more
time in configuration than solving the exercises. The easiest alternative was to
use racket's sicp package, which I knew but have stuck with using *pure*
mit-scheme as I felt it is more canonical. Well, whatever, I've given up with
that; let's go with racket.
**** Exercise 2.44
We can define ~up-split~ analogous to ~right-split~.
#+BEGIN_SRC scheme
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))
#+END_SRC
**** Exercise 2.45
We can easily abstract this by higher order function:
#+BEGIN_SRC scheme
(define (split tran1 tran2)
  (lambda (painter n)
    (if (= n 0)
        painter
        (let ((smaller ((split tran1 tran2) painter (- n 1))))
          (tran1 painter (tran2 smaller smaller))))))
#+END_SRC
**** Exercise 2.46
Note that I implement ~sub-vect~ using the ~scale-vect~ and ~add-vect~; it is
subtle matter but I thought this definition is more canonical in algebraical
sense:
#+BEGIN_SRC scheme
(define (make-vect x y)
  (cons x y))

(define (xcor-vect v)
  (car v))

(define (ycor-vect v)
  (cdr v))

(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1)
                (xcor-vect v2))
             (+ (ycor-vect v1)
                (ycor-vect v2))))
(define (scale-vect s v)
  (make-vect (* (xcor-vect v) s)
             (* (ycor-vect v) s)))
(define (sub-vect v1 v2)
  (add-vect v1 (scale-vect -1 v2)))
#+END_SRC
**** Exercise 2.47
For first representation, we can implement selectors accordingly:
#+BEGIN_SRC scheme
(define (origin-frame f)
  (car f))
(define (edge1-frame f)
  (cadr f))
(define (edge2-frame f)
  (caddr f))
#+END_SRC
For the latter, similarly:
#+BEGIN_SRC scheme
(define (origin-frame f)
  (car f))
(define (edge1-frame f)
  (cadr f))
(define (edge2-frame f)
  (cddr f))
#+END_SRC
**** Exercise 2.48
Didn't we solved this in exercise 2.2? In there, we made segment using points
not vector but the representation axiom is same in both; we can reuse that
definiiton:
#+BEGIN_SRC scheme
;; Constructor make-segment
(define (make-segment start-pt end-pt)
  (cons start-pt end-pt))
;; Selector start-segment
(define (start-segment segment)
  (car segment))
;; Selector end-segment
(define (end-segment segment)
  (cdr segment))
#+END_SRC
**** Exercise 2.49
***** a.
The painter that draws the outline of the designated frame.
#+BEGIN_SRC scheme
(define outliner
  (let ((o (make-vect 0 0))
        (br (make-vect 1 0))
        (tr (make-vect 1 1))
        (tl (make-vect 0 1)))
    (segments->painter (list (make-segment o br)
                             (make-segment br tr)
                             (make-segment tr tl)
                             (make-segment tl o)))))
#+END_SRC
***** b.
The painter that draws an "X" by connecting opposite corners of the frame.
#+BEGIN_SRC scheme
(define x-liner
  (let ((o (make-vect 0 0))
        (br (make-vect 1 0))
        (tr (make-vect 1 1))
        (tl (make-vect 0 1)))
    (segments->painter (list (make-segment o tr)
                             (make-segment br tl)))))
#+END_SRC
***** c.
The painter that draws a diamond shape by connecting the midpoints of the sides
of the frame.
#+BEGIN_SRC scheme
(define dia-liner
  (let ((o (make-vect 0 0))
        (br (make-vect 1 0))
        (tr (make-vect 1 1))
        (tl (make-vect 0 1)))
    (let ((left (scale-vect 0.5 tl))
          (bottom (scale-vect 0.5 br)))
      (let ((right (add-vect br left))
            (top (add-vect tl bottom)))
        (segments->painter (list (make-segment left top)
                                 (make-segment top right)
                                 (make-segment right bottom)
                                 (make-segment bottom left)))))))
#+END_SRC
***** DONE d.
The wave painter.
#+BEGIN_SRC scheme
(define wave
  (let ((lhl (make-vect 0 0.65))         ;left hand
        (lhh (make-vect 0 0.8))
        (rhh (make-vect 1 0.35))
        (rhl (make-vect 1 0.2))
        (lal (make-vect 0.24 0.45))     ;left arm joint
        (lah (make-vect 0.24 0.6))
        (lsl (make-vect 0.4 0.6))       ;left shoulder
        (lsh (make-vect 0.4 0.65))
        (ln (make-vect 0.45 0.65))
        (rn (make-vect 0.55 0.65))
        (rs (make-vect 0.6 0.65))
        (lfa (make-vect 0.43 0.8))
        (rfa (make-vect 0.57 0.8))
        (lh (make-vect 0.45 1))
        (rh (make-vect 0.55 1))
        (lv (make-vect 0.43 0.55))
        (rv (make-vect 0.57 0.55))
        (lfo (make-vect 0.3 0))
        (rfo (make-vect 0.7 0))
        (lfo1 (make-vect 0.4 0))
        (rfo1 (make-vect 0.6 0))
        (cl (make-vect 0.5 0.3)))
    (segments->painter (list (make-segment lhh lah)
                             (make-segment lah lsh)
                             (make-segment lsh ln)
                             (make-segment ln lfa)
                             (make-segment lfa lh) ;from left hand high to left head
                             (make-segment lhl lal)
                             (make-segment lal lsl)
                             (make-segment lsl lv)
                             (make-segment lv lfo) ;from left hand low to left foot
                             (make-segment lfo1 cl)
                             (make-segment cl rfo1) ;from left foot1 to right foot1
                             (make-segment rfo rv)
                             (make-segment rv rhl) ;from left foot to right hand low
                             (make-segment rhh rs)
                             (make-segment rs rn)
                             (make-segment rn rfa)
                             (make-segment rfa rh)))        ;from left hand high left head
    ))
#+END_SRC
**** Transforming and combining painters
As we noted in the introductive session of this section, the combinators created
new painter element using the existing ones. Now we implement the combinators
using more general procedure, ~transform-painter~:
#+BEGIN_SRC scheme
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter
         (make-frame new-origin
                     (sub-vect (m corner1) new-origin)
                     (sub-vect (m corner2) new-origin)))))))
#+END_SRC
Here we exploit the fact that ~painter~ is actually just procedure, which takes
~frame~ for its arguemnt, so to transform the ~painter~ all we need to do is
transform the ~frame~ appropriately. Also note that we could have chosen ~edge1~
and ~edge2~ for transformation instead ~corner1~ and ~corner2~; we just found
from the use case it is more convenient.

Then we can implement a lot of combinators:
- ~filp-vert~
  #+BEGIN_SRC scheme
(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
  #+END_SRC
- We can also shrink the frame:
  #+BEGIN_SRC scheme
(define (shrink-to-upper-right painter)
  (transform-painter painter
                     (make-vect 0.5 0.5)
                     (make-vect 1.0 0.5)
                     (make-vect 0.5 1.0)))
  #+END_SRC
- Also we can rotate the frame:
  #+BEGIN_SRC scheme
(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
  #+END_SRC
- We can combine two or more paitners
  #+BEGIN_SRC scheme
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              split-point
                              (make-point 0.0 1.0)))
          (paint-right
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.0)
                              (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
  #+END_SRC
**** Exercise 2.50
We can define ~flip-horiz~ analogous to ~flip-vert~:
#+BEGIN_SRC scheme
(define (flip-horiz painter)
  (transform-painter painter
                     (make-vect 1.0 0.0) ;new origin
                     (make-vect 0.0 0.0) ;new end of edge1
                     (make-vect 0.0 1.0))) ;new end of edge2
#+END_SRC
We can define rotating frames in either way, using ~rotate90~ or directly:
- Using ~rotate90~:
  #+BEGIN_SRC scheme
(define (rotate180 painter)
  (rotate90 (rotate90 painter)))
(define (rotate270 painter)
  (rotate90 (rotate180 painter)))
  #+END_SRC
- define directly:
  #+BEGIN_SRC scheme
(define (rotate180 painter)
  (transform-painter painter
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 0.0)))
(define (rotate270 painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
  #+END_SRC
**** Exercise 2.51
- Define ~below~ analogous to ~beside~:
  #+BEGIN_SRC scheme
(define (below painter1 painter2)
  (let ((split-point (make-vect 0.0 0.5)))
    (let ((paint-bottom
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              (make-point 1.0 0.0)
                              split-point))
          (paint-top
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.5)
                              (make-vect 0.0 1.0))))
      (lambda (frame)
        (paint-bottom frame)
        (paint-top frame)))))
  #+END_SRC
- Using ~beside~:
  #+BEGIN_SRC scheme
(define (below painter1 painter2)
  (rotate270 (beside (rotate90 painter2)
                     (rotate90 painter1))))
  #+END_SRC
**** Exercise 2.52
***** a.
Let's add some smile to our ~wave~:
#+BEGIN_SRC scheme
(define wave
  (let ((lhl (make-vect 0 0.65))         ;left hand
        (lhh (make-vect 0 0.8))
        (rhh (make-vect 1 0.35))
        (rhl (make-vect 1 0.2))
        (lal (make-vect 0.24 0.45))     ;left arm joint
        (lah (make-vect 0.24 0.6))
        (lsl (make-vect 0.4 0.6))       ;left shoulder
        (lsh (make-vect 0.4 0.65))
        (ln (make-vect 0.45 0.65))
        (rn (make-vect 0.55 0.65))
        (lm (make-vect 0.48 0.77))      ;smile~
        (rm (make-vect 0.52 0.77))
        (cm (make-vect 0.5 0.75))
        (rs (make-vect 0.6 0.65))
        (lfa (make-vect 0.43 0.8))
        (rfa (make-vect 0.57 0.8))
        (lh (make-vect 0.45 1))
        (rh (make-vect 0.55 1))
        (lv (make-vect 0.43 0.55))
        (rv (make-vect 0.57 0.55))
        (lfo (make-vect 0.3 0))
        (rfo (make-vect 0.7 0))
        (lfo1 (make-vect 0.4 0))
        (rfo1 (make-vect 0.6 0))
        (cl (make-vect 0.5 0.3)))
    (segments->painter (list (make-segment lhh lah)
                             (make-segment lah lsh)
                             (make-segment lsh ln)
                             (make-segment ln lfa)
                             (make-segment lfa lh) ;from left hand high to left head
                             (make-segment lhl lal)
                             (make-segment lal lsl)
                             (make-segment lsl lv)
                             (make-segment lv lfo) ;from left hand low to left foot
                             (make-segment lfo1 cl)
                             (make-segment cl rfo1) ;from left foot1 to right foot1
                             (make-segment rfo rv)
                             (make-segment rv rhl) ;from left foot to right hand low
                             (make-segment rhh rs)
                             (make-segment rs rn)
                             (make-segment rn rfa)
                             (make-segment rfa rh) ;from left hand high left head
                             (make-segment lm cm)
                             (make-segment cm rm))) ;smile~
    ))
#+END_SRC
***** b.
Change ~corner-split~ using only one copy of the ~up-split~ and ~right-split~:
#+BEGIN_SRC scheme
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left up)
              (bottom-right right))
          (beside (below painter top-left)
                  (below bottom-right (corner-split painter (- n 1))))))))
#+END_SRC
***** c.
Modify ~square-limit~ so that the big Mr. Rogers look outward from each corner
of the square:
#+BEGIN_SRC scheme
(define (squre-limit painter n)
  (let ((combine4 (square-of-four flip-vert
                                  rotate180
                                  identity
                                  flip-horiz)))))
#+END_SRC
**** Resulting Pictures
#+BEGIN_SRC racket :session *racket-pict*
#lang racket
(require sicp-pict)
(define/contract wave
  (listof segment?)
  (let ((lhl (make-vect 0 0.65))         ;left hand
        (lhh (make-vect 0 0.8))
        (rhh (make-vect 1 0.35))
        (rhl (make-vect 1 0.2))
        (lal (make-vect 0.24 0.45))     ;left arm joint
        (lah (make-vect 0.24 0.6))
        (lsl (make-vect 0.4 0.6))       ;left shoulder
        (lsh (make-vect 0.4 0.65))
        (ln (make-vect 0.45 0.65))
        (rn (make-vect 0.55 0.65))
        (rs (make-vect 0.6 0.65))
        (lm (make-vect 0.48 0.77))      ;smile~
        (rm (make-vect 0.52 0.77))
        (cm (make-vect 0.5 0.75))
        (lfa (make-vect 0.43 0.8))
        (rfa (make-vect 0.57 0.8))
        (lh (make-vect 0.45 1))
        (rh (make-vect 0.55 1))
        (lv (make-vect 0.43 0.55))
        (rv (make-vect 0.57 0.55))
        (lfo (make-vect 0.3 0))
        (rfo (make-vect 0.7 0))
        (lfo1 (make-vect 0.4 0))
        (rfo1 (make-vect 0.6 0))
        (cl (make-vect 0.5 0.3)))
    (list (make-segment lhh lah)
          (make-segment lah lsh)
          (make-segment lsh ln)
          (make-segment ln lfa)
          (make-segment lfa lh)         ;from left hand high to left head
          (make-segment lhl lal)
          (make-segment lal lsl)
          (make-segment lsl lv)
          (make-segment lv lfo)         ;from left hand low to left foot
          (make-segment lfo1 cl)
          (make-segment cl rfo1)        ;from left foot1 to right foot1
          (make-segment rfo rv)
          (make-segment rv rhl)         ;from left foot to right hand low
          (make-segment rhh rs)
          (make-segment rs rn)
          (make-segment rn rfa)
          (make-segment rfa rh)         ;from left hand high left head
          (make-segment lm cm)
          (make-segment cm rm))         ;smile~
    ))
(define wave-p (segments->painter wave))
(paint wave-p)
#+END_SRC

#+RESULTS:
: (object:image-snip% ...)
** Symbolic Data
*** Quotation
**** Exercise 2.53
This is easy stuff to get familized with quote notation
#+BEGIN_SRC scheme
(list 'a 'b 'c)                         ;(a b c)
(list (list 'george))                   ;((george))
(cdr '((x1 x2) (y1 y2)))                ;((y1 y2))
(pair? (car '(a short list)))           ;#f
(memq 'red '((red shoes) (blue socks))) ;#f
(memq 'red '(red shoes blue socks))     ;(red shoes blue socks)
#+END_SRC
**** Exercise 2.54
We can think ~equal?~ procedure as two independent unit:
- check if two arguments are symbols--not list and if it is then delegate to ~eq?~.
- otherwise, it means both are list; delegate this to another helper procedure
  ~eqList?~.


Here we used our old strategy wishful thinking: We haven't ~eqList?~; we defered
to implement it.
#+BEGIN_SRC scheme
(define (equal? s1 s2)
  (or (and (symbol? s1)
           (symbol? s2)
           (eq? s1 s2))
      (eqList? s1 s2)))
#+END_SRC

Then we should implement ~eqList?~. We can design it using the type constrains,
of which Standard ML is good at:
#+BEGIN_SRC sml
fun eqList [] [] = true
  | eqList _ [] = false
  | eqList [] _ = false
  | eqList (x::xs) (y::ys) = (eq x y) andalso (eqList xs ys);
#+END_SRC

We can translate to scheme easily:
#+BEGIN_SRC scheme
(define (eqList? xs ys)
  (cond ((and (null? xs) (null? ys))
         true)
        ((and (not (null? xs)) (null? ys))
         false)
        ((and (null? xs) (not (null? ys))) ;base case
         false)
        (else (and (eq? (car xs) (car ys)) ;recursive case
                   (eqList? (cdr xs) (cdr ys))))))
#+END_SRC
**** Exercise 2.55
Because ~'...~ is just syntatic sugar for ~(quote ...)~. So it is same as
~(quote (quote ...))~. That is, as inner parts of the outermost ~quote~ are
treated symbolically, ~(car (quote ...))~ is ~quote~. There is no surprise here.
*** Example: Symbolic Differentiation
By allowing the symbolic notation in our language, we can cope with algebraic
manipulation symbolically. For simplicity, here we consider only simple
differentiation rules:
- $\frac{dc}{dx} = 0$ for $c$ a constant or a variable different from $x$
- $\frac{dx}{dx} = 1$
- $\frac{\left( u + v \right)}{dx} = \frac{du}{dx} + \frac{dv}{dx}$
- $\frac{\left( uv \right)}{dx} = u \left( \frac{dv}{dx} \right) + v \left(
  \frac{du}{dx} \right)$


Here we delegate implementing of representation of symbolic differentiation
system by using wishful thinking: We just need specify what we want.

First let's try to code ~deriv~ that calculate the derivative of given
expression with respect to ~var~ along with differentiation rules:
#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplicand exp)
                        (deriv (multiplier exp) var))
          (make-product (deriv (multiplicand exp) var)
                        (multiplier exp))))
        (else
         (error "unknown expression type -- DERIV" exp))))
#+END_SRC

Note that we /just/ used all the procedure that we need without implementing
that. Also note that this ~deriv~ procedure coded directly the differential
rules from calculus.

Can we represent the expression that we used in ~deriv~? Yes sure!
#+BEGIN_SRC scheme
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (symbol? v1) (symbol? v2) (eq? v1 v2)))
(define (make-sum a1 a2)
  (list '+ a1 a2))
(define (make-product m1 m2)
  (list '* m1 m2))
(define (sum? s)
  (and (pair? s) (eq? (car s) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? p)
  (and (pair? p) (eq? (car p) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand P) (caddr p))
#+END_SRC

Here we embedded the symbolic expression analogous to lisp's compound
expression--prefix notation.

Let's test this:
#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)                     ;(+ 1 0)
(deriv '(* x y) 'x)                     ;(+ (* x 0) (* 1 y))
(deriv '(* (* x y) (+ x 3)) 'x)         ;(+ (* (+ x 3) (+ (* y 1) (* 0 x))) (* (+ 1 0) (* x y)))
#+END_SRC

Is what we expected? Well, yes and no: The program produces answer that are
correct with respect with the differentiation rules; but it is so verbose. We
need some simplifying steps; we can accomplish this using the analogy to
rational number arithmetic system; we don't need to alter the ~deriv~ procedure,
which uses the constructors and selectors--the lower lever of language.

Let's specify what we exactly expect from the simplification:
- For multiplication
  - $x \times 0 = 0$
  - $y \times 1 = y$
- For summation
  - $x + 0 = 0$


Also we want to fold the constants:
If the two argument of symbolic operation are both number than we calculate
appropriately, i.e.
- ~('+ 5 4)~ should be simplified to ~9~
- ~('* 5 4)~ should be simplified to ~20~


Then we can implement this by amending the low level language.
#+BEGIN_SRC scheme
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (=number? s n)
  (and (number? s) (= s n)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2))
         (* m1 m2))
        (else (list '* m1 m2))))
#+END_SRC
**** Exercise 2.56
Add the exponentiation to our symbolic algebraic system.
Our differentiation system become
#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplicand exp)
                        (deriv (multiplier exp) var))
          (make-product (deriv (multiplicand exp) var)
                        (multiplier exp))))
        ((exponentiation? exp)
         (make-product (make-product (exponent exp)
                                     (make-exponentiation (base exp) (- (exponent exp) 1)))
                       (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIV" exp))))
#+END_SRC
with the representation
#+BEGIN_SRC scheme
(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        ((and (number? base) (number? exponent))
         (expt base exponent))
        (else (list '** base exponent))))

(define (exponentiation? e)
  (and (pair? e) (eq? (car e) '**)))

(define (base ex)
  (cadr ex))

(define (exponent ex)
  (caddr ex))
#+END_SRC
Let's test it:
- The normal differentiation:
  #+BEGIN_SRC scheme
(deriv '(** x 5) 'x)                    ;(* 5 (** x 4))
  #+END_SRC
- Check if it simplify appropriately:
  #+BEGIN_SRC scheme
(deriv '(** x 2) 'x)                    ;(* 2 x)
  #+END_SRC
**** Exercise 2.57
Extend our program to handle sums and product of arbitrary numbers (two or more)
of terms; e.g.
- our last example of test, ~(deriv '(* (* x y) (+ x 3)) 'x)~, can be expressed
  as ~(deriv '(* x y (+ x 3)) 'x)~.


Just amending the lower level of language--constructors and selectors.
Note that the differential rules-- ~deriv~-- doesn't assume that the $v$ is just
symbol; if we can recognize the $v$ part appropriately, we are done.

Here is the idea:
\[\frac{d\left[ u + \left( v + w + \cdots \right) \right]}{dx} = \frac{du}{dx} +
\frac{d\left( v + w + \cdots \right)}{dx}\]
That is, if we can amend ~(augend exp)~ to return ~(+ v w ...)~ then we complete
our mission.

We can code it directly:
#+BEGIN_SRC scheme
(define (augend s)
;; provided that s has more than two number of terms
  (if (null? (cdddr s))
      (caddr s)                         ;it has exactly two terms addend augend.
      (cons '+ (cddr s))))              ;it has more than that
#+END_SRC

Similarly,
#+BEGIN_SRC scheme
(define (multiplicand m)
;; provided that s has more than two number of terms
  (if (null? (cdddr m))
      (caddr m)                         ;it has exactly two terms.
      (cons '* (cddr m))))              ;it has more than that
#+END_SRC

We don't need to fix any of the constructors. We don't like to fix any so that
our construct afford to make expression with arbitrary terms; that only make
things more complicate.
**** Exercise 2.58
The mathematicians want to use infix form instead of prefix form like lisp
expression. Suppose we have to program our differentiation procedure for such
mathematicians; i.e. we have to modify our differentiation program so that it
works with ordinary mathematical notation--infix form.

***** a. binary infix form
Here we consider the infix operator accept only two terms, i.e. binary infix
operator. By experimenting with some examples, we can conclude that in the
correct syntax form of expression, the operator should position at ~cadr~ of it.

Then we can accomplish it by coding that observation:
#+BEGIN_SRC scheme
(define (sum? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (eq? (cadr iexp) '+)))
#+END_SRC

Here we used ~pair?~ twice to assure it will not raise exception when we call
~(cadr iexp)~. It is necessary not to raise exception because the caller of
~sum?~ doesn't know and doesn't need to know the gross detail like whether
~iexp~ satisfy the constraint of representation of ~sum~; they doesn't need to
know the representation of those.

Likewise,
#+BEGIN_SRC scheme
(define (product? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (eq? (cadr iexp) '*)))
#+END_SRC

The selectors can be expressed as follows
#+BEGIN_SRC scheme
(define (addend is) (car is))
(define (augend is) (caddr is))
(define (multiplier im) (car im))
(define (multiplicand im) (caddr im))
#+END_SRC

Similarly, the constructors represented as
#+BEGIN_SRC scheme
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2)) ;↑ simplification
        (else (list a1 '+ a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) ;↑ simplification
         (* m1 m2))
        (else (list m1 '* m2))))
#+END_SRC

The test works well:
#+BEGIN_SRC scheme
(deriv '((x * 5) + (y + 4)) 'x)         ;5
#+END_SRC
***** b. Standard algebraic notation
Now we want to deal with more general case, standard algebraic notation, e.g.
~(x + 3 * (x + y + 2))~, which drops unnecessary parentheses and assumes that
multiplication is done before addition, i.e. multiplication has higher
precedence than addition.

To simplify the task, we develop new language, that is, the semantics of
standard algebraic notation. We can be rephrased as add new layer under the
representation; or to layer out between semantics and syntax.

First let's experiment with some examples:
~((x + y) * 5 * z)~, ~(x * y + (z + y) * 5)~

We can reconstruct using tree representation. Unfortunately I myself don't know
yet how to print the tree figure here[fn:1]; so I've drew these in my personal
note. Well, anyway there is one way to represent the tree structure in text:
Lisp! As said in text or lecture of SICP, we can represent the tree as list!
If we do that now, we obtain following results:
- ~(* (+ x y) 5 z)~ or ~(* (+ x y) (* 5 z))~
- ~(+ (* x y) (* (+ z y) 5))~


Note that in the first example we can represent in both, binary tree or tree
with arbitrary branches. Also note that this situation exactly match with the
previous exercise, [[Exercise 2.57][ex 2.57]].

Consequently, all we need to do is to convert infix form to prefix form allowed
to have arbitrary number of terms; the rest would be handled by ex 2.57 as said.

Then how? Again by wishful thinking assume that all the subtrees are constructed
appropriately. Let's try out.

If ~(car exp)~ is compound data, then delegate it to subtree constructor and
also we know that if it is correct infix form the ~(cadr exp)~ is
operator[fn:2]. Now we can construct whole tree by delegating the ~(cddr exp)~
and then constructing ~((cadr exp) sub1 sub2)~.

We constructed the abstract design of our code. The thing is, is it correct?
No, it isn't! The second example shows why it is; we have not considered the
precedence relation appropriately! To cope with it, we have to build the whole
tree either when we encounter with the lowest precedence operator or when we
get faced with last operator of expression at the top level.

This time, it works! How can we be sure? Can we prove it? Well, at least it is
worth to prove for practice or because it is not obvious; yet we are left with
long way to go. Let's consider that first. We've built the so called AST--
Abstract Syntactic Tree. Are we good to go and code this idea? Unfortunately no;
there is something we missed: The selectors that used by ~deriv~ should return
infix form not the prefix form as AST.

That is, this time, we have to linger over the opposite way than we have
constructed so far: To convert from AST to infix form. Here we also use the
wishful thinking in recursive case: The subtrees are constructed for us; the
rest is to deal with at the very top level.

For simplicity, let we ignore the unnecessary parentheses, i.e. we don't have to
omit the verbose parenthesis for conciseness when we convert to infix form. Then
we can easily do the task: ~(cov-sub1 op cov-sub2)~

Yeah It was quite long way to accomplish this! We did the design things! All the
left is to code it!

If we code that directly without further design--naive approach, then we get
#+BEGIN_SRC scheme
(define (->AST iexp)
  (define (constructor left stack)
    (let ((op (cadr left)))
      (cond ((or (lowest? op) (last? op left))
             (list op
                   (->AST (cons (car left) stack))
                   (->AST (cddr left))))
            (else (constructor
                   (cddr left)
                   (cons op
                         (cons (car left)
                               stack)))))))
  (cond ((null? (cdr iexp))             ;in the top level, it appears as singlton expression
         (if (pair? (car iexp))
             (->AST (car iexp))         ;compound expression
             (car iexp)))               ;singleton
        (else (constructor iexp '()))))

(define (lowest? op)
  (and (symbol? op) (eq? op '+)))
(define (last? op left)
  (and (symbol? op) (null? (cdddr left))))
#+END_SRC

We can test it; it works:
#+BEGIN_SRC scheme
;; test
(->AST '((x + y) * 5 * z))              ;(* (* 5 (+ x y)) z)
(->AST '(x * y + (z + y) * 5))          ;(+ (* y x) (* (+ z y) 5))
#+END_SRC

The reverse process can be coded likely:
#+BEGIN_SRC scheme
(define (->infix ast)
  (cond ((not (pair? ast)) ast)         ;base case
        (else (list (->infix (cadr ast)) ;recursive case
                    (car ast)
                    (->infix (caddr ast))))))
#+END_SRC

It also works:
#+BEGIN_SRC scheme
(->infix (->AST '((x + y) * 5 * z)))    ;((5 * (x + y)) * z)
#+END_SRC

With those, we can complete the code:
#+BEGIN_SRC scheme
(define (sum? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (let ((ast (->ast iexp)))
         (eq? (car ast) '+))))

(define (product? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (let ((ast (->ast iexp)))
         (eq? (car ast) '*))))

(define (addend iexp)
  (let ((ast (->ast iexp)))
    (->infix (cadr ast))))

(define (augend iexp)
  (let ((ast (->ast iexp)))
    (->infix (caddr ast))))

(define (multiplier iexp)
  (let ((ast (->ast iexp)))
    (->infix (cadr ast))))

(define (multiplicand iexp)
  (let ((ast (->ast iexp)))
    (->infix (caddr ast))))
#+END_SRC

The constructor should work as *a.* without modification.

Let's test it:
#+BEGIN_SRC scheme
(deriv '(x + 3 * (x + y + 2)) 'x)       ;4
(deriv '((x + y) * 5 * z) 'x)           ;(z * 5)
(deriv '(x * y + (z + y) * 5) 'x)       ;y
#+END_SRC

It works well. Phew, we did it.

# Or I've realized that actually it suffice to convert the infix form to prefix
# only at the very top level. If you see the code or example, I think, you got what
# I meant:
# #+BEGIN_SRC scheme
# (define (->pseudoAST iexp)
#   (define (constructor left stack)
#     (let ((op (cadr left)))
#       (cond ((or (lowest? op) (last? op left))
#              (cons op
#                    (cons (cons (car left) stack)
#                          (cddr left))))
#             (else (constructor
#                    (cddr left)
#                    (cons op
#                          (cons (car left)
#                                stack)))))))
#   (if (null? (cdr iexp))
#       (car iexp)
#       (constructor iexp '())))
# #+END_SRC

# And here are the example (or tests):
# #+BEGIN_SRC scheme
# (->pseudoAST '((x + y) * 5 * z))        ;(* (5 * (x + y)) z)
# (->pseudoAST '(x * y + (z + y) * 5))    ;(+ (y * x) (z + y) * 5)
# #+END_SRC

# We have shortcut transforming to AST and back to infix form by this. With this,
# we can easily implement rest:
# - The predicates
#   #+BEGIN_SRC scheme
# (define (sum? iexp)
#   (and (pair? iexp)
#        (pair? (cdr iexp))
#        (let ((pAST (->pseudoAST iexp)))
#          (eq? (car pAST) '+))))

# (define (product? iexp)
#   (and (pair? iexp)
#        (pair? (cdr iexp))
#        (let ((pAST (->pseudoAST iexp)))
#          (eq? (car pAST) '*))))
#   #+END_SRC
# - The selectors
# #+BEGIN_SRC scheme
# (define (addend is)
#   (let ((pAST (->pseudoAST is)))
#     (cadr is)))
# (define (augend is)
#   (let ((pAST (->pseudoAST is)))
#     (cddr is)))
# (define (multiplier im)
#   (let ((pAST (->pseudoAST is)))
#     (cadr im)))
# (define (multiplicand im)
#   (let ((pAST (->pseudoAST is)))
#     (cddr im)))
# #+END_SRC
# - The constructors are same as part *a.*

# ↑ doesn't work. I should have not cheat this.

Well, we did it, but we did not include the exponentiation expression. Our
standard infix form should accommodate that expression? Although the statement
of this exercise did not mention it, isn't it cool if we can handle the
exponentiation? If we can accomplish that thing, we can extend further more!

First we need to redesign our ~->AST~ procedure. It is possible to cope with
exponentiation just modifying our existing procedure; but the result would be
quite mess--hard to recognize and maintain, no logic behind, etc.

****** Try: Let we assume there are specialist who can only handle specific operation.
For instance, ~expt->AST~ can convert only exponentiation to AST and so on.

The flow of overall ~->AST~ procedure can be described as
#+BEGIN_SRC text
infix form => inital setup + handle base case => expt->AST => prod->AST
=> sum->AST => AST(output)
#+END_SRC

We can specify the ~<??>->AST~'s behavior:
- should take infix form with partially built AST.
- should return partially built AST whit rest infix form where the first
  operation is not ~<??>~.


So, for example, the output of ~expt->AST~ should satisfy that its first ~op~ is
either ~+~ or ~*~ (or no operation left in infix form); by the same argument,
when it comes to ~sum->AST~ the first ~op~ should ~+~ (or as mentioned no more
operation).

Let we code it:
#+BEGIN_SRC scheme
(define (->AST iexp)
  (cond ((not (pair? iexp))             ;symbol--singleton
         iexp)
        ((null? (cdr iexp))             ;eof mark
         (if (pair? (car iexp))
             (->AST (car iexp))         ;turns out compound exp
             (car iexp)))               ;it was singleton
        (else (expt->AST (cdr iexp) (->AST (car iexp)))))) ;recursive process
(define (expt->AST iexp AST)
  (cond ((null? iexp) AST)              ;eof
        ((and (symbol? (car iexp))
              (eq? (car iexp) '**))
         (expt->AST (cddr iexp) (list '** AST (->AST (cadr iexp)))))
        (else (prod->AST iexp AST))))
(define (prod->AST iexp AST)
  (cond ((null? iexp) AST)
        ((and (symbol? (car iexp))
              (eq? (car iexp) '*))
         (prod->AST (cddr iexp) (list '* AST (->AST (cadr iexp)))))
        (else (sum->AST iexp AST))))
(define (sum->AST iexp AST)
  (cond ((null? iexp) AST)
        ((and (symbol? (car iexp))
              (eq? (car iexp) '+))
         (list '+ AST (->AST (cdr iexp))))))
#+END_SRC

The results:
#+BEGIN_SRC scheme
(->AST '(x + 3 * (x + y + 2)))          ;(+ x (* 3 (+ x (+ y 2))))
(->AST '(x ** 4 * (x * 2 + y + 2)))     ;(* (** x 4) (+ (* x 2) (+ y 2)))
#+END_SRC

Works well!

The rest are the predicate, selectors and constructors of exponentiation, which
can be accomplished using analogy with others:
#+BEGIN_SRC scheme
(define (exponentiation? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (let ((ast (->ast iexp)))
         (eq? (car ast) '**))))

(define (base iexp)
  (let ((ast (->ast iexp)))
    (->infix (cadr ast))))

(define (exponent iexp)
  (let ((ast (->ast iexp)))
    (->infix (caddr ast))))

(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        ((and (number? base) (number? exponent))
         (expt base exponent))
        (else (list base '** exponent))))
#+END_SRC

Let's test our last piece:
#+BEGIN_SRC scheme
(deriv '(x ** 4 * (x * 2 + y + 2)) 'x)
;;((((x * 2) + (y + 2)) * (4 * (x ** 3))) + (2 * (x ** 4)))
#+END_SRC

Done.

#  LocalWords:  AST
*** Example: Representing Sets
We can abstract out the representation of set by using data abstraction: As long
as we have ~union-set~, ~intersection-set~, ~element-of-set?~, and ~adjoin-set~
we can do anything as with normal set. Those procedures can be thought as
interface of object set or axioms of set:
- ~(element-of-set? x (union-set S1 S2))~ is equivalent to
  ~(or (element-of-set? x S1) (element-of-set? x S2)~
- ~(element-of-set? x (intersection-set S1 S2))~ is equivalent to
  ~(and (element-of-set? x S1) (element-of-set? x S2)~
- For any element ~x~ and set ~S~, ~(element-of-set? x (adjoin-set x S))~ is ~true~


All the representation that satisfy all the axioms above can be treat as set.

**** Sets as unordered lists
Here we represent a set as list of its elements in which no element appears more
than once. As we are going to represent sets as ordered lists, we name this
representation as unordered list representation.

As we mentioned ~adjoin-set~ should adjoin member if and only if member is not
already ~element-of-set?~:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
#+END_SRC

Then ~element-of-set?~ get straightforward:
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
#+END_SRC

For the ~intersection-set~ we can rely on induction on either of each arguments:
#+BEGIN_SRC scheme
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
#+END_SRC
**** Exercise 2.59
Finally, ~union-set~ can be implemented as append-like procedure:
#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        (else (adjoin-set (car set1)
                          (union-set (cdr set1) set2)))))
#+END_SRC
This procedure has \Theta(n^{2}) step complexity as ~intersection-set~.
**** Exercise 2.60
What if we represent a set as a list allowed to be duplicate? We don't need to
check if the member already in the given set to adjoin:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (cons x set))
#+END_SRC

And others doesn't have to change at all but the complexity change. As
~adjoin-set~ became \Theta(1) of step complexity, ~union-set~, which depends on
~adjoin-set~, get to have \Theta(n) of step complexity, where n is the size of ~set1~.

The complexity of the others-- ~element-of-set?~, ~intersection-set~-- doesn't
change at all but now the concept of size of set has changed; although it is
same along with the specification, the size of it can depend on representation,
e.g. ~{1,2,1,1,1,1}~ has two member in it--1,2-- and also it is ~{1,2}~ but
those differ in size--6, 2 respectively.

If we use ~adjoin-set~ (and ~union-set~) a lot and sarcely ~element-of-set~ (or
~intersection-set~) then current version would be more efficient than previous
one, vice versa.
**** Sets as ordered lists
To simplify our discussion, we consider only the case where the set elements are
numbers. This section is well documented in text book. So we just jot down
necessary procedures here:
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) false)
        (else (element-of-set? x (cdr set)))))

(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1))
            (x2 (car set2)))
        (cond ((= x1 x2) (cons x1 (intersection-set (cdr set1)
                                                    (cdr set2))))
              ((< x1 x2) (intersection-set (cdr set1) set2))
              ((> x1 x2) (intersection-set set1 (cdr set2)))))))
#+END_SRC
**** Exercise 2.61
We know that if the member, which we are about to adjoin in given set, is
smaller then the ~(car set)~ then the member are not contained in given set;
if the member equals to ~(car set)~ then we don't have to do anything,
else we should look up the ~cdr~ of set recursively. Then we end up with
base case--nil of set; we just ~cons~ our member with nil:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (if (null? set)
      (list x)
      (let ((hd (car set)))
        (cond ((< x hd) (cons set))
              ((= x hd) set)
              (else
               (adjoin-set x (cdr set)))))))
#+END_SRC
**** Exercise 2.62
To give \Theta(n) growth ~union-set~, we exploit the idea behind the
~intersection-set~. I've got quite bored with jotting down all the rules that
governs the algorithm; as this implementation is straightforward, let me just
show them:
#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (let ((x1 (car set1))
              (x2 (car set2)))
          (cond ((= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2))))
                ((< x1 x2) (cons x1 (union-set (cdr set1) set2)))
                ((> x1 x2) (cons x2 (union-set set1 (cdr set2))))))))
#+END_SRC
**** Sets as binary trees
Here we represent sets as binary trees--composed by entry, left branch, right
branch. In turns, we have to represent the binary tree which satisfy following
axioms:
- ~(entry (make-tree entry left right))~ equals to ~entry~
- ~(left-branch (make-tree entry left right))~ equals to ~left~
- ~(right-branch (make-tree entry left right))~ equals to ~right~


Here is one of representation that satisfy above axioms:
#+BEGIN_SRC scheme
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
#+END_SRC

Given with above, we can write ~element-of-set?~ procedure:
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (if (null? set)
      false
      (let ((hd (entry set)))
        (cond ((= x hd) true)
              ((< x hd) (element-of-set? x (left-branch set)))
              ((> x hd) (element-of-set? x (right-branch set)))))))
#+END_SRC

For the ~adjoin-set~ we recursively branching down the tree whether entry is
equals to given member or not; if there is no such entry, it end up with empty
tree, at that point, we should construct new tree and put the all pieces
together appropriately:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (if (null? set)
      (make-tree x '() '())
      (let ((hd (entry set)))
        (cond ((= x hd) set)
              ((< x hd) (make-tree hd
                                   (adjoin-set x (left-branch set))
                                   (right-branch set)))
              ((> x hd) (make-tree hd
                                   (left-branch set)
                                   (adjoin-set x (right-branch set))))))))
#+END_SRC
**** Exercise 2.63
#+BEGIN_SRC scheme
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
  (copy-to-list tree '()))
#+END_SRC
***** a.
We prove both produce the same result-- ordered list.
For the former, we can prove the assertion by induction on the depth of tree.
For the latter, we prove the assertion by using the invariance that
~copy-to-list~ returns ordered list of given tree with appending the
~result-list~ at the end.

As consequence, the figure 2.16 end up with ~(1 2 3 4 5 6 7)~.
***** b.
For the former, if we estimate the size of input as number of entries of tree,
then we get the following differential equation:
\[f \left( n \right) - 2 f \left( n/2 \right) = \Theta \left( n/2 \right)\],
which end up with
\[f \left( n \right) = \Theta(n) + \Theta (n \log n)\].
As consequence, we got $\Theta(n \log n)$ step complexity.

For the latter, it becomes
\[ f(n) - 2 f(n/2) = \Theta (1) \];
it can be concluded as
\[f(n) = \Theta(n) + \Theta(\log n) = \Theta(n)\], i.e. $\Theta(n)$ step complexity.
**** Exercise 2.64
#+BEGIN_SRC scheme
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+1 left-size))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts)
                                              right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
#+END_SRC
***** a.
The ~partial-tree~'s behavior is as follows
- given with ordered list ~elts~ it returns pair that contains balanced tree
  with first ~n~ elements from the ~elts~ with ordered list but first ~n~ elements.


This is just specification that we want to implement for ~list->tree~. Then how
to implement it? We have the powerful strategy, wishful thinking:
Let we assume that for all inputs that has less than ~n~ ~partial-tree~
implemented by John. Our task is to complete the ~partial-tree~ for the inputs
with ~n~. Here is the idea:
1. First, build the left half tree with the ~elts~.
2. And then, take one element from the remaining ~elts~ from step 1.
3. Using the rest elements construct right half tree.
4. Build whole tree using ~make-tree~ with above left tree, entry, right tree
   from 1, 2, 3, respectively.
5. Returns pair consisting the tree built from step 4 with remaining elements
   from step 3.


The straightforward implementation is shown above. Note that we used for the
~left-size~ since we have to satisfy the relation-- $n - 1 \ge 2 ~\text{left-size}$.
***** b.
Analogous to [[Exercise 2.63][previous exercise]], we can deduce that the order of growth of this
implementation is \Theta(n).
**** Exercise 2.65
***** ~intersection-set~
After I've played with some examples, I concluded that the ordered list version
of it is quite ideal implementation than using tree. Given with exercise 2.63,
we can revert the (balanced) tree to ordered list.

Then we simply put together all the modules:
#+BEGIN_SRC scheme
(define (intersection-set set1 set2)
  (let ((ol1 (tree->list-2 set1))
        (ol2 (tree->list-2 set2)))
    (list->tree (intersection-setl ol1 ol2))))
#+END_SRC
Here I rephrase the previous version of ~intersection-set~ as
~intersection-setl~ for denoting ordered list.

Similarly, we can do same thing to ~union-set~:
#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (let ((ol1 (tree->list-2 set1))
        (ol2 (tree->list-2 set2)))
    (list->tree (union-setl ol1 ol2))))
#+END_SRC

These have all \Theta(n) order of growth.
**** Exercise 2.66
As we know that ~lookup~ is analogous to ~element-of-set?~, here also we can
implement using that observation:
#+BEGIN_SRC scheme
(define (lookup given-key set)
  (if (null? set)
      false
      (let ((hd (key (entry set))))
        (cond ((= given-key hd) true)
              ((< given-key hd) (lookup given-key (left-branch set)))
              ((> given-key hd) (lookup given-key (right-branch set)))))))
#+END_SRC
*** Example: Huffman Encoding trees
**** Representing Huffman trees
Here we represent Huffman tree as weighted tree. The leaf can be represented as
#+BEGIN_SRC scheme
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
#+END_SRC

A general tree will be a list of left branch, a right branch, a set of symbols,
and as weight. The set of symbols will be simply a list of the symbols, which
contains all the symbols of leaves under the tree. And weight will be number
which indicate sum of leaves' weights under the tree. As I noted before, the
~append~ operation is very similar to ~union~. Here, as we represent the set of
symbols as just list, we can get the behavior of ~union~ using ~append~:
#+BEGIN_SRC scheme
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))
#+END_SRC

The other interface procedures determined by this representation:
#+BEGIN_SRC scheme
(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
#+END_SRC
**** The decoding procedure
Given bits with Huffman tree, we can start decode with each bit from the
leftmost bit to determine how to choose next branch in the tree. If we
encountered with leaf, then it means we decoded one symbol in message.
Repeatedly decoding the symbols, and accumulating the symbols in list, we
complete the decoding process. It is natural to decompose this decoding
procedure to decoding one symbol, procedure to choose branch with the current
bit and branch of tree, accumulating the result symbols and determining
termination condition. Here is one possible implementation:
#+BEGIN_SRC scheme
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bat bit -- CHOOSE-BRANCH" bit))))
#+END_SRC

Here we merged somehow decode one symbol with accumulating & terminating; we
found that it is way more concise than bothering to decompose with the described
fashion.
**** Sets of weighted elements
The tree-generating algorithm requires to choose smallest nodes in the set. To
do this, it is more convenient to represent a set as an ordered list as we did
before. However, in this situation, provided that the element being adjoined to
the set is not in the set. Using this fact we can ~adjoin-set~ more efficiently:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
#+END_SRC

Using this, we can construct the ordered list of pairs, which contains symbol
with frequency:
#+BEGIN_SRC scheme
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair) ;symbol
                               (cadr pair)) ;frequency
                    (make-leaf-set (cdr pairs))))))
#+END_SRC
**** Exercise 2.67
#+BEGIN_SRC scheme
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
;; test
(decode sample-message sample-tree)     ;(a d a b b c a)
#+END_SRC
**** Exercise 2.68
The ~encode~ process can be decomposed as
#+BEGIN_SRC scheme
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
#+END_SRC

Then we should implement the ~encode-symbol~ procedure that encode one symbol as
sequence of bits. This procedure also should raise exception when there is not
such symbol in the tree. We can deduce the algorithm by playing with it:
1. Test whether the symbol included in tree.
2. If not raise error, else choose next branch that contains given symbol.
3. If we get all the way down to the leaf (which also contains given symbol by
   contract) return the accumulated bits.


When we code this algorithm, we get
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

(define (encode-symbol symbol tree)
  (define (encode-1 current-branch)
    (if (leaf? current-branch)
        '()
        (if (element-of-set? symbol
                             (symbols (left-branch current-branch)))
            (cons 0
                  (encode-1 (left-branch current-branch)))
            (cons 1
                  (encode-1 (right-branch current-branch))))))
  (if (not (element-of-set? symbol (symbols tree)))
      (error "bad symbol -- ENCODE-SYMBOL" symbol)
      (encode-1 tree)))
;; test
(encode (decode sample-message sample-tree) sample-tree) ;(0 1 1 0 0 1 0 1 0 1 1 1 0)
#+END_SRC
**** Exercise 2.69
I've designed in my personal note. The result:
#+BEGIN_SRC scheme
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successive-merge leaf-set)     ;provided that leaf-set is list
  (cond ((null? leaf-set) '())
        ((null? (cdr leaf-set)) (car leaf-set)) ;termination condition
        (else                                   ;provided that it has atleast 2 leaves in this
         (let ((leaf1 (car leaf-set))
               (leaf2 (cadr leaf-set))
               (rest-set (cddr leaf-set)))
         (successive-merge (adjoin-set (make-code-tree leaf1 leaf2)
                                       rest-set))))))
;;test
(define sample-pairs '((A 4) (B 2) (C 1) (D 1)))
(decode sample-message (generate-huffman-tree sample-pairs)) ;(a d a b b c a)
#+END_SRC
**** Exercise 2.70
If we do the instructions, we get
#+BEGIN_SRC scheme
(define rock-pairs '((A 2) (BOOM 1) (GET 2) (JOB 2) (NA 16) (SHA 3) (YIP 9) (WAH 1)))
(define rock-tree (generate-huffman-tree rock-pairs))
(define rock-message '(Get a job
                           Sha na na na na na na na na
                           Get a job
                           Sha na na na na na na na na
                           Wah yip yip yip yip yip yip yip yip yip
                           Sha boom))
(define rock-code (encode rock-message rock-tree))
(length rock-code)                      ;84
#+END_SRC

In Huffman encoding, we need 84 bits for encoding the message. If we have used
fixed-length code for eight-symbol alphabet--we need at least 3 bits per
symbol, we get ~(* 3 (length rock-message))~ that evaluated to 108. We saved
about 22% bits for encoding the message.
**** Exercise 2.71
We can prove by induction on /n/ or on depth of tree that the most frequent
symbol requires 1 bit to encode and for the least frequent one /n-1/ bits.
**** Exercise 2.72
For the given special case, we can prove that for the most frequent one the
order of growth is \Theta(n) and for the least frequent one \Theta(n^{2}) at the
worst case.
* Footnotes

[fn:2] Note that we naturally inherit the lisp's power, that is, of manipulating
list. That means we don't have to parse all the expression to get the token,
which we have to do usually when we implement the complier or interpreter.

[fn:1] Well, there are several candidates for doing this like [[http://plantuml.com/en/][plantUML]], [[https://www.graphviz.org/][dot]]
, etc. If I can afford to learn those, I'd like to upload these study note as well someday.

#  LocalWords:  SICP
