#+TITLE: Metalinguistic Abstraction
/Metalinguistic Abstraction/ -- establishing new languages -- plays an important
role in all branches of engineering design. It is particularly important to
computer programming, because in programming /not only can we formulate new
languages but we can also implement these languages by constructing evaluators/.

* The Metacircular Evaluator
** The Core of the Evaluator
In this section we use the syntax operations (the representation for the syntax
of language being implemented) to implement the =eval= and =apply= process. Our
evaluator uses several ADTs each for syntax for language being implemented and the
internal representations for internal evaluation model -- environment.
*** Exercise 4.1
We can force the order by using =let= statement -- since it is just syntactic
sugar for lambda application, the value of each bindings of =let= expression
evaluated before evaluating the body of it.
#+BEGIN_SRC scheme
;;; Left to Right
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((first (eval (first-operand exps) env)))
        (cons first
              (list-of-values (rest-operands exps) env)))))
;;; Right to Left
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((rest (list-of-values (rest-operands exps) env)))
        (cons (eval (first-operand exps) env)
              rest))))
#+END_SRC
** Representing Expressions
It is reminiscent of the symbolic differentiation program discussed in section
2.3.2; each expression has its own type tag in it, so our evaluator dispatch on
this type and recursively evaluate the nested expression.
*** Exercise 4.2
**** a.
It will deal the assignment expression as if it is procedure application since
procedure application expression doesn't have any type for specifying it so any
the pairs not sifted by the =cond= clauses before that clause treated as
procedure application. So =(define x 3)= are treated procedure application and,
in turn, evaluator lookup the =define= variable; since it couldn't find any it
will signal error -- undefined variable.
**** b.
Here is the fix:
#+BEGIN_SRC scheme
(define (application? exp) (tagged-list? exp 'call))
#+END_SRC
*** Exercise 4.3
We can rely on the data-directed style only for the tagged expressions:
#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        (else
         (let ((op (and (tagged-exp? exp)
                        (get 'eval (type-tag exp)))))
           (cond (op (op exp env))
                 ((application? exp)
                  (apply (eval (operator exp) env)
                         (list-of-values (operands exp) env)))
                 (else
                  (error "Unknown expression type -- EVAL" exp)))))))
#+END_SRC

The procedures of =tagged-exp= ADT:
#+BEGIN_SRC scheme
(define (type-tag exp)
  (car exp))
(define (tagged-exp? exp)
  (pair? exp))
#+END_SRC

Then install the contents:
#+BEGIN_SRC scheme
(define (install-eval-clauses)
  (put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
  (put 'eval 'set! eval-assignment)
  (put 'eval 'define eval-definition)
  (put 'eval 'if eval-if)
  (put 'eval 'lambda (lambda (exp env)
                       (make-procedure (lambda-parameters exp)
                                       (lambda-body exp)
                                       env)))
  (put 'eval 'begin (lambda (exp env)
                      (eval-sequence (begin-actions exp) env)))
  (put 'eval 'cond (lambda (exp env)
                     (eval (cond->if exp) env)))
  'done)
#+END_SRC

I've implemented the type tags directly for simplicity.
*** Exercise 4.4
**** As special expression
#+BEGIN_SRC scheme
(define (install-eval-and-or-direct)
  ;; and eval
  (define (eval-and exp env)
    (eval-and-subs (subexps exp) env))
  (define (eval-and-subs subs env)
    (cond ((null? subs) (eval 'true env))
          ((last-sub? subs) (eval (first subs) env))
          (else
           (if (true? (eval (first-sub subs) env))
               (eval-and-subs (rest-subs subs) env)
               (eval 'false env)))))

  ;; or eval
  (define (eval-or exp env)
    (eval-or-subs (subexps exp) env))
  (define (eval-or-subs subs env)
    (cond ((null? subs) (eval 'false env))
          ((last-sub? subs) (eval (first subs) env))
          (else
           (let ((current
                  (eval (first-sub subs) env)))
             (if (false? current)
                 (eval-or-subs (rest-subs subs) env)
                 current)))))

  ;; selector on And or Or expression
  (define (subexps exp) (cdr exp))
  ;; sub ADT
  (define (last-sub? subs)
    (and (pair? subs) (null? (cdr subs))))
  (define first-sub car)
  (define rest-subs cdr)

  ;; interface with eval procedure
  (put 'eval 'and eval-and)
  (put 'eval 'or eval-or)
  'done)
#+END_SRC

Here we used data-directed style =eval= from [[Exercise 4.3][ex 4.3]].

Then setup for test:
#+BEGIN_SRC scheme
(define eval-table (make-hash-table))
(define (put op type item)
  (if (eq? op 'eval)
      (hash-table-set! eval-table type item)
      (error "Unallowed operation -- PUT" op)))
(define (get op type)
  (if (eq? op 'eval)
      (hash-table-ref eval-table type (lambda () #f))
      (error "Unknown operation -- GET" op)))
#+END_SRC

Let's run!
#+BEGIN_SRC scheme
1 ]=> (install-eval-clauses)

;Value: done

1 ]=> (install-eval-and-or-direct)

;Value: done

1 ]=> (driver-loop)

;;; M-Eval input:
(and)

;;; M-Eval value:
#t

;;; M-Eval input:
(and 5)

;;; M-Eval value:
5

;;; M-Eval input:
(and false)

;;; M-Eval value:
#f

;;; M-Eval input:
(and false 5 2)

;;; M-Eval value:
#f

;;; M-Eval input:
(and 5 2)

;;; M-Eval value:
2

;;; M-Eval input:
(and 5 false)

;;; M-Eval value:
#f

;;; M-Eval input:
(or)

;;; M-Eval value:
#f

;;; M-Eval input:
(or 5)

;;; M-Eval value:
5

;;; M-Eval input:
(or false 5 false flase)

;;; M-Eval value:
5

;;; M-Eval input:
(or false 5 false)

;;; M-Eval value:
5

;;; M-Eval input:
(or false false 5)

;;; M-Eval value:
5

#+END_SRC

Or we could test this in unit:
#+BEGIN_SRC scheme
(install-eval-clauses)

;Value: done

(install-eval-and-or-direct)

;Value: done

(eval '(and 5) the-global-environment)

;Value: 5

(eval '(and false 5) the-global-environment)

;Value: #f

(eval '(or 5 false) the-global-environment)

;Value: 5
#+END_SRC
**** As derived expression
This is analogous to =cond=:
#+BEGIN_SRC scheme
define (install-eval-and-or-derived)
  (define (expand-or-subs subs)
    (cond ((null? subs) 'false)
          ((null? (cdr subs)) (car subs))
          (else
           (let ((first (car subs)))
             (make-let
              (list (list 'first first))
              (list (make-if 'first
                        'first
                        (expand-or-subs (cdr subs)))))))))
  (define (expand-and-subs subs)
    (cond ((null? subs) 'true)
          ((null? (cdr subs)) (car subs))
          (else
           (make-if (car subs)
                    (expand-and-subs (cdr subs))
                    'false))))

  (define (and->if exp)
    (expand-and-subs (cdr exp)))

  (define (or->if exp)
    (expand-or-subs (cdr exp)))

  (put 'eval 'and (lambda (exp env)
                    (eval (and->if exp) env)))
  (put 'eval 'or (lambda (exp env)
                   (eval (or->if exp) env)))
  'done)
#+END_SRC
For =or=, we used =make-let= to reuse the result of evaluation of first
subexpression in case where it turns out true.

Here is =make-let= syntax procedure that is analogous to =make-lambda=
#+BEGIN_SRC scheme
;; List<binding>, List<expression> -> Let
(define (make-let bindings body)
  (cons 'let (cons bindings body)))
#+END_SRC

Then test!
#+BEGIN_SRC scheme
(install-eval-and-or-derived)

;Value: done

(eval '(and 5) the-global-environment)

;Value: 5

(eval '(and false 5) the-global-environment)

;Value: #f

(eval '(and true 2 true) the-global-environment)

;Value: #t
#+END_SRC

For the =or= part, we delegate the test until we implement the =let= expression
in our evaluator ([[Exercise 4.6][ex 4.6]])
*** Exercise 4.5
We can support this new feature through either special form or derived form. The
key issue is that is it okay re-evaluate the =<test>= expression twice?
- If it is okay, the only change that we should make is the =sequence->exp= part
  of =expand-clauses= into
  #+BEGIN_SRC scheme
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (cond-actions->exp first)
                     (expand-clauses rest))))))

(define (cond-actions->exp clause)
  (let ((actions (cond-actions clause)))
    (if (eq? (car actions) '=>)
        (if (and (pair? (cdr actions))
                 (null? (cddr actions)))
            (list (cadr actions) (cond-predicate clause))
            (error "Illformed expression -- COND-MAP" clause))
        (sequence->exp actions))))
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr)
                         (else false)) the-global-environment)

;Value: 4

(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Illformed expression -- COND-MAP ((cons 3 4) => cdr 3)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC
- If it is not, in other word, we are constrained to evaluate the =cond-predicate=
  only once, we do use =make-let= as we did in the previous exercise.
  #+BEGIN_SRC scheme
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (let ((pred (cond-predicate first)))
              (make-let
               (list (list 'pred pred))
               (list (make-if 'pred
                              (map-or-sequence->exp
                               (cond-actions first) 'pred)
                              (expand-clauses rest)))))))))

(define (map-or-sequence->exp actions pred)
  (if (eq? (car actions) '=>)
      (if (and (pair? (cdr actions))
               (null? (cddr actions)))
          (list (cadr actions) pred)
          (error "Illformed expression -- COND-MAP" clause))
      (sequence->exp actions)))
  #+END_SRC
*** Exercise 4.6
#+BEGIN_SRC scheme
(define (install-eval-let)
  (define (let->combination exp)
    (let* ((bindings (bindings exp))
           (unziped-b
            (fold-right
             (lambda (var-exp vars-exps)
               (cons (cons (car var-exp) (car vars-exps))
                     (cons (cadr var-exp) (cdr vars-exps))))
             (cons '() '())
             bindings))
           (params (car unziped-b))
           (exps (cdr unziped-b)))
      (cons (make-lambda params (body exp))
            exps)))

  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let (lambda (exp env)
                    (eval (let->combination exp) env)))
  'done)
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(eval '(let ((x 1)) (cons x 2)) the-global-environment)

;Value: (1 . 2)

(eval '(let ((x 1)) (cons x 2) (cons 2 x)) the-global-environment)

;Value: (2 . 1)
#+END_SRC

Then now we can test the =or= of derived version:
#+BEGIN_SRC scheme
(install-eval-and-or-derived)

;Value: done

(eval '(or 5 false) the-global-environment)

;Value: 5

(eval '(or false 5 false) the-global-environment)

;Value: 5
#+END_SRC

And derived =cond='s new feature:
#+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr)
                         (else false)) the-global-environment)

;Value: 4

(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Unbound variable: clause
#+END_SRC
By test it we found the bug in our previous error handling. It is easy to fix.
After fixing,
#+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Illformed expression -- COND-MAP (=> cdr 3)
#+END_SRC
It works as expected.
*** Exercise 4.7
#+BEGIN_SRC scheme
(define (install-eval-let*)
  (define (let*->let exp)
    (define (expand-let* bindings)
      (if (null? bindings)
          (body exp)
          (let ((first (car bindings))
                (rest (cdr bindings)))
            (make-let
             (list first)
             ((if (null? rest)
                  identity-procedure
                  list) ;for the type contraction of make-let
              (expand-let* rest))))))
    (expand-let* (bindings exp)))
  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let* (lambda (exp env)
                     (eval (let*->let exp) env)))
  'done)
#+END_SRC
It suffices to define =let*= as derived expression since subsequent derived
expression reduced to non-derived expression by =eval= and =apply= loop, which
in turn reduced to primitive expressions.

Then test:
#+BEGIN_SRC scheme
(install-eval-let*)

;Value: done

(eval
 '(let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))
 the-global-environment)

;Value: 39
#+END_SRC
*** Exercise 4.8
First let we code the test:
#+BEGIN_SRC scheme
(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)
;; ok
(eval
 '(fib 3)
 the-global-environment)
;; 1
#+END_SRC

And note that by using the environment model, we can deduce named let expression
=(let <var> <bindings> <body>)= is equivalent to
#+BEGIN_SRC scheme
(let ((<var> undef))
  (set! <var>
    (lambda <params of bindings> body))
  (apply <var> <exps of bindings>))
#+END_SRC

So we convert named let expression above equivalent expression.

Here is the result:
#+BEGIN_SRC scheme
(define (install-eval-let-with-named)
  ;; ADT for named
  (define (named? exp)
    (and (pair? exp)
         (pair? (cdr exp))
         (symbol? (cadr exp))))

  (define (named exp)
    (cadr exp))

  (define (except-name-let exp)
    (cdr exp))

  (define (let->combination exp)
    (let* ((bindings (bindings exp))
           (unziped-b
            (fold-right
             (lambda (var-exp vars-exps)
               (cons (cons (car var-exp) (car vars-exps))
                     (cons (cadr var-exp) (cdr vars-exps))))
             (cons '() '())
             bindings))
           (params (car unziped-b))
           (exps (cdr unziped-b)))
      (cons (make-lambda params (body exp))
            exps)))

  (define (named->let-combination exp)
    (let ((var (named exp))
          (comb (let->combination
                 (except-name-let exp))))
      (let ((lambda-part (car comb))
            (exps (cdr comb)))
        (make-let
         (list (list var (list 'quote undef)))
         (list
          (make-assignment var
                           lambda-part)
          (cons var
                exps))))))

  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let (lambda (exp env)
                    (eval (if (named? exp)
                              (named->let-combination exp)
                              (let->combination exp)) env)))
  'done)
#+END_SRC

And the auxiliary parts:
#+BEGIN_SRC scheme
(define undef '*unassigned*)
(define (make-assignment var val)
  (list 'set! var val))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
(install-eval-let-with-named)

;Value: done

(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)

;Value: ok

(eval
 '(fib 3)
 the-global-environment)

;Unbound variable =
#+END_SRC

Huh, we should set ~=~ (and also =-=) as primitive procedure in our environment.
Do that and re-run:
#+BEGIN_SRC scheme
(install-eval-clauses)

;Value: done

(install-eval-let-with-named)

;Value: done

(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)

;Value: ok

(eval
 '(fib 3)
 the-global-environment)

;Value: 2

(eval
 '(fib 2)
 the-global-environment)

;Value: 1
#+END_SRC

Oh-huh there are good news and bad news:
- Our test code was wrong! =(fib 3)= should return 2 not 1 as it count from 0!
- Our code works right!

*** Exercise 4.9
For example, here we try to implement typical imperative control structure,
=while=. Let us think about the what syntax should it be? Analogous to any other
imperative programming language, let we make our syntax as follows:
#+BEGIN_SRC scheme
(while <pred>
  <exp1>
  ...
  <expN>)
#+END_SRC

The semantic of this control structure are followings:
1. Evaluate =<pred>= first.
2. If it true, execute from =<exp1>= until =<expN>= sequentially; Then go to *1.*
3. If it was false, then return the control to consequent structure (return
   undefined value).


All of the above expressions should be evaluated in a same environment; we don't
need to extend the given environment.

Then here is the code:
#+BEGIN_SRC scheme
(define (install-eval-while)
  (define pred cadr)
  (define body cddr)
  (define (eval-while exp env)
    (let ((bexp (sequence->exp (body exp))))
      (let loop ()
        (if (true? (eval (pred exp) env))
            (begin (eval bexp env)
                   (loop))
            'done))))
  (put 'eval 'while eval-while)
  'done)
#+END_SRC

Then here is the test code:
#+BEGIN_SRC scheme
(eval '(begin
         (define x 5)
         (define sum 0)
         (while (> x 0)
           (set! sum (+ x sum))
           (set! x (-1+ x)))
         sum)
      the-global-environment)
;Should return 15
#+END_SRC

And run:
#+BEGIN_SRC scheme
(eval '(begin
         (define x 5)
         (define sum 0)
         (while (> x 0)
           (set! sum (+ x sum))
           (set! x (-1+ x)))
         sum)
      the-global-environment)

;Value: 15
#+END_SRC

Sweet!
*** Exercise 4.10
Here we will use dispatch on type rather than data-directed style since we are
going to mix the infix expressions with prefix expressions. Specifically we will
transform the assignment notation and that of definition into infix notation:
- From =(set! <var> <exp>)= to =(<var> <- <exp>)=;
- From =(define <var> <exp>)= to =(<var> = <exp>)=.


All we need to change is the detectors and selectors:
- From
  #+BEGIN_SRC scheme
;; detector
(define (assignment? exp)
  (tagged-list? exp 'set!))

;; selectors
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
  #+END_SRC
  to
  #+BEGIN_SRC scheme
;; detector
(define (assignment? exp)
  (infix-tag-list? exp '<-))

;; selectors
(define (assignment-variable exp) (car exp))
(define (assignment-value exp) (caddr exp))
  #+END_SRC
- From
  #+BEGIN_SRC scheme
;; detector
(define (definition? exp)
  (tagged-list? exp 'define))

;; selectors
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))
  #+END_SRC
  to
  #+BEGIN_SRC scheme
;; detector
(define (definition? exp)
  (infix-tag-list? exp '=))

;; selectors
(define (definition-variable exp)
  (if (symbol? (car exp))
      (car exp)
      (caar exp)))
(define (definition-value exp)
  (if (symbol? (car exp))
      (caddr exp)
      (make-lambda (cdar exp)
                   (cddr exp))))
  #+END_SRC


Then the test code:
#+BEGIN_SRC scheme
;; Test infix defintion
(eval '(begin (x = 2)
              x)
      the-global-environment)
;; 2
;; procedure definition
(eval
 '((factorial n) = (if (= n 1)
                       1
                       (* n (factorial (-1+ n)))))
 the-global-environment)
;; ok
(eval '(factorial 3) the-global-environment)
;; 6


;; test infix assignment
(eval '(begin (x <- 5)
              x)
      the-global-environment)
;; 5
#+END_SRC

Then let's run
#+BEGIN_SRC scheme
(eval '(begin (x = 2)
              x)
      the-global-environment)

;Value: 2

(eval
 '((factorial n) = (if (= n 1)
                       1
                       (* n (factorial (-1+ n)))))
 the-global-environment)

;Value: ok

(eval '(factorial 3) the-global-environment)

;Value: 6

(eval '(begin (x <- 5)
              x)
      the-global-environment)

;Value: 5
#+END_SRC
** Evaluator Data Structures
*** Exercise 4.11
This is same as replace our frame data structure with table as we did in section
3.3. Then the changes are trivial:
#+BEGIN_SRC scheme
;; For extend-environment
(define (make-frame vars vals)
  (let ((bindings
         ;; provided that the length of both arguments match
         (fold-right
          (lambda (var val bindings)
            (cons (list var val) bindings))
          '()
          vars
          vals))
        (tbl (make-table)))
    (set-bindings! tbl bindings)
    tbl))

;; Table ADT
;; constructor
(define (make-table)
  (list '*table*))
;; mutator
(define set-bindings! set-cdr!)
;; selector
(define bindings cdr)

;; For lookup-variable-value
(define (lookup-variable-value var env)
  (let env-loop ((env env))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (cond ((assoc var (bindings frame)) => cadr)
                (else (env-loop
                       (enclosing-environment env))))))))

;; For set-variable-value!
(define (set-variable-value! var val env)
  (let env-loop ((env env))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (cond ((assoc var (bindings frame))
                 => (lambda (b) (set-car! (cdr b) val)))
                (else (env-loop
                       (enclosing-environment env))))))))

;; For define-variable!
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (cond ((assoc var (bindings frame))
                 => (lambda (b) (set-car! (cdr b) val)))
          (else (set-bindings! frame
                               (cons (list var val)
                                     (bindings frame)))))))
#+END_SRC

By using the built in procedures about the alist structure, we could write our
procedures more succinctly; this leads that we recognize the common patterns in
above procedures more obviously, which we revisit in the next exercise.

Return to our discourse, let we code the test:
#+BEGIN_SRC scheme
;; test definition
(eval '(define test-def 0) the-global-environment)
;; ok

;; test assignment in nested frame
(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)
;; ok

(eval 'test-def the-global-environment)
;; 0

(eval '(test-assignment) the-global-environment)
;; ok

;; test lookup-variable-value
(eval 'test-def the-global-environment)
;; 5

;; verify that we using the new data structure for frame
(caar the-global-environment)
;; *table*
#+END_SRC

Then run:
#+BEGIN_SRC scheme
(eval '(define test-def 0) the-global-environment)

;Value: ok

(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 0

(eval '(test-assignment) the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 5

(caar the-global-environment)

;Value: *table*
#+END_SRC
*** Exercise 4.12
We can capture the common pattern first by recognizing the same code in those
code and then refine them with their role of behavior, namely traversing given
frame and traversing given environment:
#+BEGIN_SRC scheme
;; Var, (Vals -> Any) -> FrameOp
(define (find-var-and-apply-in-frame var vals-op)
  (lambda (null-op frame)
    (let scan ((vars (frame-variables frame))
               (vals (frame-values frame)))
      (cond ((null? vars)
             (null-op))
            ((eq? var (car vars))
             (vals-op vals))
            (else (scan (cdr vars) (cdr vals)))))))

;; FrameOp, void -> Any, Env
;; -> Any
(define (traverse-env-using frame-op empty-env-op env)
  (if (eq? env the-empty-environment)
      (empty-env-op)
      (frame-op (first-frame env)
                (lambda () (traverse-env-using frame-op empty-env-op
                                               (enclosing-environment env))))))
#+END_SRC
Here we, for interfacing the traverser on environment with traverser on frame,
defined new data type, namely =FrameOp= -- ~FrameOp := Frame, NullOp -> Any~,
~NullOp := void -> Any~.

Then our operations on environments get
#+BEGIN_SRC scheme
(define (lookup-variable-value var env)
  (traverse-env-using
   (find-var-and-apply-in-frame var car)
   (lambda () (error "Unbound variable" var))
   env))

(define (set-variable-value! var val env)
  (traverse-env-using
   (find-var-and-apply-in-frame
    var
    (lambda (vals) (set-car! vals val)))
   (lambda () (error "Unbound variable -- SET!" var))
   env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    ((find-var-and-apply-in-frame
      var
      (lambda (vals) (set-car! vals val)))
     (lambda ()
       (add-binding-to-frame! var val frame))
     frame)))
#+END_SRC

Then test using the test code of previous exercise:
#+BEGIN_SRC scheme
...
(eval 'test-def the-global-environment)

;The object #[compound-procedure 38], passed as the first argument to cdr, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 2) => Specify an argument to use in its place.
; (RESTART 1) => Return to read-eval-print level 1.

2 error> (pp #@38)
(lambda ()
  (traverse-env-using frame-op empty-env-op (enclosing-environment env)))
;Unspecified return value
#+END_SRC

Got error! It is due to the ill-ordered argument in =traverse-env-using=. After
fixing that we got:
#+BEGIN_SRC scheme
(eval '(define test-def 0) the-global-environment)

;Value: ok

(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 0

(eval '(test-assignment) the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 5
#+END_SRC

Our code got more cleaner and easier for us to read.
*** Exercise 4.13
As we can think of this new special form as counter expression against =define=,
let we make =make-unbound!= remove only the binding in the first frame of the
environment. To implement this feature, that is to remove specific binding in the
frame, we need to do nearly what we did in =remove-first-item= in agenda data
structure. So, we would not reuse the abstract procedure of previous exercise,
=find-var-and-apply-in-frame=; but the resulting procedure would be nearly same
as that.

To encompass this pattern, we extend =find-var-and-apply-in-frame= with:
#+BEGIN_SRC scheme
(define (find-var-and-apply-to-bindings var find-op bindings-op)
  (lambda (null-op frame)
    (let scan ((vars (frame-variables frame))
               (vals (frame-values frame)))
      (cond ((null? vars)
             (null-op))
            ((eq? var (find-op vars))
             (bindings-op vars vals))
            (else (scan (cdr vars) (cdr vals)))))))
#+END_SRC

Then we can define
#+BEGIN_SRC scheme
(define (find-var-and-apply-in-frame var vals-op)
  (find-var-and-apply-to-bindings
   var car (lambda (vars vals) (vals-op vals))))
#+END_SRC

Or it would better to refine our frame data structure by making the
=frame-variables= and =frame-values= to be headed list respectively to encompass
=make-unbound!= in our scheme uniformly.

As we defined our frame data structure abstractly, all we need to change is the
representation of frame:
#+BEGIN_SRC scheme
;; Change the representation of frame
(define (make-frame variables values)
  (cons (cons '*variables* variables)
        (cons '*values* values)))

(define (frame-variables frame) (cdar frame))
(define (frame-values (cddr frame)))
#+END_SRC

Then we exploit this idea by amending the =find-var-and-apply-to-bindings=
allowing even the selectors and detector for frame:
#+BEGIN_SRC scheme
(define (find-var-and-apply-to-bindings
         var find-op bindings-op frame-vars frame-vals empty-vars?)
  (lambda (null-op frame)
    (let scan ((vars (frame-vars frame))
               (vals (frame-vals frame)))
      (cond ((empty-vars? vars)
             (null-op))
            ((eq? var (find-op vars))
             (bindings-op vars vals))
            (else (scan (cdr vars) (cdr vals)))))))

(define (find-var-and-apply-in-frame var vals-op)
  (find-var-and-apply-to-bindings
   var car (lambda (vars vals) (vals-op vals))
   frame-variables frame-values null?))
#+END_SRC

Then we can define what we wanted:
#+BEGIN_SRC scheme
(define (unbound-variable! var val env)
  (let ((frame (first-frame env)))
    ((find-var-and-apply-to-bindings
      var cadr
      (lambda (h-vars h-vals)
        (set-cdr! h-vars (cddr h-vars))
        (set-cdr! h-vals (cddr h-vals)))
      car cdr (lambda (h-vars) (null? (cdr h-vars))))
     (lambda ()
       (error "Unbound variable in the given frame -- MAKE-UNBOUND!" var))
     frame)))

(define (install-eval-make-unbound)
  (define var cadr)
  (define val caddr)
  (put 'eval 'make-unbound!
       (lambda (exp env)
         (unbound-variable! (var exp)
                            (val exp)
                            env))))
#+END_SRC

Then let we first test the new frame data structure:
#+BEGIN_SRC scheme
(eval '(test-assignment) the-global-environment)

;Unbound variable test-assignment
#+END_SRC
Error! This is due to the =add-binding-to-frame!= as we did not updated that
procedure, which is mutator of frame structure!

Then refine the data structure for frame:
#+BEGIN_SRC scheme
;; Change the representation of frame
(define (make-frame variables values)
  (cons (cons '*variables* variables)
        (cons '*values* values)))

;; selectors for frame
(define (frame-variables frame) (cdar frame))
(define (frame-values frame) (cddr frame))

;; mutators of frame
(define (add-binding-to-frame! var val frame)
  (set-cdr! (car frame) (cons var (frame-variables frame)))
  (set-cdr! (cdr frame) (cons val (frame-values frame))))

(define (remove-binding-from-frame! var frame exception)
  ((find-var-and-apply-to-bindings
      var cadr
      (lambda (h-vars h-vals)
        (set-cdr! h-vars (cddr h-vars))
        (set-cdr! h-vals (cddr h-vals)))
      car cdr (lambda (h-vars) (null? (cdr h-vars))))
     exception
     frame))
#+END_SRC

Then our procedure get clarified as
#+BEGIN_SRC scheme
(define (unbound-variable! var env)
  (remove-binding-from-frame!
   var
   (first-frame env)
   (lambda ()
     (error "Unbound variable in the given frame -- MAKE-UNBOUND!" var))))
#+END_SRC

Re-run our test code:
#+BEGIN_SRC scheme
(eval '(define test-def 0) the-global-environment)

;Value: ok

(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 0

(eval '(test-assignment) the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 5

(eval '(make-unbound! test-def) the-global-environment)

;ok

(eval '(make-unbound! test-def) the-global-environment)

;Unbound variable in the given frame -- MAKE-UNBOUND! test-def
#+END_SRC

Works sweetly!
** Running the Evaluator as a Program
*** Exercise 4.14
1. It is because our evaluator uses data abstraction for decouple the semantics
   from syntaxes of language.
2. Combined with the *1.*, it is due to the difference of how evaluator treats
   application of compound procedure from that of primitive procedure.
3. =Map= needs to apply evaluated procedure to the each element of given list;
   but the value of that procedure is wrapped around by type-tag and it handled
   underlying Scheme's evaluator which don't know how to handle our type-tagged data.
4. So namely, it is not the procedure, which handed over to =map=, in
   implementation language but in language being implemented.
** Data as Programs
*** Exercise 4.15
We can prove this by case analysis with /reductio ad absurdum/:
- =(try try)= \to ='halted=:
  By definition of =try=, it implies that =(halts? try try)= evaluated as
  =false=. Which in turn means =(try try)= raises error or run forever by the
  definition of =halts?=; this is contradiction with our assumption -- =(try
  try)= returns ='halted=, which means it halted.
- =(try try)= \to /run forever/ or /raise error/:
  With the same argument from the previous one, it leads to contradiction with
  assumption in any case -- whether it evaluated as /run forever/ or /raise error/.
** Internal Definitions
*** Exercise 4.16
**** a.
#+BEGIN_SRC scheme
(define (lookup-variable-value var env)
  (traverse-env-using
   (find-var-and-apply-in-frame
    var
    (lambda (vals)
      (let ((val (car vals)))
        (if (eq? val undef)
            (error "Unassigned variable" var)
            val))))
   (lambda () (error "Unbound variable" var))
   env))
#+END_SRC
**** b.
I've designed in the text book with my digital paper:
#+BEGIN_SRC scheme
(define (scan-out-defines proc-body)
  (let ((extrated-exps
         ;; List<Exp> (proc-body) -> List<Exp> x List<Exp>
         ;; We implement this a little bit complicate procedure since
         ;; we want to examine possible user error --
         ;; defenstive programming.
         (fold-right
          (lambda (exp extracted)
            (if (definition? exp)
                (cons (cons exp (car extracted)) (cdr extracted))
                (if (null? (car extracted))
                    (cons (car extracted) (cons exp (cdr extracted)))
                    ;; intertwined internal definitions with others
                    (error "Internal defintions intertwins with others" proc-body))))
          (cons '() '())
          proc-body)))
    (let ((internal-defs (car extrated-exps))
          (rest-body (cdr extrated-exps)))
      (let ((vars (map definition-variable internal-defs))
            (exps (map definition-value internal-defs)))
        (let ((bindings
               (map (lambda (var) (list var (list 'quote undef)))
                    vars))
              (set-exps
               (map (lambda (var val)
                      (make-assignment var val))
                    vars
                    exps)))
          (make-let bindings (append set-exps rest-body)))))))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
;; test for scan-out-defines
(scan-out-defines
 '((define u <e1>)
   (define v <e2>)
   <e3>))
;; should return
(let ((u '*unassigned*)
      (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
#+END_SRC

Then the results:
#+BEGIN_SRC scheme
(pretty-print (scan-out-defines
               '((define u <e1>)
                 (define v <e2>)
                 <e3>)))
(let ((u '*unassigned*) (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
;Unspecified return value
#+END_SRC
as expected.
**** c.
The construction time is better. Note that it is analogous to the choice we made
when we comes with rational number arithmetic package. Since procedure is
"captured common computational process," it is supposed to be applied more than
defining ones; so by make =scan-out-defines= run in the construction time, we'll
get more efficient implementation dynamically.

Then here is the code:
#+BEGIN_SRC scheme
(define (make-procedure parameters body env)
  (list 'procedure parameters
        (scan-out-defines body)
        env))
#+END_SRC
*** Exercise 4.17
I've drawn the required diagram with my digital paper.

For the second question, first we need to recognize what the correct program is;
as jotted in the text book, correct program means what program obeyed the
described restriction -- the defined variables' values can be evaluated without
using any of variables' values. Then we can answer given question: Variables
that can be looked up in evaluating =<e3>= is same in both environment
structure; as an evaluation of any statement can not inspect the environment
directly, the behavior of both should equals among both. More formally, we can
prove the argument using the structure induction on eval/apply; that is,
evaluation of statement achieved by eval/apply, so we need to prove if all the
behavior of the program before the transformation are same, then after that
transformation the evaluation result of each clause should results in same as
before the transformation.

Lastly, we can fix this different environment structure by transforming the
internal definitions into
- Define the variables of them with =*unassigned*= then =set!= the value by
  corresponding expressions afterward, which would do not make any extra frame
  and also satisfy all the specifications described above.
- Note that this fixation does not involve any ill-defined procedure, that is
  the infinite loop where calls itself again and again.


The code:
#+BEGIN_SRC scheme
(define (scan-out-defines2 proc-body)
  (let ((extrated-exps
         ;; List<Exp> (proc-body) -> List<Exp> x List<Exp>
         ;; We implement this a little bit complicate procedure since
         ;; we want to examine possible user error --
         ;; defenstive programming.
         (fold-right
          (lambda (exp extracted)
            (if (definition? exp)
                (cons (cons exp (car extracted)) (cdr extracted))
                (if (null? (car extracted))
                    (cons (car extracted) (cons exp (cdr extracted)))
                    ;; intertwined internal definitions with others
                    (error "Internal defintions intertwines with others" proc-body))))
          (cons '() '())
          proc-body)))
    (let ((internal-defs (car extrated-exps))
          (rest-body (cdr extrated-exps)))
      (let ((vars (map definition-variable internal-defs))
            (exps (map definition-value internal-defs)))
        (let ((def-vars
               (map (lambda (var) (make-definition var (list 'quote undef)))
                    vars))
              (set-exps
               (map (lambda (var val)
                      (make-assignment var val))
                    vars
                    exps)))
          (append def-vars (append set-exps rest-body)))))))

(define (make-definition var val)
  (list 'define var val))
#+END_SRC


Then test again:
#+BEGIN_SRC scheme
(pretty-print (scan-out-defines2
               '((define u <e1>)
                 (define v <e2>)
                 <e3>)))
((define u '*unassigned*) (define v '*unassigned*) (set! u <e1>) (set! v <e2>) <e3>)
#+END_SRC
*** Exercise 4.18
This new version would not work; whereas the version in the text works. We can
reason this as follows:
#+BEGIN_SRC scheme
(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt)) ;does not evaluate dy until it need
  ;; ↑ in this block structure it never needed.
  (define dy (stream-map f y))          ;does evaluate y
  y)
#+END_SRC
1. As noted above annotation, the value expression of =dy= involves =y= and need
   to evaluate that to return the value.
2. Since in this transformation strategy does not change all the occurrence of
   =u= and =v= into =a= and =b= respectively in the =<e1>= and =<e2>= as it
   assume the restriction is obeyed, when it comes to evaluate =y= it lookup and
   signal error as it found =*unassigned*=.
3. This malfunction is due to the modification of the name of definition without
   changing all the expressions that depend on the name of internal definitions
   as we noted above.
*** Exercise 4.19
1. I myself couldn't yet be convinced by why we need to treat internal
   definitions especially; so I support Ben's view since it make me (and
   possibly other people too) easy to understand the behavior of internal
   definition in consistent manner.

   However it is trickier than it seems since the difference between procedure
   and other data. And because of the limitation of text editor environment: We
   are forced to write code in sequential manner; so it forces us to think as if
   we are dealing with sequential events. But it isn't as we discuss below.

   The above discussion is not consistent with that of mutual recursive
   procedures -- it works as if the defines evaluated simultaneously. So in
   theory Eva's view point is the most consistent one.

2. For the second question; yes, we can but it should be implemented in a error
   handling manner: If we got into unassigned value error, then try to delegate
   the execution of that assignment statement (to stack another place and try
   each of them when we reach the end of assignment statement; if there are no
   reduction in stack after one-loop finally it should raise an error -- give
   up!). This algorithm is expensive since it recursively reduces the stacked
   statements until there is no change.
*** Exercise 4.20
**** a.
Here we implement the strategy written in text book. That is, to transform from
#+BEGIN_SRC scheme
(letrec ((u <e1>)
         (v <e2>))
  <e3>)
#+END_SRC
to
#+BEGIN_SRC scheme
(let ((u '*unassigned*)
      (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
#+END_SRC

So we can code the test code using above example:
#+BEGIN_SRC scheme
(pretty-print (letrec->let-assignment
               (letrec ((u <e1>)
                        (v <e2>))
                 <e3>)))
(let ((u '*unassigned*)
      (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
;Unspecified return value
#+END_SRC

Then code:
#+BEGIN_SRC scheme
(define (install-eval-letrec)
  (define bindings cadr)                ;((u <e1>) (v <e2>))
  (define body cddr)                    ;<e3>
  (define (letrec->let-assignment exp)
    (let ((binds (bindings exp))
          (rest-body (body exp)))
      (let ((vars (map car binds))
            (exps (map cadr binds)))
        (make-let
         (map (lambda (var) (list var (list 'quote undef)))
              vars)
         (append
          (map (lambda (var exp) (make-assignment var exp))
               vars exps)
          rest-body)))))
  (put 'eval 'letrec
       (lambda (exp env)
         (eval (letrec->let-assignment exp) env)))
  ;; test
  (letrec->let-assignment
   '(letrec ((u <e1>)
             (v <e2>))
      <e3>)))
#+END_SRC

And test!
#+BEGIN_SRC scheme
(pretty-print (install-eval-letrec))
(let ((u '*unassigned*) (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
;Unspecified return value
#+END_SRC
**** b.
Solely let, we cannot express recursive process within the body of procedure.
I've drawn the environment diagram reasoning about this assertion.
*** Exercise 4.21
**** a.
#+BEGIN_SRC scheme
((lambda (n)
   ((lambda (fact)
      (fact fact n))
    (lambda (ft k)
      (if (= k 1)
          1
          (* k (ft ft (- k 1)))))))
 10)

;Value: 3628800
#+END_SRC
It works well. By using this technique -- specifically the lambda calculus by
Alonzo Church -- we can reason our program's behavior using, back to our old
friend, substitution model.

Fibonacci number can be calculated by using this strategy:
#+BEGIN_SRC scheme
((lambda (n)
   ((lambda (fibo)
      (fibo fibo n))
    (lambda (fib k)
      (if (< k 2)
          k
          (+ (fib fib (- k 1))
             (fib fib (- k 2)))))))
 4)

;Value: 3
#+END_SRC

The common pattern in above procedures is that the inner procedure, which do all
the serious process, take additional parameter. We can think of this parameter
as /self/ reference; as soon as we calculate the type contract of this /self/
parameter, we realize this is same as that type of the procedure of discourse.
**** b.
#+BEGIN_SRC scheme
(define (f x)
  ((lambda (even? odd?)
     (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? ev? od? (-1+ n))))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? ev? od? (-1+ n))))))
#+END_SRC

then test:
#+BEGIN_SRC scheme
(f 5)

;Value: #f

(f 4)

;Value: #t
#+END_SRC
** Separating Syntactic Analysis from Execution
*** Exercise 4.22
We can get what we want by mapping the expression part to =let->combination= to
=analyze-application=. First let we make our analyzer to be data-directed
style, which is analogous to [[Exercise 4.3][ex 4.3]]:
#+BEGIN_SRC scheme
(define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((variable? exp) (analyze-variable exp))
        (else
         (let ((op (and (tagged-exp? exp)
                        (get 'analyze (type-tag exp)))))
           (cond (op (op exp))
                 ((application? exp)
                  (analyze-application exp))
                 (else
                  (error "Unknown expression type -- ANALYZE" exp)))))))
#+END_SRC

Then extend our =eval= /ad-hoc/ table into more general 2 dimensional
hash-table:
#+BEGIN_SRC scheme
(define operation-table (make-hash-table))
(define (put op type item)
  (let ((type-table (hash-table-ref operation-table op (lambda () #f))))
    (if type-table
        (hash-table-set! type-table type item)
        (let ((type-table (make-hash-table)))
          (hash-table-set! type-table type item)
          (hash-table-set! operation-table op type-table)))))
(define (get op type)
  (let ((type-table
         (hash-table-ref operation-table op (lambda () #f))))
    (and type-table
         (hash-table-ref type-table type (lambda () #f)))))
#+END_SRC

And then
#+BEGIN_SRC scheme
(define (install-analyze-clauses)
  (put 'analyze 'quote analyze-quoted)
  (put 'analyze 'set! analyze-assignment)
  (put 'analyze 'define analyze-definition)
  (put 'analyze 'if analyze-if)
  (put 'analyze 'lambda analyze-lambda)
  (put 'analyze 'begin (lambda (exp) (analyze-sequence (begin-actions exp))))
  (put 'analyze 'cond (lambda (exp) (analyze (cond->if exp))))
  'done)
#+END_SRC

Finally we can return our original task:
#+BEGIN_SRC scheme
(define (install-analyze-let)
  (define let->combination
    (cadr (assq 'let->combination (install-eval-let))))
  (put 'analyze 'let (lambda (exp) (analyze-application (let->combination exp)))))
#+END_SRC

To make available the =let->combination= procedure, which is defined in
=install-eval-let=, I've made following change to the end of =install-eval-let=:
#+BEGIN_SRC scheme
,*** the last line of install-eval-let
  `((let->combination ,let->combination))
#+END_SRC

That is, the alist of procedures, which we want to export. And you may find
[[https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Quoting.html][Scheme manual about quasi-quote]] useful.
*** Exercise 4.23
The procedure of Alyssa's version start to link all the sequence expressions
into one analyzed expression in execution time; whereas the version of text do
link the sequence in the analysis time. As consequence, the number of steps it
needs when it executed are quite different among both. I've wrote the sample
execute in my digital paper using the substitution model since the execution
does not involve any side effect (the side effect of executed statement does not
affect the behavior of this level of abstraction).
*** Exercise 4.24
**** Compare Execution Time
Here we compare the time it needs to execute application of test procedure. For
the test procedure we use procedure which calculate Fibonacci number using multi
recursive process (since it is expensive, we can measure the time more
apparently).

The definition of test procedure:
#+BEGIN_SRC scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
#+END_SRC

And we can extract /only/ the execution of application not the definition by
using =eval=, namely
#+BEGIN_SRC scheme
(eval '(fib 33) the-global-environment)
#+END_SRC

Then we can time it needs to execute whole of this process the variation from
project 3:
#+BEGIN_SRC scheme
(define (timed proc)
  (let ((start (runtime)))
    (let ((val (proc)))
      (newline)
      (display "time expended: ")
      (display (- (runtime) start))
      val)))
#+END_SRC

Then we can use this as
#+BEGIN_SRC scheme
(timed (lambda () (eval '(fib 33) the-global-environment)))
#+END_SRC

As we designed the experiments, now let's run those:
#+BEGIN_SRC scheme
;;; Analysis
(install-analyze-clauses)
(eval
 '(define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1))
                   (fib (- n 2))))))
 the-global-environment)
(timed (lambda () (eval '(fib 20) the-global-environment)))

time expended: 1.6300000000000026
;Value: 6765
#+END_SRC

Turns out =(fib 33)= way more expensive to wait.

Then without analysis version:
#+BEGIN_SRC scheme
(install-eval-clauses)
(eval
 '(define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1))
                   (fib (- n 2))))))
 the-global-environment)
(timed (lambda () (eval '(fib 20) the-global-environment)))

time expended: 3.21
;Value: 6765
#+END_SRC

With analysis, we halved the time it takes. Quite impressive isn't it?

For curiosity, let we run also the primitive evaluator of our Scheme!
#+BEGIN_SRC scheme
(define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1))
                   (fib (- n 2))))))

;Value: fib

(timed (lambda () (fib 20)))

time expended: .02999999999999936
;Value: 6765
#+END_SRC

Huge difference!
**** Compare the time spent by analysis versus by execution
Here is the previous =fib= procedure's:
#+BEGIN_SRC scheme
(timed
 (lambda ()
   (repeat 1000 (lambda ()
                  (eval '(fib 2)
                        the-global-environment)))))

time expended: .20000000000000018
;Value: done
#+END_SRC

And that of simple execution:
#+BEGIN_SRC scheme
(timed
 (lambda ()
   (repeat 1000 (lambda ()
                  (eval '(fib 1)
                        the-global-environment)))))

time expended: .07000000000000028
;Value: done
#+END_SRC

Or simple recursive execution:
#+BEGIN_SRC scheme
(timed
 (lambda ()
   (repeat 1000 (lambda ()
                  (eval '(fib 2)
                        the-global-environment)))))

time expended: .20000000000000018
;Value: done
#+END_SRC

Here we used =repeat= to measure the time otherwise unable to estimate:
#+BEGIN_SRC scheme
(define (repeat n proc)
  (let loop ((k n))
    (if (> k 0)
        (begin (proc)
               (loop (-1+ k)))
        'done)))
#+END_SRC

Or let us test the sequential statements:
#+BEGIN_SRC scheme
;; Or those of sequential statements
(define test-sequential
  '(define (test-sequential)
     (define x 0)
     (set! x (1+ x))
     (set! x (1+ x))
     (set! x (1+ x))
     (set! x (1+ x))
     (set! x (1+ x))
     x))
;; analysis time
(timed (lambda () (repeat 1000 (lambda () (analyze test-sequential)))))

time expended: .08999999999999986
;Value: done

;; execution time
(eval test-sequential the-global-environment)
(timed (lambda ()
         (repeat 1000 (lambda ()
                        (eval '(test-sequential) the-global-environment)))))

time expended: .17000000000000015
;Value: done
#+END_SRC
* Variations on a Scheme -- Lazy Evaluation
** Normal Order and Applicative Order
*** Exercise 4.25
It will falls into infinite loop since what ever argument we hand over, it
should call itself with different argument to pass the =unless= procedure as
parameter -- as our underlying Scheme evaluate in applicative order, evaluator
first evaluate the operands of application of compound procedure and then apply.

And yes, our procedure will work in normal-order language since in normal-order
language, expressions only got evaluated when the expression is operation in
application or the operation part unwound into primitive procedure.

If we apply above discussion into our =factorial= application, it unwound into
application of =unless=, which in turn got into =if= expression that is special
form; by the rule of =if= evaluation, now the predicate part evaluated and
depending on that value, in turn, whether consequent part of alternative part
got evaluated and so on.
*** Exercise 4.26
Here is the =unless= as derived form:
#+BEGIN_SRC scheme
(define (unless->if exp)
  (make-if (unless-pred exp)
           (unless-alter exp)
           (unless-conseq exp)))
(define unless-pred cadr)
(define unless-conseq caddr)
(define unless-alter cadddr)
#+END_SRC

Let us think the discussion using more simple example -- not =unless= itself --
the =and= or =or= special form. It has the ability to be used as "short circuit" the
code. I couldn't count the number of times if I had =or= as non-special form so
that I can code up with higher order function like =fold-right=.

Back to the original question, we can think about the possibilities if we
allowed to use =unless= with combination of stream processing frame work. By
using that combination, we could code event driven system in functional
programming style as we use the =unless= to control the input stream.

Well, in any case, if we allowed to use =unless= not as special form, we can
pass that as argument of another higher order procedures; or as the value of
application.
** An Interpreter with Lazy Evaluation
*** Exercise 4.27
The first =<response>= should be 1 and that of second =<response>= and third
would be 10 and 2 respectively since
1. The value expression of =w= is evaluated by =eval-definition= but as it's
   application of compound procedure, it will evaluate the body of given
   compound procedure with *delayed* arguments.
2. Since the first statement of the body is special form with application of
   primitive procedure, it will change the value of count from 0 to 1.
3. The last statement of that is variable, it will lookup in the extended
   environment and return the *delayed* value, that is the promise to evaluate
   =(id 10)= in that environment.


Here is the verification:
#+BEGIN_SRC scheme
;;; L-Eval input:
(define count 0)

;;; L-Eval value:
ok

;;; L-Eval input:
(define (id x)
  (set! count (+ count 1))
  x)

;;; L-Eval value:
ok

;;; L-Eval input:
(define w (id (id 10)))

;;; L-Eval value:
ok

;;; L-Eval input:
count

;;; L-Eval value:
1

;;; L-Eval input:
w

;;; L-Eval value:
10

;;; L-Eval input:
count

;;; L-Eval value:
2

#+END_SRC
*** Exercise 4.28
The example should be the case where the evaluated value is thunk and then it
used as operator in combination.

Generally, we need this extra complexity for dealing with the case where the
expression is itself result of combination of applying compound procedure where
it participate as argument.

We can deduce this using the previous exercise as example. Observe that in the
previous exercise that the arguments in the application (of compound procedure)
are made thunk by =list-of-delayed-args=. By using this observation, we can make
the situation where satisfy the property outlined above:
#+BEGIN_SRC scheme
(((lambda (x) x) +) 2 4)
#+END_SRC

Then verification:
#+BEGIN_SRC scheme
(thunk? (eval '((lambda (x) x) +) the-global-environment))

;Value: #t
#+END_SRC

So we need the =actual-value= to get the value, which in turn applied to given
operands:
#+BEGIN_SRC scheme
(thunk? (actual-value '((lambda (x) x) +) the-global-environment))

;Value: #f
#+END_SRC
*** Exercise 4.29
The good example of such program should exhibit the situation where some object
evaluated more than once; so
#+BEGIN_SRC scheme
(factorial (factorial 20))
#+END_SRC
would make huge difference between with memoization and without that.

And for the second question, we can reason about this as follows:
- For with memoization:
  1. Evaluate =(square (id 10))=, which in turn
  2. extend the environment with binding =x: (thunk (id 10) env)=
     and evaluate =(* x1 x2)= (here we used =x1= and =x2= instead =x= since
     we need to take the time when we accessed to that variable since
     memoization introduce assignment implicitly);
  3. force x_{1}, which in turn evaluate =(id 10)=; it leads to set =count= to
     be 1 and in the environment set =x= to be evaluated thunk with value 10;
  4. force x_{2}, which already evaluated by force x_{1}, so it just return 10;
  5. returned to =(* x1 x2)=, as now the values are obtained, it return 100 as
     final value.
- For without memoization:
  1. Evaluate =(square (id 10))=, which in turn
  2. extend the environment with binding =x: (thunk (id 10) env)=
     and evaluate =(* x1 x2)=;
  3. force x_{1}, which in turn evaluate =(id 10)=; it leads to set =count= to
     be 1;
  4. force x_{2}, which in turn evaluate =(id 10)=; it leads to set =count= to
     be 2;
  5. returned to =(* x1 x2)=, as now the values are obtained, it return 100 as
     final value.


So the first response is same in both as 100; the second are 1, 2 in with
memoization and without that respectively.
*** Exercise 4.30
**** a.
Since
- as this is application of compound procedure;
- it evaluate the body of =for-each= with delayed arguments;
- in turn, =if-predicate= force items to be actual value;
- by the first statement of =begin= of =for-each= is application so =proc= got
  forced;
- it leads the body of =proc= evaluated with thunked =(car items)= -- 57 in this
  example;
- as all of the statement of =proc= is application of primitive procedures the
  argument, =x=, is forced and evaluated -- 57 is displayed at this moment;
- now another =for-each= is evaluated same as above since all the conditions are
  same for applying the above argument.


By above argument all the statements in the sequence got forced.
**** b.
As we noted in [[Exercise 4.28][ex 4.28]], the thunked expression is not evaluated as value without
forcing it -- by =actual-value= --, in turn, user can thunk the expression only
via application of compound procedure.

So by applying this observation to the given Cy's examples with original
=eval-sequence=, we got =(p1 1)= \to =(1 2)= and =(p2 1)= \to 1; since while the
first does not involve any application of compound procedure; the second
assignment thunked and that, in turn, evaluated without forcing it. But with
Cy's modified version return =(1 2)= in both cases since now all the
intermediate statement forced.
**** c.
Since already forced value can not be changed by additional =force-it=. As we
noted in *a.* each statement of in the sequence already fully evaluated --
forced, so the modification does not affect at all to that specific example.
**** d.
Whatever choice we made, the evaluation of sequence being made in unexpected or
hard to be estimated time. It is totally due to the nature of normal-order
evaluation rule: By choosing the normal-order evaluation, we decoupled the time
when the expression got assembled from the time the expression actually got
evaluated. However, using assignment, we are meant to control the "time"
explicitly in the computer, that is when the evaluation is being carried out,
which mirrored the real world. The time is "state." So those -- the assignment
and normal-order rule -- are incompatible in themselves; we shouldn't expect to
use sequence of expressions /per se/ side-effects.
*** Exercise 4.31
We need to change =list-of-delayed-args= to encompass this new extension. And
also we need to change the =force-it= and add additional data structure that is
analogous to =thunk= -- =memo-thunk=.

We decide =thunk= to represent the delayed object without memoized; =memo-thunk=
for delayed object with memoization.

Let us code what we designed using digital paper!
#+BEGIN_SRC scheme
(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env))) ; changed
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (let ((params (procedure-parameters procedure)))
            (extend-environment
             (map param-name params)
             (list-if-delayed-args
              arguments (map param-type params) env) ; changed
             (procedure-environment procedure)))))
        (else
         (error
          "Unknown procedure type -- APPLY" procedure))))

;; param ADT
(define (typed-param? param)
  (and (pair? param)
       (pair? (cdr param))))
(define (param-type param)
  (if (typed-param? param)
      (cadr param)
      'strict))
(define (param-name param)
  (if (typed-param? param)
      (car param)
      param))

(define (list-if-delayed-args exps types env)
  (cond ((no-operands? exps) '())
        ((null? types)
         (error "the number of arguments do not agree with procedure"
                ;; actually whether we should use more sophisticated error message
                ;; or should delegate the error raise to extend-environment
                ;; current error message is not informative enough to be useful.
                exps))
        (else
         (cons
          ((case (first types)
             ((strict) actual-value)
             ((lazy) delay-it)
             ((lazy-memo) delay-memo-it)
             (else (error "Unknown parameter type")))
           (first-operand exps)
           env)
          (list-if-delayed-args (rest-operands exps)
                                (cdr types)
                                env)))))

;; memo-thunk ADT
(define (delay-memo-it exp env)
  (list 'memo-thunk exp env))
(define (memo-thunk? obj)
  (tagged-list? obj 'memo-thunk))

(define (force-it obj)
  (cond ((thunk? obj)
         (actual-value (thunk-exp obj) (thunk-env obj)))
        ((memo-thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)  ; replace exp with its value
           (set-cdr! (cdr obj) '())     ; forget unneeded env
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
#+END_SRC

Then test! Here we use [[Exercise 4.29][ex 4.29]] for test:
#+BEGIN_SRC scheme
;;; L-Eval input:
(define count 0)

;;; L-Eval value:
ok

;;; L-Eval input:
(define count-memo 0)

;;; L-Eval value:
ok

;;; L-Eval input:
(define (id-memo (x lazy-memo))
  (set! count-memo (+ count-memo 1))
  x)

;;; L-Eval value:
ok

;;; L-Eval input:
(define (id-lazy (x lazy))
  (set! count (+ count 1))
  x)

;;; L-Eval value:
ok

;;; L-Eval input:
(define (square-memo (x lazy-memo))
  (* x x))

;;; L-Eval value:
ok

;;; L-Eval input:
(define (square-lazy (x lazy))
  (* x x))

;;; L-Eval value:
ok

;;; L-Eval input:
(square-memo (id-memo 10))

;;; L-Eval value:
100

;;; L-Eval input:
count-memo

;;; L-Eval value:
1

;;; L-Eval input:
(square-lazy (id-lazy 10))

;;; L-Eval value:
100

;;; L-Eval input:
count

;;; L-Eval value:
2

#+END_SRC

Works!
*** Exercise 4.32
Now we can construct /reversed/ stream, that is, we use =car= to traverse and
=cdr= to store elements. With this extra concept combined with original stream,
we can now manipulate line not only ray! -- what we defined as integers in
stream was actually just natural numbers not integers, strictly speaking. More
over, we can manipulate tree operations lazily as well as list structure. So
until this point, to manipulate tree in combination with stream, we needed to
first construct whole tree strictly and then convert that into stream. If we
represent the graph in lazy tree structure, conceptually it equivalent to the
non-deterministic programming, which decomposed automatic search from
computation. We can think this differently: By allowed to manipulate not only
future -- =cdr= part -- but also past -- =car= part; so we can now traverse the
time branches back and forth freely.
*** Exercise 4.33
The reason it produce an error is as follows:
1. Quoted expression processed by the =read= procedure, by which we get the
   input from terminal, of underlying Lisp language; it is "list" in
   implementation language not that in language being implemented.
2. So we need transform from list structure of implementation language into that
   of language being implemented.


Here is the code do the right thing:
#+BEGIN_SRC scheme
(define (list->list lst)
  (fold-right (lambda (item ->list)
                `(cons ,item ,->list))
              '(quote ())
              lst))
(define (text-of-quotation exp)
  (let ((contents (cadr exp)))
    (if (list? contents)
        (eval (list->list contents) the-global-environment)
        contents)))
#+END_SRC

Then let's test!
#+BEGIN_SRC scheme
;;; setup
(eval cons-def the-global-environment)
(eval car-def the-global-environment)
(eval cdr-def the-global-environment)
;;; test quotation
(actual-value '(car '(a b c)) the-global-environment)

;Quit!
#+END_SRC

Unfortunately, it doesn't return the control! It turns out due to the test
=list?= since
#+BEGIN_SRC scheme
(list? '())

;Value: #t
#+END_SRC

So
#+BEGIN_SRC scheme
(actual-value '(quote ()) the-global-environment)

;Quit!
#+END_SRC
runs forever!

Fix the procedure as
#+BEGIN_SRC scheme
(define (text-of-quotation exp)
  (let ((contents (cadr exp)))
    (if (and (not (null? contents))
             (list? contents))
        (eval (list->list contents) the-global-environment)
        contents)))
#+END_SRC

Then re-run:
#+BEGIN_SRC scheme
(actual-value '(car '(a b c)) the-global-environment)

;Unbound variable a
#+END_SRC

Now the problem is that =list->list= does not =quote= the element! Let's fix:
#+BEGIN_SRC scheme
(define (list->list lst)
  (fold-right (lambda (item ->list)
                `(cons ',item ,->list))
              '(quote ())
              lst))
#+END_SRC

Now it produces right result:
#+BEGIN_SRC scheme
(actual-value '(car '(a b c)) the-global-environment)

;Value: a
#+END_SRC
*** Exercise 4.34
To print the pair, we need to recognize whether given object is pair by =pair?=
We can exploit the message passing paradigm:
1. Then =(define (pair? x) (x 'pair?))=
2. This will work if we request only to pair object; but predicate meant to
   check whether given argument satisfy specific condition. So predicate should
   not signal error unless it provided certain condition should be satisfied but
   violated by user (although it is not appropriate to assume informal
   contraction without verification).
3. So we'd better to take another way: Make =cons=, =car=, =cdr= non-strict
   primitive procedure; by including =pair?= as primitive (strict) procedure, we
   got what we wanted.


So we need to modify =apply= to cope with primitive non-strict application, and
the new syntax procedure for non-strict primitive procedures, finally the
=setup-environment=:
#+BEGIN_SRC scheme
 (define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure) ;strict primitive
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env)))
        ((non-strict-primitive-procedure? procedure) ;non-strict primitive
         (apply-primitive-procedure
          procedure
          (list-of-delayed-args arguments env)))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)
           (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type -- APPLY" procedure))))

(define (non-strict-primitive-procedure? proc)
  (tagged-list? proc 'non-strict))

(define (non-strict-procedure-names)
  (map car
       non-strict-procedures))

(define (non-strict-procedure-objects)
  (map (lambda (proc) (list 'non-strict (cadr proc)))
       non-strict-procedures))

(define (setup-environment)
  (let ((initial-env
         (extend-environment
          (non-strict-procedure-names)
          (non-strict-procedure-objects)
          (extend-environment (primitive-procedure-names)
                              (primitive-procedure-objects)
                              the-empty-environment))))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
;; initialize the startup environment
(define primitive-procedures
  (append (list
           (list 'pair? (lambda (p) (tagged-list? p 'pair)))
           (list 'car cadr)
           (list 'cdr cddr))
          primitive-procedures))

(define non-strict-procedures
  `((cons ,(lambda (x y) (cons 'pair (cons x y))))))
#+END_SRC

We need to make pair as tagged list to discern with other data structure. Also
note that we made only =cons= non-strict; but not the =car= and =cdr= since
there is no need to make those non-strict and further more, if we make them so,
it only make the implementation complicate to select the part appropriately! You
need to reason this by experimenting with non-strict =car= and =cdr=.

Then test!
#+BEGIN_SRC scheme
(actual-value '(car (cons 2 4)) the-global-environment)

;Value: 2

(thunk? (eval '(car (cons 2 4)) the-global-environment))

;Value: #t

(eval '(pair? (cons 2 4)) the-global-environment)

;Value: #t
#+END_SRC

Now we return to display the lazy pair appropriately. Here we used structural
induction on object. For the pair object, we also used induction on depth
combined with structural induction on =o2=. Finally for the choice of
representation of thunk, we took that of stream:
#+BEGIN_SRC scheme
(define (represent-object o)
  (cond ((compound-procedure? o)
         (list 'compound-procedure
                     (procedure-parameters o)
                     (procedure-body o)
                     '<procedure-env>))
        ((thunk? o)
         '...)
        ((evaluated-thunk? o)
         (represent-object (thunk-value o)))
        ((tagged-list? o 'pair)
         (represent-pair (cdr o)))
        (else o)))

(define (represent-pair p)
  (let ((rep1 (represent-object (car p))) ;induction on depth
        (o2 (cdr p)))
    (cond ((thunk? o2)
           (list rep1 (represent-object o2)))
          ((evaluated-thunk? o2)
           (cons rep1 (represent-object o2)))
          ((tagged-list? o2 'pair)
           (cons rep1 (represent-pair (cdr o2))))
          (else                         ;atomic value
           (cons rep1 (represent-object o2))))))
#+END_SRC

Then modify =user-print= as follows:
#+BEGIN_SRC scheme
(define (user-print object)
  (display (represent-object object)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;;; L-Eval input:
(define test-display (cons ((lambda (x) (+ 2 x)) 3) (cons 2 '())))

;;; L-Eval value:
ok

;;; L-Eval input:
test-display

;;; L-Eval value:
(... ...)

;;; L-Eval input:
(car (cdr test-display))

;;; L-Eval value:
2

;;; L-Eval input:
test-display

;;; L-Eval value:
(... 2 ...)

;;; L-Eval input:
(cdr (cdr test-display))

;;; L-Eval value:
()

;;; L-Eval input:
test-display

;;; L-Eval value:
(... 2)

;;; L-Eval input:
(car test-display)

;;; L-Eval value:
5

;;; L-Eval input:
test-display

;;; L-Eval value:
(5 2)

#+END_SRC

For the completeness, here I add to =user-print= additional feature, detect the
shared structure in lazy pair:
#+BEGIN_SRC scheme
(define (pair?* o) (tagged-list? o 'pair))
(define car* cadr)
(define cdr* cddr)

(define (extract-sharings object)
  (let ((tracked '())
        (sharings '()))
    (define scan
      (lambda (o)
        (define (mutate-list! o not-tracked-op)
          (if (memq o tracked)
              (if (not (memq o sharings))
                  (set! sharings (cons o sharings))
                  'done)
              (begin (set! tracked (cons o tracked))
                     (not-tracked-op o))))
        (cond ((evaluated-thunk? o)
               (scan (thunk-value o)))
              ((pair?* o)
               (mutate-list!
                o (lambda (o)
                    (scan (car* o))
                    (scan (cdr* o))))))))
    (scan object)
    sharings))

(define (display-entry object)
  (let ((sharings (extract-sharings object))
        (issue-table '(*issue*)))       ;hash-table won't work!
    (define (issued-number o)
      (cond ((assq o (cdr issue-table)) => cadr)
            (else #f)))
    (define issue!
      (let ((id 0))                     ;identification number
        (lambda (o)
          (let ((to-be-issued id))
            (set-cdr! issue-table (cons (list o to-be-issued)
                                        (cdr issue-table)))
            (set! id (1+ id))
            to-be-issued))))
    (define (display-issued-object id)
      (display "#")
      (display id)
      (display "#"))
    (define (display-issuing id)
      (display "#")
      (display id)
      (display "="))
    (define (display-object o)
      (cond ((compound-procedure? o)
             (display (list 'compound-procedure
                            (procedure-parameters o)
                            (procedure-body o)
                            '<procedure-env>)))
            ((thunk? o)
             (display '...))
            ((evaluated-thunk? o)
             (display-object (thunk-value o)))
            ((pair?* o)
             (display-pair o))
            (else (display o))))
    (define (display-pair p)
      (define (display-pair-entry p)
        (display "(")
        (display-object (car* p))
        (display-iter (cdr* p))
        (display ")"))
      (define (display-shared-or-default exp default-op pad1-op pad2-op)
        (if (memq exp sharings)         ;it is shared structure
            (let ((id (issued-number exp)))
              (if id
                  (begin (pad1-op)
                         (display-issued-object id))
                  (begin (pad2-op)
                         (display-issuing (issue! exp))
                         (display-pair-entry exp))))
            (default-op exp)))
      (define (display-iter exp)
        (cond ((null? exp))
              ((evaluated-thunk? exp)
               (display-iter (thunk-value exp)))
              ((pair?* exp)
               (display-shared-or-default
                exp
                (lambda (p)
                  (display " ")
                  (display-object (car* p))
                  (display-iter (cdr* p)))
                (lambda () (display " . "))
                (lambda () (display " "))))
              ((thunk? exp)
               (display " ")
               (display-object exp))
              (else
               (display " . ")
               (display-object exp))))
      (display-shared-or-default
       p (lambda (p) (display-pair-entry p))
       (lambda () 'ignore)
       (lambda () 'ignore)))
    (display-object object)
    (set-cdr! issue-table '())))        ;clear the cached
#+END_SRC

Then our =user-print= became
#+BEGIN_SRC scheme
(define (user-print object)
  ;; (display (represent-object object))
  (display-entry object))
#+END_SRC

Then test code:
#+BEGIN_SRC scheme
;;; L-Eval input:
(define ones (cons 1 ones))

;;; L-Eval value:
ok

;;; L-Eval input:
ones

;;; L-Eval value:
(... ...)

;;; L-Eval input:
(car ones)

;;; L-Eval value:
1

;;; L-Eval input:
(cdr ones)

;;; L-Eval value:
#0=(1 . #0#)

;;; L-Eval input:
(define one (cons 1 two))               ;mutual recursive definition

;;; L-Eval value:
ok

;;; L-Eval input:
(define two (cons 2 one))

;;; L-Eval value:
ok

;;; L-Eval input:
(car one)

;;; L-Eval value:
1

;;; L-Eval input:
(cdr one)

;;; L-Eval value:
(... ...)

;;; L-Eval input:
(car two)

;;; L-Eval value:
2

;;; L-Eval input:
(cdr two)

;;; L-Eval value:
#0=(1 2 . #0#)

;;; L-Eval input:
one

;;; L-Eval value:
#0=(1 2 . #0#)

;;; L-Eval input:
two

;;; L-Eval value:
#0=(2 1 . #0#)

#+END_SRC
* Variations on a Scheme -- Nondeterministic Computing
** Amb and Search
*** Exercise 4.35
Note that this procedure should behave similar with =an-element-of=:
#+BEGIN_SRC scheme
(define (an-integer-between low high)
  (require (<= low high))
  (amb low (an-integer-between (1+ low) high)))
#+END_SRC

Then here is the test:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(an-integer-between 1 10)

;;; Starting a new problem
;;; Amb-Eval value:
1

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
2

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
3

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
4

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
5

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
6

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
7

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
8

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
9

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
10

;;; Amb-Eval input:
try-again

;;; There are no more values of
(an-integer-between 1 10)
#+END_SRC
*** Exercise 4.36
The specified idea coded as
#+BEGIN_SRC scheme
(define (a-pythagorean-triple-from low high)
     (let ((i (an-integer-starting-from low)))
       (let ((j (an-integer-starting-from i)))
         (let ((k (an-integer-starting-from j)))
           (require (= (+ (* i i) (* j j)) (* k k)))
           (list i j k)))))
#+END_SRC
Unfortunately the last =let= expression doesn't end; it tries all the integers
higher than =j=. So it will never tries other than =i= equals =low=, =j= equals =low=.

So we need to constrain =k= using following rules -- the triangle inequality:
- $i^{2}+j^{2} \ge k^{2} \iff i+j > k$ for $i,j \ge 1$


This also would not work since now =i= is fixed to =low=; this kind problem is
exactly same as before, when we tried to produce stream of pairs from two
input streams. We need to ensure arbitrary element should appear in the
resulting stream after finite number of =cdr= ing down.

Can we fix current problem using the analogous strategy from stream's? Or can we
come up with nondeterminism specific algorithm?

Here we try the latter approach using the observation from
=a-pythagorean-triple-between=; in that procedure, it uses strategy of
elimination -- at any stage of computation, it removes the cases where =i= lower
than current =i=, e.g. if it started from ~low = 2~ and current =i= is 4 then
it is provided that every case where =low= \le =i= \le 4; similar argument
applied to =j= and =k= --, we can apply that strategy to this problem as =k= to
be the first stage of computation.

Here is the code:
#+BEGIN_SRC scheme
(define (a-pythagorean-triple-from low)
     (let ((k (an-integer-starting-from low)))
       (let ((i (an-integer-between low k)))
         (let ((j (an-integer-between i k)))
           (require (= (+ (* i i) (* j j)) (* k k)))
           (list i j k)))))
#+END_SRC

And test:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(a-pythagorean-triple-from 1)

;;; Starting a new problem
;;; Amb-Eval value:
(3 4 5)

...

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(12 16 20)

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(7 24 25)
#+END_SRC

From this exercise, we learned our =amb= evaluator can be thought of as
/generator/ in python as long as it traverse the /choice/ tree in depth-first.
So until now, =amb= evaluator allowed us to loop over infinite range, like
=stream= allowed to process infinite list. Is this observation is general enough
to characterize =amb= evaluator? To answer with this question, we need to
explore following examples with this mind.
*** Exercise 4.37
Yes since the number of cases to try out is different in asymptotic complexity.

The former one is \Theta(n^{3}) and this one is \Theta(n^{2}), where n is the
number of element in the given range -- [low, high].

So as long as same in both are asymptotic complexities of computation in each
step.

The difference in computation of both is the use of =sqrt=. From this
[[https://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations][source]], =sqrt='s complexity same as the multiplication.

So consequently this Ben's version is efficient in asymptotic order.
** Examples of Nondeterministic Programs
*** Exercise 4.38
Here is the result:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(multiple-dwelling)

;;; Starting a new problem
;;; Amb-Eval value:
((baker 1) (cooper 2) (fletcher 4) (miller 3) (smith 5))

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
((baker 1) (cooper 2) (fletcher 4) (miller 5) (smith 3))

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
((baker 1) (cooper 4) (fletcher 2) (miller 5) (smith 3))

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
((baker 3) (cooper 4) (fletcher 2) (miller 5) (smith 1))

;;; Amb-Eval input:
try-again

;;; There are no more values of
(multiple-dwelling)

#+END_SRC

So, 4 more answers!
*** Exercise 4.39
Yes, it matter. We can manage to reduce the average number of tests to get aborted or
succeed. Let we think about the possibilities that each branches passes the
specific requirement. Then reorder the restrictions in the increasing order
of this "weight." After that, we obtain minimum number of tests needed to get answer.

Here is the reordering:
#+BEGIN_SRC scheme
(define (multiple-dwelling)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (> miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (list (list 'baker baker)
          (list 'cooper cooper)
          (list 'fletcher fletcher)
          (list 'miller miller)
          (list 'smith smith))))
#+END_SRC

Then compare the time consumed:
#+BEGIN_SRC scheme
;; original version
(timed (lambda ()
         (ambeval '(multiple-dwelling) the-global-environment
                  (lambda (val fail) val) (lambda () 'ignore))))

time expended: .86
;Value: ((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))

;;modified definition
(timed (lambda ()
         (ambeval '(multiple-dwelling-modified) the-global-environment
                  (lambda (val fail) val) (lambda () 'ignore))))

time expended: .77
;Value: ((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
#+END_SRC
*** Exercise 4.40
Like we did when we transit from list processing to stream processing, let we
interleave construction with filtering along with the criterion as before --
ordering the requirement in "weight".

Let we first inspect the result and then discuss what caused that difference.

Here is the code:
#+BEGIN_SRC scheme
(define (multiple-dwelling-optimized)
     (let ((fletcher (amb 1 2 3 4 5)))
       (require (not (= fletcher 5)))
       (require (not (= fletcher 1)))
       (let ((cooper (amb 1 2 3 4 5)))
         (require (not (= cooper 1)))
         (require (not (= (abs (- fletcher cooper)) 1)))
         (let ((miller (amb 1 2 3 4 5)))
           (require (> miller cooper))
           (let ((baker (amb 1 2 3 4 5)))
             (require (not (= baker 5)))
             (let ((smith (amb 1 2 3 4 5)))
               (require (not (= (abs (- smith fletcher)) 1)))
               (require
                (distinct? (list baker cooper fletcher miller smith)))
               (list (list 'baker baker)
                     (list 'cooper cooper)
                     (list 'fletcher fletcher)
                     (list 'miller miller)
                     (list 'smith smith))))))))
#+END_SRC

Then compare the time it consumed!
#+BEGIN_SRC scheme
(timed (lambda ()
         (ambeval '(multiple-dwelling-optimized) the-global-environment
                  (lambda (val fail) val) (lambda () 'ignore))))

time expended: .14000000000000057
;Value: ((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
#+END_SRC

Huge improvement! We could make this optimization since we made that in each
filtering step the difference of the number of branches, between before and after that
step, minimum. As the number of remaining branches should be only one, it means
we traverse the minimum number of branches at the very beginning.
*** Exercise 4.41
As we noted before, the =amb= evaluator has a lot of analogy with programming
with iterative process. So here we implement requested task using loop.

The typical imperative style coding:
#+BEGIN_SRC scheme
(define (multiple-dwelling)
  (let baker-loop ((baker 1))
    (let cooper-loop ((cooper 1))
      (let fletcher-loop ((fletcher 1))
        (let miller-loop ((miller 1))
          (let smith-loop ((smith 1))
            (if (and (distinct? (list baker cooper fletcher miller smith))
                     (not (= baker 5))
                     (not (= cooper 1))
                     (not (= fletcher 5))
                     (not (= fletcher 1))
                     (> miller cooper)
                     (not (= (abs (- smith fletcher)) 1))
                     (not (= (abs (- fletcher cooper)) 1)))
                (list (list 'baker baker)
                      (list 'cooper cooper)
                      (list 'fletcher fletcher)
                      (list 'miller miller)
                      (list 'smith smith))
                (cond ((< smith 5) (smith-loop (1+ smith)))
                      ((< miller 5) (miller-loop (1+ miller)))
                      ((< fletcher 5) (fletcher-loop (1+ fletcher)))
                      ((< cooper 5) (cooper-loop (1+ cooper)))
                      ((< baker 5) (baker-loop (1+ baker)))
                      (else 'failed!)))))))))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(multiple-dwelling)

;Value: ((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
#+END_SRC

Just for curiosity, here we also implement the functional version -- stream
version:
#+BEGIN_SRC scheme
(define (multiple-dwelling-stream)
  (stream-filter
   (lambda (result) result)
   (stream-append-map
    (lambda (baker)
      (stream-append-map
       (lambda (cooper)
         (stream-append-map
          (lambda (fletcher)
            (stream-append-map
             (lambda (miller)
               (stream-map
                (lambda (smith)
                  (and (distinct? (list baker cooper fletcher miller smith))
                       (not (= baker 5))
                       (not (= cooper 1))
                       (not (= fletcher 5))
                       (not (= fletcher 1))
                       (> miller cooper)
                       (not (= (abs (- smith fletcher)) 1))
                       (not (= (abs (- fletcher cooper)) 1))
                       (list (list 'baker baker) ;return if all the previous test passed
                             (list 'cooper cooper)
                             (list 'fletcher fletcher)
                             (list 'miller miller)
                             (list 'smith smith))))
                (stream-enumerate-interval 1 5)))
             (stream-enumerate-interval 1 5)))
          (stream-enumerate-interval 1 5)))
       (stream-enumerate-interval 1 5)))
    (stream-enumerate-interval 1 5))))
#+END_SRC

Actually this pattern appears frequently when we try to emulate loop in
functional world! So in Scala, by default, =for= loop desugared into above
flat-map map combination.

Test!
#+BEGIN_SRC scheme
(multiple-dwelling-stream)

;Value: {((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1)) ...}
#+END_SRC
*** Exercise 4.42
It is just brain stretching exercise:
#+BEGIN_SRC scheme
(define (either p1 p2)
  (or (and p1 (not p2))
      (and (not p1) p2)))

(define (solve-Liars)
  (let ((Betty (amb 1 2 3 4 5))
        (Ethel (amb 1 2 3 4 5))
        (Joan (amb 1 2 3 4 5))
        (Kitty (amb 1 2 3 4 5))
        (Mary (amb 1 2 3 4 5)))
    (require (distinct? (list Kitty Betty Ethel Joan Mary)))
    (require (either (= Kitty 2) (= Betty 3)))
    (require (either (= Ethel 1) (= Joan 2)))
    (require (either (= Joan 3) (= Ethel 5)))
    (require (either (= Kitty 2) (= Mary 4)))
    (require (either (= Mary 4) (= Betty 1)))
    (list (list 'Betty Betty)
          (list 'Ethel Ethel)
          (list 'Joan Joan)
          (list 'Kitty Kitty)
          (list 'Mary Mary))))
#+END_SRC

#+BEGIN_SRC scheme
;;; Amb-Eval input:
(solve-Liars)

;;; Starting a new problem
;;; Amb-Eval value:
((betty 3) (ethel 5) (joan 2) (kitty 1) (mary 4))

;;; Amb-Eval input:
try-again

;;; There are no more values of
(solve-liars)

#+END_SRC

To support =or= and =and=, using which we defined =either=, we need to modify
our analyzer:
#+BEGIN_SRC scheme
,*** in analyze
        ((and? exp) (analyze (and->transformed exp)))
        ((or? exp) (analyze (or->transformed exp)))
#+END_SRC

For the implementation of those transformation please visit [[org:../MEGAsync/MIT Challenge/6.001/2004/Projects.org][my other project]].

*** Exercise 4.43
As our =amb= evaluator does not support the multi-directional computation, we
need to capture the relationship in one direction. After some experiment, I've
come to realize that let the fathers /has/ a /daughter/ and a /yacht/ would make
our task concise.

Here is (inefficient but) concise problem definition:
#+BEGIN_SRC scheme
(define (solve-daughter-and-yacht)
  ;; underlying relation ADT
  (define yacht cdr)
  (define daughter car)
  (define has-daughter-and-yacht cons)
  (define (has-daughter? father daugh)
    (eq? (daughter father) daugh))
  (define (has-yacht? owner yac)
    (eq? (yacht owner) yac))
  (define (assign-daughter-and-yachts daughters yachts)
    (has-daughter-and-yacht (an-element-of daughters)
                            (an-element-of yachts)))
  (let ((daughters '(Mary Lorna Rosalind Gabrielle Melissa)))
    (let ((yachts daughters))
      (let ((moore (assign-daughter-and-yachts daughters yachts))
            (hall (assign-daughter-and-yachts daughters yachts))
            (barnacle (assign-daughter-and-yachts daughters yachts))
            (parker (assign-daughter-and-yachts daughters yachts))
            (colonel (assign-daughter-and-yachts daughters yachts)))
        (require (has-daughter? moore 'Mary))
        (require (has-yacht? moore 'Lorna))
        (require (has-yacht? hall 'Rosalind))
        (require (has-yacht? barnacle 'Gabrielle))
        (require (has-daughter? barnacle 'Melissa))
        (require (has-yacht? colonel 'Melissa))
        (let ((Gabrielle-father (amb moore hall barnacle parker colonel)))
          (require (has-daughter? Gabrielle-father 'Gabrielle)
                   (has-yacht? Gabrielle-father (daughter parker))))
        (list (list 'Moore moore)
              (list 'Hall hall)
              (list 'Barnacle barnacle)
              (list 'Parker parker)
              (list 'Colonel colonel))))))
#+END_SRC

Yet, this won't work; more precisely, it is hard to wait until it spit the answer.

So let's optimize as we did before:
#+BEGIN_SRC scheme
(define (solve-daughter-and-yacht)
  ;; underlying relation ADT
  (define yacht cdr)
  (define daughter car)
  (define has-daughter-and-yacht cons)
  (define (has-daughter? father daugh)
    (eq? (daughter father) daugh))
  (define (has-yacht? owner yac)
    (eq? (yacht owner) yac))
  (define (assign-daughter-and-yachts daughters yachts)
    (has-daughter-and-yacht (an-element-of daughters)
                            (an-element-of yachts)))
  (let ((daughters '(Mary Lorna Rosalind Gabrielle Melissa)))
    (let ((yachts daughters))
      (let ((moore (assign-daughter-and-yachts daughters yachts)))
        (require (has-daughter? moore 'Mary))
        (require (has-yacht? moore 'Lorna))
        (let ((barnacle (assign-daughter-and-yachts daughters yachts)))
          (require (has-yacht? barnacle 'Gabrielle))
          (require (has-daughter? barnacle 'Melissa))
          (let ((hall (assign-daughter-and-yachts daughters yachts)))
            (require (has-yacht? hall 'Rosalind))
            (let ((colonel (assign-daughter-and-yachts daughters yachts)))
              (require (has-yacht? colonel 'Melissa))
              (let ((parker (assign-daughter-and-yachts daughters yachts)))
                (let ((fathers (list moore barnacle hall colonel parker)))
                  (require (distinct? (map daughter fathers)))
                  (require (distinct? (map yacht fathers)))
                  (let ((Gabrielle-father (an-element-of fathers)))
                    (require (has-daughter? Gabrielle-father 'Gabrielle))
                    (require (has-yacht? Gabrielle-father (daughter parker))))
                  (list (list 'Moore moore)
                        (list 'Hall hall)
                        (list 'Barnacle barnacle)
                        (list 'Parker parker)
                        (list 'Colonel colonel)))))))))))
#+END_SRC

Then now it response.
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(solve-daughter-and-yacht)

;;; Starting a new problem
;;; Amb-Eval value:
((moore (mary . lorna)) (hall (gabrielle . rosalind)) (barnacle (melissa . gabrielle)) (parker (rosalind . mary)) (colonel (lorna . melissa)))

;;; Amb-Eval input:
try-again

;;; There are no more values of
(solve-daughter-and-yacht)

#+END_SRC

So Lorna's father is Colonel Downing.
*** Exercise 4.44
Here is the straight forward transformation:
#+BEGIN_SRC scheme
(define (solve-queens board-size)
  (define empty-board '())
  (define (adjoin-position new-row rest-of-queens)
    (cons new-row rest-of-queens))
  (define (safe? positions)
    (define (not-equal-to? nr rest)
      (or (null? rest)
          (and (not (= nr (car rest)))
               (not-equal-to? nr (cdr rest)))))
    (define (pm-i-not-equal-to? nr i rest)
      (or (null? rest)
          (and (not (or (= (+ nr i) (car rest))
                        (= (- nr i) (car rest))))
               (pm-i-not-equal-to? nr (1+ i) (cdr rest)))))
    (let ((new-row (car positions))
          (rest-queens (cdr positions)))
      (and (not-equal-to? new-row rest-queens) ;provided that positions not empty
           (pm-i-not-equal-to? new-row 1 rest-queens))))
  (define (queens-cols k)
    (if (= k 0)
        empty-board
        (let ((positions
               (adjoin-position
                (an-integer-between 1 board-size)
                (queens-cols (- k 1)))))
          (require (safe? positions))
          positions)))
  (queens-cols board-size))
#+END_SRC

It works
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(solve-queens 6)

;;; Starting a new problem
;;; Amb-Eval value:
(2 4 6 1 3 5)

#+END_SRC

Unfortunately, this algorithm in nondeterministic programming is way too slow.
It is due to the order of recursive calling and branching:
#+BEGIN_SRC scheme
(define (solve-queens board-size)
...
  (define (queens-cols k)
    (if (= k 0)
        empty-board
        (let ((rest-queens (queens-cols (- k 1)))) ;the only change
          (let ((positions (adjoin-position
                            (an-integer-between 1 board-size)
                            rest-queens)))
            (require (safe? positions))
            positions))))
  (queens-cols board-size))
#+END_SRC

By forcing the recursion before branching -- =an-integer-between= -- our program
got way more fast:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(solve-queens 10)

;;; Starting a new problem
;;; Amb-Eval value:
(7 4 2 9 5 10 8 6 3 1)

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(8 5 2 4 10 7 9 6 3 1)

#+END_SRC

Conclusion: Computation order impact hugely on efficiency!
*** Exercise 4.45
Input and output:
#+BEGIN_SRC scheme
(parse '(The professor lectures to the student in the class with the cat))

;; output
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class))))
  (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))

(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student))))
              (prep-phrase (prep in) (noun-phrase (simple-noun-phrase (article the) (noun class)) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))

(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase (verb lectures) (prep-phrase (prep to) (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class))))))
  (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))

(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase
   (prep to)
   (noun-phrase (noun-phrase (simple-noun-phrase (article the) (noun student)) (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class))))
                (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))

(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase
   (prep to)
   (noun-phrase (simple-noun-phrase (article the) (noun student))
                (prep-phrase (prep in) (noun-phrase (simple-noun-phrase (article the) (noun class)) (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))))))
#+END_SRC

Interpretation:
1. First output means "the professor is with the cat" and "lectures in the class"
   to student.
2. Second means the professor is in "the class with the cat" and lectures to student.
3. Third means "the professor is with the cat" and lectures to "student in the class."
4. Forth means the professor lectures to "student in the class" with the cat.
5. Last means the professor lectures to student in "the class with the cat."
*** Exercise 4.46
Note that =parse-prepositional-phrase= and =parse-noun-phrase= procedure is
mutually recursive. If the evaluator evaluate in different order than now,
evaluating =parse-prepositional-phrase= leads to =parse-noun-phrase= without
consuming =preposition= and which in turn consume =simple-noun-phrase= and then
execute =parse-prepositional-phrase=. Which is not the one we wanted.
*** Exercise 4.47
This version did not store the checkered point; so as long as there is answer it
can consume it will work as expected. Otherwise, it falls into the infinite
loop. You can understand this situation easily by drawing the tree structure it
branches.

If we interchange the expression order, it even won't work if we try
=(parse '(The professor))=. It just run forever without spitting anything.
*** Exercise 4.48
Here we try to include the clause; now we can parse compound sentence. Here is
the design with the code:
#+BEGIN_SRC scheme
(define subordinates '(subord when if))

;; Subordinate-clause := Subordinate + Sentence
(define (parse-subordinate-clause)
  (list 'subordinate-clause
        (parse-word subordinates)
        (parse-sentence)))

;; Setence := Simple-sentence | Sentence + Subordinate-clause
(define (parse-sentence)
  (define (maybe-extend sentence)
    (amb sentence
         (maybe-extend (list 'compound-sentence
                             sentence
                             (parse-subordinate-clause)))))
  (maybe-extend (parse-simple-sentence)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(parse '(the professor lectures to the student in the class when the cat eats))

;;; Starting a new problem
;;; Amb-Eval value:
(compound-sentence
 (simple-sentence
  (simple-noun-phrase (article the) (noun professor))
  (verb-phrase (verb-phrase (verb lectures) (prep-phrase (prep to) (simple-noun-phrase (article the) (noun student)))) (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class)))))
 (subordinate-clause (subord when) (simple-sentence (simple-noun-phrase (article the) (noun cat)) (verb eats))))

#+END_SRC
*** Exercise 4.49
To support =generate= we make following changes:
#+BEGIN_SRC scheme
(define (parse-word word-list)
  ;; (require (not (null? *unparsed*)))
  ;; (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (an-element-of (cdr word-list))))
    ;; (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))

(define (generate)
  (parse '()))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(generate)

;;; Starting a new problem
;;; Amb-Eval value:
(simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))
                   (subordinate-clause (subord when) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))))

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(compound-sentence
 (compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))
                    (subordinate-clause (subord when) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))))
 (subordinate-clause (subord when) (simple-sentence (simple-noun-phrase (article the) (noun student)) (verb studies))))

#+END_SRC

As implied, it is not interesting; just repeat the sentence "the student
studies" using the =when= subordinate adjunct.
** Implementing the =Amb= Evaluator
*** Exercise 4.50
Here is the implementation. Design should be done in prior, in my case I've done
in my digital paper. And here is the resulting code:
#+BEGIN_SRC scheme
;; ramb syntax procedure

(define (ramb? exp) (tagged-list? exp 'ramb))
(define ramb-choices amb-choices)
#+END_SRC

#+BEGIN_SRC scheme
,*** in analyze
        ((ramb? exp) (analyze-ramb exp))
#+END_SRC

#+BEGIN_SRC scheme
(define (analyze-ramb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-rand choices)
        (let ((chosen (pick-random choices)))
          (if chosen
              (chosen
               env succeed
               (lambda ()
                 (try-rand (filter (lambda (choice) (not (eq? choice chosen)))
                                   choices))))
                (fail))))
      (try-rand cprocs))))
#+END_SRC

Then here is modification:
#+BEGIN_SRC scheme
(define (parse-word word-list)
  ;; (require (not (null? *unparsed*)))
  ;; (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (choose-randomly (cdr word-list))))
    ;; (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))

(define (choose-randomly lst)
  (require (not (null? lst)))
  (ramb (car lst) (choose-randomly (cdr lst))))
#+END_SRC

Then the result from =generate=:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(generate)

;;; Starting a new problem
;;; Amb-Eval value:
(simple-sentence (simple-noun-phrase (article a) (noun professor)) (verb studies))

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(compound-sentence (simple-sentence (simple-noun-phrase (article a) (noun professor)) (verb studies))
                   (subordinate-clause (subord if) (simple-sentence (simple-noun-phrase (article the) (noun cat)) (verb studies))))

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(compound-sentence (compound-sentence (simple-sentence (simple-noun-phrase (article a) (noun professor)) (verb studies))
                                      (subordinate-clause (subord if) (simple-sentence (simple-noun-phrase (article the) (noun cat)) (verb studies))))
                   (subordinate-clause (subord when) (simple-sentence (simple-noun-phrase (article the) (noun professor)) (verb studies))))

;;; Amb-Eval input:
(generate)

;;; Starting a new problem
;;; Amb-Eval value:
(simple-sentence (simple-noun-phrase (article the) (noun professor)) (verb sleeps))

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(compound-sentence (simple-sentence (simple-noun-phrase (article the) (noun professor)) (verb sleeps))
                   (subordinate-clause (subord when) (simple-sentence (simple-noun-phrase (article a) (noun cat)) (verb eats))))


#+END_SRC

Quite interesting!
*** Exercise 4.51
To make assignment permanently, we just remove the undo steps in
=analyze-assignment=:
#+BEGIN_SRC scheme
(define (analyze-permanent-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (set-variable-value! var val env)
               (succeed 'ok fail2))
             fail))))
#+END_SRC

Then detector (we just reuse the selectors from =assignment=):
#+BEGIN_SRC scheme
(define (permanent-assignment? exp)
  (tagged-list? exp 'permanent-set!))
#+END_SRC

Then test!
#+BEGIN_SRC scheme
;;; Amb-Eval input:

(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))

;;; Starting a new problem
;;; Amb-Eval value:
ok

;;; Amb-Eval input:

;;; Starting a new problem
;;; Amb-Eval value:
(a b 2)

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
(a c 3)

#+END_SRC

If we used =set!= instead =permanent-set!=, then the =count= always be 1 since
it =set!= after branching so the undoing step is done in prior of backtracking.
*** Exercise 4.52
You should design that is analogous to =if=:
#+BEGIN_SRC scheme
(define (analyze-if-fail exp)
  (let ((try (analyze (if-fail-try exp)))
        (failed (analyze (if-fail-failed exp))))
    (lambda (env succeed fail)
      (try env succeed
           (lambda () (failed env succeed fail))))))

(define (if-fail? exp) (tagged-list? exp 'if-fail))
(define (if-fail-try exp) (cadr exp))
(define (if-fail-failed exp) (caddr exp))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)

;;; Starting a new problem
;;; Amb-Eval value:
all-odd

;;; Amb-Eval input:
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)

;;; Starting a new problem
;;; Amb-Eval value:
8

#+END_SRC
*** Exercise 4.53
The result would be the list of all the possible =prime-sum-pair= s! You can
reason this about by keeping track of the time tree it makes or it would be more
convicing that you see the result in your eyes:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))

;;; Starting a new problem
;;; Amb-Eval value:
((8 35) (3 110) (3 20))

#+END_SRC
*** Exercise 4.54
It is easy:
#+BEGIN_SRC scheme
(define (require? exp) (tagged-list? exp 'require))
(define (require-predicate exp) (cadr exp))

(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if (false? pred-value)
                   (fail2)
                   (succeed 'ok fail2)))
             fail))))
#+END_SRC
* Logic Programming
** Deductive Information Retrieval
*** Exercise 4.55
**** a.
#+BEGIN_SRC scheme
;;; Query input:
(supervisor ?x (Bitdiddle Ben))

;;; Query results:
(supervisor (tweakit lem e) (bitdiddle ben))
(supervisor (fect cy d) (bitdiddle ben))
(supervisor (hacker alyssa p) (bitdiddle ben))

#+END_SRC
**** b.
#+BEGIN_SRC scheme
;;; Query input:
(job ?x (accounting . ?y))

;;; Query results:
(job (cratchet robert) (accounting scrivener))
(job (scrooge eben) (accounting chief accountant))

#+END_SRC
**** c.
#+BEGIN_SRC scheme
;;; Query input:
(address ?x (Slumerville . ?rest))

;;; Query results:
(address (aull dewitt) (slumerville (onion square) 5))
(address (reasoner louis) (slumerville (pine tree road) 80))
(address (bitdiddle ben) (slumerville (ridge road) 10))

#+END_SRC
*** Exercise 4.56
**** a.
#+BEGIN_SRC scheme
;;; Query input:
(and (supervisor ?person (Bitdiddle Ben))
     (address ?person ?where))

;;; Query results:
(and (supervisor (tweakit lem e) (bitdiddle ben))
     (address (tweakit lem e) (boston (bay state road) 22)))
(and (supervisor (fect cy d) (bitdiddle ben))
     (address (fect cy d) (cambridge (ames street) 3)))
(and (supervisor (hacker alyssa p) (bitdiddle ben))
     (address (hacker alyssa p) (cambridge (mass ave) 78)))
#+END_SRC
**** b.
#+BEGIN_SRC scheme
;;; Query input:
(and (salary (Bitdiddle Ben) ?Ben-amount)
     (salary ?person ?amount)
     (lisp-value < ?amount ?Ben-amount))

;;; Query results:
(and (salary (bitdiddle ben) 60000)
     (salary (aull dewitt) 25000)
     (lisp-value < 25000 60000))
(and (salary (bitdiddle ben) 60000)
     (salary (cratchet robert) 18000)
     (lisp-value < 18000 60000))
(and (salary (bitdiddle ben) 60000)
     (salary (reasoner louis) 30000)
     (lisp-value < 30000 60000))
(and (salary (bitdiddle ben) 60000)
     (salary (tweakit lem e) 25000)
     (lisp-value < 25000 60000))
(and (salary (bitdiddle ben) 60000)
     (salary (fect cy d) 35000)
     (lisp-value < 35000 60000))
(and (salary (bitdiddle ben) 60000)
     (salary (hacker alyssa p) 40000)
     (lisp-value < 40000 60000))
#+END_SRC
**** c.
#+BEGIN_SRC scheme
;;; Query input:
(and (supervisor ?person ?someone)
     (not (job ?someone (computer . ?any)))
     (job ?someone ?his-job))

;;; Query results:
(and (supervisor (aull dewitt) (warbucks oliver))
     (not (job (warbucks oliver) (computer . ?any)))
     (job (warbucks oliver) (administration big wheel)))
(and (supervisor (cratchet robert) (scrooge eben))
     (not (job (scrooge eben) (computer . ?any)))
     (job (scrooge eben) (accounting chief accountant)))
(and (supervisor (scrooge eben) (warbucks oliver))
     (not (job (warbucks oliver) (computer . ?any)))
     (job (warbucks oliver) (administration big wheel)))
(and (supervisor (bitdiddle ben) (warbucks oliver))
     (not (job (warbucks oliver) (computer . ?any)))
     (job (warbucks oliver) (administration big wheel)))
#+END_SRC
*** Exercise 4.57
#+BEGIN_SRC scheme
(rule (can-be-replaced-by ?p1 ?p2)
      (and (job ?p1 ?job1) (job ?p2 ?job2)
           (or (same ?job1 ?job2)
               (can-do-job ?job2 ?job1))
           (not (same ?p1 ?p2))))
#+END_SRC
**** a.
#+BEGIN_SRC scheme
;;; Query input:
(can-be-replaced-by (Fect Cy D) ?whom)

;;; Query results:
(can-be-replaced-by (fect cy d) (bitdiddle ben))
(can-be-replaced-by (fect cy d) (hacker alyssa p))

#+END_SRC
**** b.
#+BEGIN_SRC scheme
;;; Query input:
(and (can-be-replaced-by ?p1 ?p2)
     (salary ?p1 ?a1) (salary ?p2 ?a2)
     (lisp-value > ?a1 ?a2))

;;; Query results:
(and (can-be-replaced-by (warbucks oliver) (aull dewitt)) (salary (warbucks oliver) 150000) (salary (aull dewitt) 25000) (lisp-value > 150000 25000))
(and (can-be-replaced-by (hacker alyssa p) (fect cy d)) (salary (hacker alyssa p) 40000) (salary (fect cy d) 35000) (lisp-value > 40000 35000))
#+END_SRC
*** Exercise 4.58
Here is the definition:
#+BEGIN_SRC scheme
(rule (big-shot ?p)
      (and (job ?p (?div . ?rest))
           (not (and (supervisor ?p ?boss) ;not have a boss who work in the same division
                     (job ?boss (?div2 . ?rest2))
                     (same ?div ?div2)))))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;;; Query input:
(big-shot ?who)

;;; Query results:
(big-shot (scrooge eben))
(big-shot (warbucks oliver))
(big-shot (bitdiddle ben))

#+END_SRC
*** Exercise 4.59
**** a.
#+BEGIN_SRC scheme
;;; Query input:
(meeting ?division (Friday ?time))

;;; Query results:
(meeting administration (friday |1pm|))

#+END_SRC
**** b.
Here is the resulting code:
#+BEGIN_SRC scheme
(rule (meeting-time ?person ?day-and-time)
      (or (meeting whole-company ?day-and-time)
          (and (job ?person (?division . ?subtitle))
               (meeting ?division ?day-and-time))))
#+END_SRC
**** c.
#+BEGIN_SRC scheme
;;; Query input:
(meeting-time (Hacker Alyssa P) (Wednesday ?time))

;;; Query results:
(meeting-time (hacker alyssa p) (wednesday |4pm|))
(meeting-time (hacker alyssa p) (wednesday |3pm|))
#+END_SRC
*** Exercise 4.60
Since the rule is symmetry: If =(lives-near p1 p2)= then also =(lives-near p2
p1)=. To make the requested happen, we need query with non-symmetric relation
by imposing order in persons. The most canonical way of doing this is
lexicographical ordering:
#+BEGIN_SRC scheme
(define (name<? s-lst1 s-lst2)
  (symbol<? (fold-right symbol-append '|| s-lst1)
            (fold-right symbol-append '|| s-lst2)))
#+END_SRC

Then we can query as
#+BEGIN_SRC scheme
;;; Query input:
(and (lives-near ?person-1 ?person-2) (lisp-value name<? ?person-1 ?person-2))

;;; Query results:
(and (lives-near (aull dewitt) (reasoner louis)) (lisp-value name<? (aull dewitt) (reasoner louis)))
(and (lives-near (aull dewitt) (bitdiddle ben)) (lisp-value name<? (aull dewitt) (bitdiddle ben)))
(and (lives-near (fect cy d) (hacker alyssa p)) (lisp-value name<? (fect cy d) (hacker alyssa p)))
(and (lives-near (bitdiddle ben) (reasoner louis)) (lisp-value name<? (bitdiddle ben) (reasoner louis)))
#+END_SRC
*** Exercise 4.61
#+BEGIN_SRC scheme
(?x next-to ?y in (1 (2 3) 4))
#+END_SRC
would results in
#+BEGIN_SRC scheme
?x = 1,		?y = (2 3)                  ;by applying base case
?x = (2 3),	?y = 4                      ;by applying recursive case and then base
#+END_SRC

And the
#+BEGIN_SRC scheme
(?x next-to 1 in (2 1 3 1))
#+END_SRC
would spit out
#+BEGIN_SRC scheme
?x = 2                                  ;by applying base case
?x = 3                                  ;by applying recursive case twice and then base
#+END_SRC

And verification:
#+BEGIN_SRC scheme
;;; Query input:
(?x next-to ?y in (1 (2 3) 4))

;;; Query results:
(1 next-to (2 3) in (1 (2 3) 4))
((2 3) next-to 4 in (1 (2 3) 4))

;;; Query input:
(?x next-to 1 in (2 1 3 1))

;;; Query results:
(2 next-to 1 in (2 1 3 1))
(3 next-to 1 in (2 1 3 1))
#+END_SRC

This exercise shows we are not limited to the prefix notation, which is used in
underlying Scheme evaluator, in query language.
*** Exercise 4.62
Here is the straight forward transformation:
#+BEGIN_SRC scheme
(rule (last-pair (?x) (?x)))            ;base case
(rule (last-pair (?head . ?tail) ?x)    ;recursive case
      (last-pair ?tail ?x))
#+END_SRC

Here you should be careful in =assert!= order: You should =assert!= recursive
rule first and then base rule. It might sound counterintuitive; it is due to the
implementation details of data base where the assertions and rules stored.

Then test!
#+BEGIN_SRC scheme
;;; Query input:
(last-pair (3) ?x)

;;; Query results:
(last-pair (3) (3))

;;; Query input:
(last-pair (2 ?x) (3))

;;; Query results:
(last-pair (2 3) (3))

#+END_SRC

Then the last unfolding case:
#+BEGIN_SRC scheme
;;; Query input:
(last-pair ?x (3))

;;; Query results:
(last-pair (3) (3))
(last-pair (?head-181 3) (3))
(last-pair (?head-181 ?head-185 3) (3))
(last-pair (?head-181 ?head-185 ?head-189 3) (3))
(last-pair (?head-181 ?head-185 ?head-189 ?head-193 3) (3))
(last-pair (?head-181 ?head-185 ?head-189 ?head-193 ?head-197 3) (3))
(last-pair (?head-181 ?head-185 ?head-189 ?head-193 ?head-197 ?head-201 3) (3))
(last-pair (?head-181 ?head-185 ?head-189 ?head-193 ?head-197 ?head-201 ?head-205 3) (3))
...
#+END_SRC

It is reasonable since the revert is right!
#+BEGIN_SRC scheme
;;; Query input:
(last-pair (?head-181 ?head-185 ?head-189 ?head-193 ?head-197 3) (3))

;;; Query results:
(last-pair (?head-304 ?head-306 ?head-308 ?head-310 ?head-312 3) (3))

#+END_SRC
And as =?head-...= is free variable the result assert (infinite number of) facts
that for any assignment to =?head-...= the given statements are satisfied.

And also note that the number appended to the variable name like 181 in
=?head-181= is due to the implementation detail.
*** Exercise 4.63
#+BEGIN_SRC scheme
(rule (grandson ?g ?s)
      (and (son ?f ?s) (son ?g ?f)))
(rule (son ?m ?s)
      (and (wife ?m ?w) (son ?w ?s)))
#+END_SRC

Then test!
#+BEGIN_SRC scheme
;;; Query input:
(grandson Cain ?who)

;;; Query results:
(grandson cain irad)

;;; Query input:
(son Lamech ?son)

;;; Query results:
(son lamech jubal)
(son lamech jabal)

;;; Query input:
(grandson Methushael ?who)

;;; Query results:
(grandson methushael jubal)
(grandson methushael jabal)

#+END_SRC
** How the Query System Works
** Is Logic Programming Mathematical Logic?
*** Exercise 4.64
By the high level specification of this logic language, we can trace the
query =(outranked-by (Bitdiddle Ben) ?who)= as follows:
1. =?staff-person= is bound to =(Bitdiddle Ben)= and =?who= is bound to =?boss=
   (since after this point by using the body of rule they are going to bind
   =?boss=; so we need to bind =?who= here to propagate the subsequent bindings).
2. Depending on the implementation details, whether it spits out the first
   output of =(supervisor ?staff-person ?boss)= or =(and (outranked-by
   ?middle-manager) (supervisor ?staff-person ?middle-manager))=
3. Here let we assume the case =or= consume the latter one first. Then by the
   specification of =and= it first query =(outranked-by ?middle-manager ?boss)=
   with the input frame, which is extended from *1.* but has no bindings for
   =?middle-manager= and =?boss=.
4. By the same arguments from *1.* to *3.* it infinitely process =(outranked-by
   ?middle-manager ?boss)= without bindings for those.
5. Now let we consider other way around: =or= first process the former one. Then
   it now extend frame with binding for =?boss=; so it spits out possible
   answers but to find more it should consume the latter one. It follows to the
   reasoning we did in the above case but spitting out each answer it encounters
  , after that, falling into infinite loops.


Let's experiment with our evaluator to verify what path our evaluator proceed:
#+BEGIN_SRC scheme
;;; Query input:
(outranked-by (Bitdiddle Ben) ?who)

;;; Query results:
(outranked-by (bitdiddle ben) (warbucks oliver))
(outranked-by (bitdiddle ben) (warbucks oliver))  C-c C-c
;Quit!
#+END_SRC

Yes the rather one is what our evaluator chose.
*** Exercise 4.65
Since there is four different frames satisfying Oliver to be wheel:
#+BEGIN_SRC scheme
?middle-manager		?x
Bitdiddle Ben		Hacker Alyssa P
Bitdiddle Ben		Fect Cy D
Bitdiddle Ben		Tweakit Lem E
Scrooge Eben			Cartchet Robert
#+END_SRC
*** Exercise 4.66
Think about the following request:
#+BEGIN_SRC scheme
(sum ?amount
     (and (wheel? ?x)
          (salary ?x ?amount)))
#+END_SRC
to find out the total salaries of all the wheels in the Microshaft company. But
as we seen before Oliver counted forth times. What we wanted! We wanted to count
once for each wheel without duplication.

To deal with this malfunction, he need to remove the duplicate frames from the
output stream of query. Here we need to define what is duplicate frames
rigorously:
1. Extract the pattern variables used in =<query pattern>= from each output frames;
2. Take the first frame in the output frame stream and then filtering the rest
   of output stream based on the values bound to extracted variables, that is,
   to remove frames that has the same set of values with the first frame from
   the rest ones.
*** Exercise 4.67
This situation is similar with the designing the detector of cycle in the
section 3 in the text; but got more complicated.

The key point is that in what situation we know that we came to the "same" query
that processed before in this query chain. If the variable names are same as
before in frame should be that case? Certainly not since rule application is
recursive in their nature as we have seen in previous exercises
(=append-to-form= or =last-pair= and so on).

And it is also important to recognize in what situation we possibly falls into
infinite loop? We can reason about this question by thinking the cycle case or
all the other programs that results in infinite loops: The means of abstraction
allows us to program which can leads to infinite loop. So the rule application
is the main region we should consider.

Combining the preceding two paragraph, we can conclude that if we trace what
rule application we have used so far in this query chain with the values of the
variables in rule conclusion with which the body of that rule application
executed, we can detect whether we are going to loop infinitely:
- If we the same rule application with the same values -- same values is means
  either the values of two variables is bound to the equal value (for the case
  the value also contains variables, it recursively walk the tree structure to
  find out whether the two variables bound to same value) or both variables are
  unbound -- it should signal that we are now in the loop.
*** Exercise 4.68
To make the rule work in both way, we need to the recursive rule conclusion to
be decomposed in both argument. Here we try to accomplish this restriction using
=append-to-form= since it decompose the input arguments in multi-directional
way:
#+BEGIN_SRC scheme
(rule (reverse () ()))                  ;base case
(rule (reverse (?x . ?xs) ?y)           ;recursive case
      (and (append-to-form ?rs (?x) ?y)
           (reverse ?xs ?rs)))
#+END_SRC

But this works in unidirectional way:
#+BEGIN_SRC scheme
;;; Query input:
(reverse ?x (1 2 3))

;;; Query results:
(reverse (3 2 1) (1 2 3))

;;; Query input:
(reverse (1 2 3) ?x)

;;; Query results:
(reverse (1 2 3) (3 2 1))  C-c C-c
;Quit!

#+END_SRC

To resolve this situation, we need to think it falls into the infinite loop
after spitting out the answer.

After some experimenting or reasoning we can reach to think it is due to
unfortunate of =append-to-form=:
#+BEGIN_SRC scheme
;;; Query input:
(append-to-form ?x (1) ?y)

;;; Query results:
(append-to-form () (1) (1))
(append-to-form (?u-397) (1) (?u-397 1))
(append-to-form (?u-397 ?u-399) (1) (?u-397 ?u-399 1))
(append-to-form (?u-397 ?u-399 ?u-401) (1) (?u-397 ?u-399 ?u-401 1))
(append-to-form (?u-397 ?u-399 ?u-401 ?u-403) (1) (?u-397 ?u-399 ?u-401 ?u-403 1))
#+END_SRC

This stream of frames passed to =(reverse ?xs ?rs)= when we try to execute
=(reverse (1 2 3) ?x)=; no limit in this unfolding. So if we can limit this
infinite unfolding, then we got what we wanted!

Here is the deal:
#+BEGIN_SRC scheme
(assert! (rule (same-length () ())))
(assert! (rule (same-length (?x . ?xs) (?y . ?ys))
               (same-length ?xs ?ys)))
#+END_SRC

Then restrict our unfolding using above rule!
#+BEGIN_SRC scheme
(assert! (rule (reverse () ())))
(assert! (rule (reverse (?x . ?xs) ?y)
               (and (same-length (?x . ?xs) ?y)
                    (append-to-form ?rs (?x) ?y)
                    (reverse ?xs ?rs))))
#+END_SRC

Now try our new =reverse=
#+BEGIN_SRC scheme
;;; Query input:
(reverse (1 2 3) ?x)

;;; Query results:
(reverse (1 2 3) (3 2 1))

;;; Query input:
(reverse ?x (1 2 3))

;;; Query results:
(reverse (3 2 1) (1 2 3))

#+END_SRC

Now it works in multi-direction.

The lesson from this exercise: We can restrict the pattern variable like we did
in the nondeterministic programming; but in more confined way. We can limit the
variable via confining the relations but not in a direct way such as =if= or like
that control stuff.
*** Exercise 4.69
Here is the first task: Write rule that determine if a list ends in the word
=grandson=
#+BEGIN_SRC scheme
(rule (end-with-grandson ?rel)
      (last-pair ?rel (grandson)))
#+END_SRC

Then the main tasks:
#+BEGIN_SRC scheme
(rule ((grandson) ?x ?y)
      (grandson ?x ?y))
(rule ((great . ?rel) ?x ?y)
      (and (son ?x ?g)
           (?rel ?g ?y)
           (end-with-grandson ?rel)))
#+END_SRC

The first clause of above rules is needed since our recursive rule definition
only reduced to =(grandson)=. So we need to connect from =(grandson)= to
=grandson=.

Then test:
#+BEGIN_SRC scheme
;;; Query input:
((great grandson) ?g ?ggs)

;;; Query results:
((great grandson) mehujael jubal)
((great grandson) irad lamech)
((great grandson) mehujael jabal)
((great grandson) enoch methushael)
((great grandson) cain mehujael)
((great grandson) adam irad)

;;; Query input:
(?relationship Adam Irad)

;;; Query results:
((great grandson) adam irad)

;;; Query input:
((great great great great grandson) ?g ?gggggs)

;;; Query results:
((great great great great grandson) cain jubal)
((great great great great grandson) adam lamech)
((great great great great grandson) cain jabal)

#+END_SRC
** Implementing the Query System
*** Exercise 4.70
Note that we have combined assignment with lazy evaluation, which normally what
we shouldn't do if we can escape.

Here we expect to mutate using what I get if we lookup the environment in this
state -- =THE-ASSERTIONS=; however since the =cdr= part of =cons-stream= delayed
implicitly, we don't know which "version" we actually mutate when the evaluation
being made in computer.

In this specific situation, we know what the result would be: The infinite
stream of one element, newly added =assertion= like =ones=.
*** Exercise 4.71
To answer this question we need to simulate what our evaluator does.

For the first situation -- =simple-query= if it uses delayed append:
1. From the entry point (by user input in the driver loop or that of subsequent
   query) =simple-query= is called by data directed dispatch.
2. The body of =simple-query= is evaluated:
   1. =stream-flatmap=
   2. =lambda= expression
   3. =frame-stream=
3. The body of =stream-flatmap= is evaluated. Before =stream-append='s body
   being evaluated, =find-assertions= is evaluated but =apply-rules= since it is
   delayed.
4. After =find-assertions= terminates with the returning stream of frames, the
   body of =stream-append-delayed= is evaluated.
5. Only if that stream is empty =stream-append-delayed= force the evaluation of
   =apply-rules=; otherwise the body of =stream-flatmap= is evaluated.
6. As the result, the body of =stream-flatmap= is halted with returning output stream.

If =simple-query= uses =stream-append= instead delayed version of that:
1. Until *2.* the evaluations are same as above.
2. Now =stream-flatmap='s body being evaluated. =apply-rules= being evaluated
   as well as =find-assertions= before the body of =stream-append=.
3. By the same arguments as preceding ones, =apply-rules= in turn calls
   =apply-a-rule= that evaluate the body of given rule with the frame.
4. In =apply-rules=, =apply-a-rule= is evaluated until find the rule that matched
   with the query or exhausted the rules to be tested with.
5. If found one that is matched then the matched rule's body is evaluated.
6. Note that so far we have not processed any frame completely. We just chained
   the evaluation of argument.
7. However rule can call recursively itself.
8. Normally recursive rule meant to reduce the given problem into more simpler
   problem; so if the recursive rule calling ended with base case rule -- the
   rule has empty body, then it halted as normally.
9. It is possible that the base case depends on the assertions not the rule
   with empty body. In this case, also halted as normally since there is no rule
   that can be applied to this query.


So the logic program that would halt in one version, also halt in another
version. Although here we showed this assertion using the evaluation process in
both evaluator, we can think this in more abstract manner: Delay or stream can
only mutate the evaluation order not the result if we don't mix the assignment.
This observation should be familiar with us; in situation where substitution
model can be applied, the evaluation order can not alter the result.

So two different =simple-query= can not make any change at all for the program
which halted; it only make difference in non-halting program: run forever of
signaling an error. We can inspect this assertion using following examples:

#+BEGIN_SRC scheme
(assert! (rule (infinite ?x)
               (infinite ?x)))
(assert! (infinite answer))
#+END_SRC

First the test with original =simple-query=:
#+BEGIN_SRC scheme
;;; Query input:
(infinite ?x)

;;; Query results:
(infinite answer)
(infinite answer)
(infinite answer)
(infinite answer)
...
(infinite answer)
(infinite answer)
(infinite answer)  C-c C-c
;Quit!

#+END_SRC

Then the =simple-query= without append delayed:
#+BEGIN_SRC scheme
;;; Query input:
(infinite ?x)

;;; Query results:  C-c C-c
;Quit!
#+END_SRC

So the difference became apparent: One finds all the possible answers yet run
forever; other one just run forever without find any.

Let's do the same kind of argument to the second question. It is almost same as
the first one -- =simple-query= case.

The preceding observation applies here too. So here we just show the example
that embodies the difference.

For that example here we use the one from [[Exercise 4.64][ex 4.64]]:
#+BEGIN_SRC scheme
(outranked-by (Bitdiddle Ben) ?who)
#+END_SRC
with the ill-defined rule definition:
#+BEGIN_SRC scheme
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person ?middle-manager))))
#+END_SRC

In previous exercise, it would spit out all the possible answers and then run
forever. But with modified =disjoin= we got
#+BEGIN_SRC scheme
;;; Query input:
(outranked-by (Bitdiddle Ben) ?who)

;;; Query results:  C-c C-c
;Quit!
#+END_SRC

If we revert the modification in =disjoin=, we got
#+BEGIN_SRC scheme
;;; Query input:
(outranked-by (Bitdiddle Ben) ?who)

;;; Query results:
(outranked-by (bitdiddle ben) (warbucks oliver))
(outranked-by (bitdiddle ben) (warbucks oliver))  C-c C-c
;Quit!
#+END_SRC
as expected (the reason we got the same answer duplicated is that we asserted
two =outranked-by= -- one for proper definition and one for ill-definition).
*** Exercise 4.72
We used =interleave= in section 3.5.3 for dealing with =pair=, the stream of
pairs from two (possibly infinite) streams; we needed that since we wanted to
make sure that each pair element appear in the resulting stream in finite step
of =cdr= ing down that stream.

Here is also the same situation in abstract viewpoint: even if there is infinite
stream in one of arguments, we want to the program find all the answers from the
other arguments that has finite (or infinite) stream of frames.

Here is the simple example describes above idea:
If we make =disjoin= as
#+BEGIN_SRC scheme
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      (amb)
      (stream-append-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))
#+END_SRC

Then the (stupid) query makes the evaluator fall into infinite loop without
answering:
#+BEGIN_SRC scheme
;;; Query input:
(or (infinite ?x)
    (outranked-by ?who (Bitdiddle Ben)))

;;; Query results:
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))
...
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))  C-c C-c
;Quit!
#+END_SRC

With original one:
#+BEGIN_SRC scheme
;;; Query input:
(or (infinite ?x)
    (outranked-by ?who (Bitdiddle Ben)))

;;; Query results:
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))
(or (infinite ?x) (outranked-by (tweakit lem e) (bitdiddle ben)))
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))
(or (infinite ?x) (outranked-by (reasoner louis) (bitdiddle ben)))
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))
(or (infinite ?x) (outranked-by (fect cy d) (bitdiddle ben)))
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))
(or (infinite ?x) (outranked-by (hacker alyssa p) (bitdiddle ben)))
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))
...
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))  C-c C-c
#+END_SRC

For the =stream-flatmap=, we can apply the same observation to this. We can
illustrate the need by showing following examples:
First let's setup this assertions should be added in initialized data base. The
purpose of following definitions is to show the affection of modified
=stream-flatmap= on =apply-rules=; that is, one of the following rule
application can produce infinite stream of frames, others not.
#+BEGIN_SRC scheme
(assert! (rule (infinite ?x)))
(assert! (rule (infinite ?x)
               (infinite ?x)))
(assert! (infinite answer))
#+END_SRC

Modified =stream-flatmap= with following definition:
#+BEGIN_SRC scheme
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (stream-append-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
#+END_SRC

Then run in the original version:
#+BEGIN_SRC scheme
;;; Query input:
(infinite ?x)

;;; Query results:
(infinite answer)                       ;assertion
(infinite answer)                       ;infinite rule application
(infinite ?x-98763)                     ;base case rule application
(infinite answer)
(infinite ?x-98765)
(infinite answer)
(infinite ?x-98767)
(infinite answer)
(infinite ?x-98769)
...
(infinite answer)  C-c C-c
#+END_SRC

And the modified one:
#+BEGIN_SRC scheme
;;; Query input:
(infinite ?x)

;;; Query results:
(infinite answer)                       ;inifinite rule application with find-assertions
(infinite answer)
(infinite answer)
...
(infinite answer)
#+END_SRC

The original version produces all the possible answers but the modified one does
not as expected.
*** Exercise 4.73
The modified version implicitly forces all the element of given stream until it
encountered with =the-empty-stream=:
1. Evaluate =flatten-stream= with given argument stream;
2. evaluate =stream-cdr= of given stream and evaluate =flatten-stream= with
   resulting =stream=;
3. ... if the subsequent =flatten-stream= calls encountered with
   =the-empty-stream= then calls return the control to the caller.
4. finally the *1.* is get the value from subsequent calls and then return the
   control to the caller.


By above reasoning,
1. without delaying, =flatten-stream= violates what we meant to stream at the
   first place -- deferring the evaluation until it is really needed;
2. even more, =stream=, with which =flatten-stream= called with, can possess
   infinite number of elements. In this case, =flatten-stream= run forever
   without returning the control to the caller.


In this discourse, we used /caller/ and /callee/ concept explicitly since
without this notation reader get easy to confuse with result given process can
produce (infinite stream) with step of evolution (infinite loop).
*** Exercise 4.74
**** a.
By the type constraint, we can fill the slots as
#+BEGIN_SRC scheme
(define (simple-flatten stream)
  (stream-map stream-car
              (stream-filter
               (lambda (s) (not (stream-null? s)))
               stream)))
#+END_SRC
**** b.
No, since in those cases, both result in same stream. We can prove this
assertion by structure induction on =negate=, =lisp-value=, =find-assertions=
combined with induction on length of stream.

More specifically we need to show
1. In both implementation, the resulting stream has same element in same order.
2. If one of the resulting stream is delayed in some part then the other one
   should result the stream with delayed in corresponding part.


As above implementation satisfies given contracts, the behavior of both should
be same.
*** Exercise 4.75
It is analogous to =not=:
#+BEGIN_SRC scheme
(define (uniquely-asserted operand frame-stream)
  (stream-flatmap
   (lambda (frame)
     (let ((output-frames
            (qeval (unique-query operand)
                   (singleton-stream frame))))
       (if (and (not (stream-null? output-frames))
                (stream-null? (stream-cdr output-frames)))
           output-frames
           the-empty-stream)))
   frame-stream))

(define (unique-query operand) (car operand))
#+END_SRC

And install on =qeval=:
#+BEGIN_SRC scheme
,*** in initialize-data-base
  (put 'unique 'qeval uniquely-asserted)
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;;; Query input:
(unique (job ?x (computer wizard)))

;;; Query results:
(unique (job (bitdiddle ben) (computer wizard)))

;;; Query input:
(unique (job ?x (computer programmer)))

;;; Query results:

;;; Query input:
(and (job ?x ?j) (unique (job ?anyone ?j)))

;;; Query results:
(and (job (aull dewitt) (administration secretary)) (unique (job (aull dewitt) (administration secretary))))
(and (job (cratchet robert) (accounting scrivener)) (unique (job (cratchet robert) (accounting scrivener))))
(and (job (scrooge eben) (accounting chief accountant)) (unique (job (scrooge eben) (accounting chief accountant))))
(and (job (warbucks oliver) (administration big wheel)) (unique (job (warbucks oliver) (administration big wheel))))
(and (job (reasoner louis) (computer programmer trainee)) (unique (job (reasoner louis) (computer programmer trainee))))
(and (job (tweakit lem e) (computer technician)) (unique (job (tweakit lem e) (computer technician))))
(and (job (bitdiddle ben) (computer wizard)) (unique (job (bitdiddle ben) (computer wizard))))

#+END_SRC
*** Exercise 4.76
After some experimenting with this new strategy, we can come up algorithm do the
right things as follows:
1. Assume that we have =unify-frames=, that is,
   - =(unify-frames <frame1> <frame2>)= ::
     takes two frames and produces output frame that contains all the variables
     in both frames with unified value if the frames are compatible with each
     other otherwise symbol ='failed=.
2. Takes two input streams which produced by each conjunct in =and=, then for
   each frame (say =<frame1>=) in the first argument stream, for each frame (say
   =<frame2>=) in the second argument, stream produce =(unify-frames <frame1>
   <frame2>)=.
3. So far we just dealt with binary operation; we can implement n-ary conjoin
   operation using induction on =n= based with above binary operation.


Here is the codes for the =unify-frames=:
#+BEGIN_SRC scheme
(define (unify-frames frame1 frame2)
  (unify-bindings (frame->binding-list frame1) frame2))

(define (unify-bindings bindings frame)
  (cond ((eq? frame 'failed) 'failed)
        ((null? bindings) frame)
        (else
         (unify-bindings
          (cdr bindings)
          (let ((binding (car bindings)))
            (extend-if-possible (binding-variable binding)
                                (binding-value binding)
                                frame))))))

;; ADT for frame, tranforming the type
;; Frame -> List<Binding>
(define (frame->binding-list frame) frame)
#+END_SRC

And following is the code for doing the second specification:
#+BEGIN_SRC scheme
;; Frame -> (Query, Query -> Stream<Frame>)
(define (conjoin-from-frame frame)
  (lambda (conjunct1 conjunct2)
    (stream-filter
     (lambda (frame)
       (not (eq? frame 'failed)))
     (stream-append-map
      (lambda (frame1)
        (stream-map
         (lambda (frame2)
           (unify-frames frame1 frame2))
         (qeval conjunct2 (singleton-stream frame))))
      (qeval conjunct1 (singleton-stream frame))))))
#+END_SRC

Then the code for third one:
#+BEGIN_SRC scheme
;; Frame -> (Conjuncts -> Stream<Frame>)
(define (conjoin-from-frame frame)
  (define (conjoiner conjuncts)
    (if (empty-conjunction? (rest-conjuncts conjuncts))
        (first-conjunct conjuncts)
        (stream-filter
         (lambda (frame)
           (not (eq? frame 'failed)))
         (stream-append-map
          (lambda (frame1)
            (stream-map
             (lambda (frame2)
               (unify-frames frame1 frame2))
             (conjoiner (rest-conjuncts conjuncts))))
          (qeval (first-conjunct conjuncts)
                 (singleton-stream frame))))))
  (lambda (conjuncts)
    (if (empty-conjunction? conjuncts)
        (singleton-stream frame)
        (conjoiner conjuncts))))
#+END_SRC
It uses the algorithm that is analogous to binary operation.

Or iterative process:
#+BEGIN_SRC scheme
(define (conjoin-from-frame frame)
  (define (conjoiner conjuncts conjoined)
    (if (empty-conjunction? conjuncts)
        conjoined
        (conjoiner
         (rest-conjuncts conjuncts)
         (stream-filter
          (lambda (frame)
            (not (eq? frame 'failed)))
          (stream-append-map
           (lambda (frame1)
             (stream-map
              (lambda (frame2)
                (unify-frames frame1 frame2))
              conjoined))
           (qeval (first-conjunct conjuncts)
                  (singleton-stream frame)))))))
  (lambda (conjuncts)
    (if (empty-conjunction? conjuncts)
        (singleton-stream frame)
        (conjoiner (rest-conjuncts conjuncts)
                   (qeval (first-conjunct conjuncts)
                          (singleton-stream frame))))))
#+END_SRC

Then the entry point becomes
#+BEGIN_SRC scheme
(define (conjoin conjuncts frame-stream)
  (stream-flatmap
   (lambda (frame)
     ((conjoin-from-frame frame) conjuncts))
   frame-stream))
#+END_SRC


Then let's test:
#+BEGIN_SRC scheme
;;; Query input:
(and (supervisor ?x ?boss) (supervisor ?y ?x) (supervisor ?z ?y))

;;; Query results:
(and (supervisor (bitdiddle ben) (warbucks oliver)) (supervisor (hacker alyssa p) (bitdiddle ben)) (supervisor (reasoner louis) (hacker alyssa p)))

;;; Query input:
(and (wheel ?who) (job ?who ?j))

;;; Query results:
(and (wheel (warbucks oliver)) (job (warbucks oliver) (administration big wheel)))
(and (wheel (warbucks oliver)) (job (warbucks oliver) (administration big wheel)))
(and (wheel (warbucks oliver)) (job (warbucks oliver) (administration big wheel)))
(and (wheel (warbucks oliver)) (job (warbucks oliver) (administration big wheel)))
(and (wheel (bitdiddle ben)) (job (bitdiddle ben) (computer wizard)))

#+END_SRC

It works on "simple" compound queries; however not work on the recursive rule
application:
#+BEGIN_SRC scheme
;;; Query input:
(outranked-by ?x (Bitdiddle Ben))

;;; Query results:
(outranked-by (tweakit lem e) (bitdiddle ben))  C-c C-c
;Quit!
#+END_SRC

Or even not work on seemingly quite simple compound query:
#+BEGIN_SRC scheme
;;; Query input:
(grandson ?g ?gs)

;;; Query results:  C-c C-c
;Quit!
#+END_SRC

Actually this malfunction is due to (hidden) recursive rule:
#+BEGIN_SRC scheme
(assert! (rule (son ?m ?s)
       (and (wife ?m ?w) (son ?w ?s))))
#+END_SRC

Without this rule definition, our =conjoin= works as expected:
#+BEGIN_SRC scheme
;;; Query input:
(grandson ?x ?y)

;;; Query results:
(grandson mehujael lamech)
(grandson irad methushael)
(grandson enoch mehujael)
(grandson cain irad)
(grandson adam enoch)
#+END_SRC

Even fails in this simple query:
#+BEGIN_SRC scheme
;;; Query input:
(lives-near (Bitdiddle Ben) ?who)

;;; Query results:

#+END_SRC

Now let's think about the cases where our new =conjoin= fails to halt. The
commonalities among them are
- it involve recursive rule application in addition to =and= in their body;
- if we change the order of conjuncts with the original =cojoin=, it will fail
  to halt also.


Actually the latter condition is crucial; thinking about why we failed in the
latter condition even with the original one, we can notice that the
"malfunction" is not due to our "ill-defined" procedure but its own limitation:
We have meant to evaluate the conjuncts at the same time from the same frame,
/and then/ check their compatibility.

So, the rules fail in our new =conjoin= if those would fail with our original
one why not works if we change their order.

It implies that we need the original =conjoin= even with this new =conjoin= but
in a different syntax or explicit syntax --  =andthen=. The order of clauses are
matter in original =conjoin= but the name of syntax of that does not implies
that or even confuse us to think it would work independently with the order of
its clauses. Now our new =conjoin= works independently with the order as the
name, =and=, implies; but we can embody the idea we have implemented with
original =conjoin= so far.

So let us rename original =conjoin= as =conjoin-in-order= and the syntax as
=andthen=:
#+BEGIN_SRC scheme
(define (conjoin-in-order conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin-in-order (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))

,*** in initialize-data-base
  (put 'andthen 'qeval conjoin-in-order)
#+END_SRC

Then let's test with:
#+BEGIN_SRC scheme
,*** microshaft-data-base
(rule (lives-near ?person-1 ?person-2)
      (andthen (and (address ?person-1 (?town . ?rest-1))
                    (address ?person-2 (?town . ?rest-2)))
               (not (same ?person-1 ?person-2))))

(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (andthen (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
#+END_SRC

Now =lives-near= works:
#+BEGIN_SRC scheme
;;; Query input:
(lives-near ?who ?neighbor)

;;; Query results:
(lives-near (reasoner louis) (aull dewitt))
(lives-near (aull dewitt) (reasoner louis))
(lives-near (bitdiddle ben) (aull dewitt))
(lives-near (aull dewitt) (bitdiddle ben))
(lives-near (bitdiddle ben) (reasoner louis))
(lives-near (hacker alyssa p) (fect cy d))
(lives-near (reasoner louis) (bitdiddle ben))
(lives-near (fect cy d) (hacker alyssa p))

#+END_SRC
And also recursive rule:
#+BEGIN_SRC scheme
;;; Query input:
(outranked-by ?who (Bitdiddle Ben))

;;; Query results:
(outranked-by (tweakit lem e) (bitdiddle ben))
(outranked-by (reasoner louis) (bitdiddle ben))
(outranked-by (fect cy d) (bitdiddle ben))
(outranked-by (hacker alyssa p) (bitdiddle ben))

#+END_SRC
*** Exercise 4.77
We need to change the representation of frame. So far we used alist as our
frame. Since we used ADT for frame, we can easily change the representation
without dramatical change of code.

Then we need to specify what features our frame should have. As we are going to
support the "promise" to filter /this/ frame if the condition satisfied; also we
should have to support that if and only if some prior condition, let we call
this as /trigger/ condition, is satisfied the /promised/ filter operation being
tried.

These specification is quite familiar with us; it indicates /event-driven/
programming, that is, to check whether given object's the condition has changed
and it satisfy specified /trigger/ condition, call the stored procedures or in
other terms take an /action/.

So our frame should work as /wire/ in the digital simulator language or
/connector/ is constraint based arithmetic language in section 3.

So our frame has to store /callback list/ to be called whenever some program
extend the given frame; /callback/ function should return either frame of symbol
=failed=. We can implement the filtering function by let the /callback/ function
return =failed= whenever the given condition is satisfied.

Also whenever we add new /callback/ function to our frame we should call given
function with respect to current given frame since it may already have satisfied
the /trigger/ condition.

And it may necessary to make our /callback/ work one time only; that is whenever
it once triggered, it should not be called anymore since our frame structure
does not mutate existing bindings.

So as summary to the /callback/ function, it should meet following format:
1. It should specify the /trigger/ condition which take frame as argument.
2. It should specify the /action/ procedure which take frame and return frame or
   symbol =failed=.


For the frame,
1. It should store /callback/ function list to activate whenever it extended.
2. In that activating process, it should remove the callback function from the
   callback list after calling its action procedure whenever its /trigger/
   condition meets.


Now we can rebuild the ADT of frame as follows:
- Constructors
  - =empty-frame= :: empty frame structure.
  - =(make-frame <bindings> <callbacks>)= :: return frame structure with
    =<bindings>= and =<callbacks>= as its part.
- Selectors
  - =(bindings <frame>)= :: returns binding list of given =<frame>=.
  - =(callbacks <frame>)= :: returns callback list of given =<frame>=.
- Operations
  - =(binding-in-frame <variable> <frame>)= :: returns /binding/ in the =<frame>= that
    has =<variable>= as its variable part.

  - =(extend <variable> <value> <frame>)= :: returns extended frame with the given
    =<variable>= =<value>= binding or symbol =failed=.

    It call =activate-callbacks= with respect to the extended frame and return its
    result.
  - =(add-callback <callback> <frame>)= :: returns frame with extended callback
    list or symbol =failed=.

    It activate given =<callback>= with respect to given =<frame>= then if the
    =<callback>='s trigger condition doesn't meet return the extended frame or
    return the result of =<callback>='s action application with respect to
    =<frame>=.


Then the ADT for callback function:
- Constructors
  - =(make-callback <trigger> <action>)= :: returns callback function with given
    =<trigger>= function and =<action>= function.
- Selectors
  - =(trigger <callback>)= :: returns trigger function of given =<callback>=.
  - =(action <callback>)= :: returns action function of given =<callback>=.


Then here is the code implementing above specifications with auxiliary
procedures:
#+BEGIN_SRC scheme
;;;; Frame ADT
(define (binding-in-frame variable frame)
  (assoc variable (bindings frame)))

(define (extend variable value frame)
  (activate-callbacks
   (make-frame (cons (make-binding variable value) (bindings frame))
               (callbacks frame))))

;; Callback -> Frame | failed
(define (add-callback callback frame)
  (if ((trigger callback) frame)
      ((action callback) frame)
      (make-frame (bindings frame)
                  (cons-callback
                   callback (callbacks frame)))))

;; Frame -> Frame | failed
(define (activate-callbacks frame)
  ;; Callback-list, Callback-list, Frame -> Frame | failed
  (define (loop wait-callbacks activateds frame)
    (cond ((eq? frame 'failed) 'failed)
          ((empty-callbacks? wait-callbacks)
           (make-frame (bindings frame)
                       activateds))
          (else
           (let ((callback (first-callback wait-callbacks))
                 (rests (rest-callbacks wait-callbacks)))
             (if ((trigger callback) frame)
                 (loop rests
                       activateds
                       ((action callback) frame))
                 (loop rests
                       (cons-callback callback activateds)
                       frame))))))
  (loop (callbacks frame) empty-callbacks frame))

;; Frame -> List<Binding>
(define (bindings frame)
  (car frame))

;; Frame -> Callback-list
(define (callbacks frame)
  (cadr frame))

;; List<Binding>, Callback-list -> Frame
(define (make-frame bindings callbacks)
  (list bindings callbacks))

(define empty-frame
  (make-frame empty-bindings empty-callbacks))

;;;; Callback list ADT
(define empty-callbacks '())
(define empty-callbacks? null?)
(define rest-callbacks cdr)
(define first-callback car)
(define cons-callback cons)

;;;; Callback ADT
;; Trigger := Frame -> boolean
;; Action := Frame -> Frame | failed
;; Trigger, Action -> Callback
(define (make-callback trigger-op action-op)
  (list trigger-op action-op))

;; Callback -> Trigger
(define (trigger callback)
  (car callback))

;; Callback -> Action
(define (action callback)
  (cadr callback))

#+END_SRC

Then we are going to design procedure that would be cinch to defining trigger
operation:
- =(has-constant? <variable> <frame>)= :: returns true if the given =<variable>=
  has constant value in =<frame>= otherwise false.
- =(has-constants? <variable list> <frame>)= :: take as input the list of
  variable and return true only if all the variables in the given list
  =has-constant?= in the given =<frame>=.
- =(extract-vars <pattern>)= :: extract list of variables in the given =<pattern>=.
 
  In usual case, =<pattern>= is query.


Here is the codes of above specifications:
#+BEGIN_SRC scheme
;; Variable, Frame -> boolean
(define (has-constant? val frame)
  (cond ((var? val)
         (let ((binding (binding-in-frame val frame)))
           (if binding
               (has-constant? val frame)
               false)))
        ((pair? val)
         (and (has-constant? (car val) frame)
              (has-constant? (cdr val) frame)))
        (else
         ;; constant
         true)))

;; List<Variable>, Frame -> boolean
(define (has-constants? vars frame)
  (if (null? vars) true
      (and (has-constant? (car vars) frame)
           (has-constants? (cdr vars) frame))))

(define (extract-vars pattern)
  ;; Pattern, List<Variable> -> List<Variable>
  (define (tree-walk exp extracteds)
    (cond ((var? exp)
           (cons exp extracteds))
          ((pair? exp)
           (tree-walk (cdr exp)
                      (tree-walk (car exp)
                                 extracteds)))
          (else extracteds)))
  (tree-walk pattern '()))

#+END_SRC

Then the =negate= becomes
#+BEGIN_SRC scheme
(define (negate operands frame-stream)
  (define callback
    (let ((vars (extract-vars (negated-query operands))))
      (make-callback
       (lambda (frame)
         (has-constants? vars frame))
       (lambda (frame)
         (if (stream-null? (qeval (negated-query operands)
                                  (singleton-stream frame)))
             frame
             'failed)))))
  (stream-filter
   (lambda (frame)
     (not (eq? frame 'failed)))
   (stream-map
    (lambda (frame)
      (add-callback callback frame))
    frame-stream)))
#+END_SRC

Similarly =lisp-value=:
#+BEGIN_SRC scheme
(define (lisp-value call frame-stream)
  (define callback
    (let ((vars (extract-vars call)))
      (make-callback
       (lambda (frame)
         (has-constants? vars frame))
       (lambda (frame)
         (if (execute
              (instantiate
               call
               frame
               (lambda (v f)
                 (error "Unknown pat var -- LISP-VALUE" v))))
             frame
             'failed)))))
  (stream-filter
   (lambda (frame)
     (not (eq? frame 'failed)))
   (stream-map
    (lambda (frame)
      (add-callback callback frame))
    frame-stream)))
#+END_SRC

We need to modify =unify-frames= to combine the callbacks of both frame:
#+BEGIN_SRC scheme
(define (unify-frames frame1 frame2)
  (unify-bindings
   (frame->binding-list frame1)
   (fold-left                           ;add all the callbacks of frame1 to frame2
    (lambda (frame callback)
      (if (eq? frame 'failed)
          'failed                       ;propagate failed
          (add-callback callback frame)))
    frame2
    (callbacks frame1))))
#+END_SRC

Let's test!
#+BEGIN_SRC scheme
;;; Query input:
(not (job (Bitdiddle Ben) (computer)))

;;; Query results:
(not (job (bitdiddle ben) (computer)))

;;; Query input:
(not (job (Bitdiddle Ben) (computer wizard)))

;;; Query results:

;;; Query input:
(lisp-value < 1 2)

;;; Query results:
(lisp-value < 1 2)

;;; Query input:
(lives-near ?person ?neighbor)

;;; Query results:  C-c C-c
;Quit!

#+END_SRC

It works for the simple compound query but not the recursive one; run forever.

This is time for debug. Here we are going to use binary search method with
=display=:
#+BEGIN_SRC scheme
(define (negate operands frame-stream)
  (define callback
    (let ((vars (extract-vars (negated-query operands))))
      (make-callback
       (lambda (frame)
         (newline)
         (display "Variables:\t")
         (display vars)
         (display "\tin frame \t:")
         (display frame)
         (has-constants? vars frame))
       (lambda (frame)
         (newline)
         (display "action procedure")
         (if (stream-null? (qeval (negated-query operands)
                                  (singleton-stream frame)))
             frame
             'failed)))))
  (stream-filter
   (lambda (frame)
     (not (eq? frame 'failed)))
   (stream-map
    (lambda (frame)
      (add-callback callback frame))
    frame-stream)))
#+END_SRC

Then query:
#+BEGIN_SRC scheme
;;; Query input:
(lives-near ?person ?neighbor)

;;; Query results:
Variables:	((? 25 person-2) (? 25 person-1))	in frame 	:((((? 25 person-2) aull dewitt) ((? 25 rest-2) (onion square) 5) ((? 25 rest-1) (onion square) 5) ((? 25 town) . slumerville) ((? 25 person-1) aull dewitt) ((? neighbor) ? 25 person-2) ((? person) ? 25 person-1)) ())  C-c C-c
;Quit!
#+END_SRC

From this test, we can realize our =extract-vars= works as expected; the
/trigger/ function called once but never the /action/ function of =callback=. It
implies our =has-constants?= has problem in it:
#+BEGIN_SRC scheme
(define (has-constant? val frame)
  (cond ((var? val)
         (let ((binding (binding-in-frame val frame)))
           (if binding
               (has-constant?
                ;; val
                (binding-value binding)
                frame)
               false)))
        ((pair? val)
         (and (has-constant? (car val) frame)
              (has-constant? (cdr val) frame)))
        (else
         ;; constant
         true)))
#+END_SRC

We have modified the argument of recursive call from =val= into =(binding-value
binding)=. This was the bug after fixing as above, let's re-run the test:
#+BEGIN_SRC scheme
;;; Query input:
(lives-near ?person ?neighbor)

;;; Query results:
(lives-near (reasoner louis) (aull dewitt))
(lives-near (aull dewitt) (reasoner louis))
(lives-near (bitdiddle ben) (aull dewitt))
(lives-near (aull dewitt) (bitdiddle ben))
(lives-near (bitdiddle ben) (reasoner louis))
(lives-near (hacker alyssa p) (fect cy d))
(lives-near (reasoner louis) (bitdiddle ben))
(lives-near (fect cy d) (hacker alyssa p))

#+END_SRC

Now works as expected.

Do more tests:
#+BEGIN_SRC scheme
;;; Query input:
(assert! (rule (can-be-replaced-by ?p1 ?p2)
               (and (job ?p1 ?job1) (job ?p2 ?job2)
                    (or (same ?job1 ?job2)
                        (can-do-job ?job2 ?job1))
                    (not (same ?p1 ?p2)))))

Assertion added to data base.

;;; Query input:
(can-be-replaced-by (Fect Cy D) ?whom)

;;; Query results:
(can-be-replaced-by (fect cy d) (hacker alyssa p))
(can-be-replaced-by (fect cy d) (bitdiddle ben))

#+END_SRC
works as expected and if we change the order of =not= in the body, it should
works as before:
#+BEGIN_SRC scheme
;;; Query input:
(assert! (rule (can-be-replaced-by ?p1 ?p2)
               (and (not (same ?p1 ?p2)) (job ?p1 ?job1)
                    (job ?p2 ?job2)
                    (or (same ?job1 ?job2)
                        (can-do-job ?job2 ?job1)))))

Assertion added to data base.

;;; Query input:
(can-be-replaced-by (Fect Cy D) ?whom)

;;; Query results:  C-c C-c
;Quit!
#+END_SRC
But it isn't. We can progress with our binary search debug:
#+BEGIN_SRC scheme
,*** in action procedure
(if (stream-null? (qeval (negated-query operands)
                                  (singleton-stream frame)))
             (begin
               (newline)
               (display "frame worked! with result:\t")
               (display frame)
               frame)
             (begin (newline) (display "failed worked!") 'failed))
#+END_SRC

Then the response:
#+BEGIN_SRC scheme
;;; Query input:
(can-be-replaced-by (Fect Cy D) ?whom)

;;; Query results:
Variables:	((? 7395 p2) (? 7395 p1))	in frame 	:((((? whom) ? 7395 p2) ((? 7395 p1) fect cy d)) ())
Variables:	((? 7395 p2) (? 7395 p1))	in frame 	:((((? 7395 job1) computer programmer) ((? whom) ? 7395 p2) ((? 7395 p1) fect cy d)) ((#[compound-procedure 13] #[compound-procedure 14])))
Variables:	((? 7395 p2) (? 7395 p1))	in frame 	:((((? 7395 job2) administration secretary) ((? 7395 job1) computer programmer) ((? whom) ? 7395 p2) ((? 7395 p1) fect cy d)) ((#[compound-procedure 13] #[compound-procedure 14])))
Variables:	((? 7395 p2) (? 7395 p1))	in frame 	:((((? 7395 p2) aull dewitt) ((? 7395 job2) administration secretary) ((? 7395 job1) computer programmer) ((? whom) ? 7395 p2) ((? 7395 p1) fect cy d)) ((#[compound-procedure 13] #[compound-procedure 14])))
action procedure with frame:	((((? 7395 p2) aull dewitt) ((? 7395 job2) administration secretary) ((? 7395 job1) computer programmer) ((? whom) ? 7395 p2) ((? 7395 p1) fect cy d)) ((#[compound-procedure 13] #[compound-procedure 14])))
...
C-c C-c
;Quit!
#+END_SRC

But none of the branches of /action/ procedure have been passed. Now we know
where is the bug: the predicate part of =if=. Let's put more =display= in that
part:
#+BEGIN_SRC scheme
,*** in action procedure
         (if (stream-null?
              (begin
                (newline)
                (display "the negated-query\t")
                (display (negated-query operands))
                (newline)
                (display "With frame:\t")
                (display frame)
                (qeval (negated-query operands)
                       (singleton-stream frame))))
             ...)
#+END_SRC

Then we can run the specific case in manually:
#+BEGIN_SRC scheme

;;; Query input:
(can-be-replaced-by (Fect Cy D) ?whom)

;;; Query results:
the negated-query	(same (? 27833 p1) (? 27833 p2))
With frame:	((((? 27833 p2) aull dewitt) ((? 27833 job2) administration secretary) ((? 27833 job1) computer programmer) ((? whom) ? 27833 p2) ((? 27833 p1) fect cy d)) ((#[compound-procedure 15] #[compound-procedure 16])))
...
#+END_SRC
as
#+BEGIN_SRC scheme
(define query '(same (? 27833 p1) (? 27833 p2)))
(define frame
  `((((? 27833 p2) aull dewitt)
     ((? 27833 job2) administration secretary)
     ((? 27833 job1) computer programmer)
     ((? whom) ? 27833 p2)
     ((? 27833 p1) fect cy d))
    ((,#@15 ,#@16))))
#+END_SRC

Then:
#+BEGIN_SRC scheme
(qeval query (singleton-stream frame))

the negated-query	(same (? 27833 p1) (? 27833 p2))
With frame:	((((? 27873 x) fect cy d) ((? 27833 p2) aull dewitt) ((? 27833 job2) administration secretary) ((? 27833 job1) computer programmer) ((? whom) ? 27833 p2) ((? 27833 p1) fect cy d)) ((#[compound-procedure 15] #[compound-procedure 16])))
the negated-query	(same (? 27833 p1) (? 27833 p2))
...
#+END_SRC

This result is quite complicated mess. Here what we should expect from the above
execution was just
#+BEGIN_SRC scheme
(qeval query (singleton-stream frame))

;Value: ()
#+END_SRC
not calling the callback action recursively, which led into infinite loop.

After some reasoning, we can understand that it is due to the =unify-match=
calling in the =apply-a-rule=, which in turn called when we process the =same=
query above. =Unify-match= calls =extend-if-possible= in processing the body of
it, and it led to call =extend=; that now calls the /action/ procedure with
which all the process started.

To fix this, all we need to do is just remove all the callbacks from the frame
, with which the predicate part of =if= processed, which in turn led all of
these mass.


The followings do what specified above:
#+BEGIN_SRC scheme
(define (remove-callbacks frame)
  (make-frame (bindings frame)
              empty-callbacks))
#+END_SRC

#+BEGIN_SRC scheme
,*** in negate
  (define callback
    (let ((vars (extract-vars (negated-query operands))))
      (make-callback
       (lambda (frame)
         (has-constants? vars frame))
       (lambda (frame)
         (if (stream-null?
              (qeval (negated-query operands)
                     (singleton-stream (remove-callbacks frame))))
             frame
             'failed)))))
#+END_SRC

Now it works:
#+BEGIN_SRC scheme
;;; Query input:
(assert! (rule (can-be-replaced-by ?p1 ?p2)
               (and (not (same ?p1 ?p2)) (job ?p1 ?job1)
                    (job ?p2 ?job2)
                    (or (same ?job1 ?job2)
                        (can-do-job ?job2 ?job1)))))

Assertion added to data base.

;;; Query input:
(can-be-replaced-by (Fect Cy D) ?whom)

;;; Query results:
(can-be-replaced-by (fect cy d) (hacker alyssa p))
(can-be-replaced-by (fect cy d) (bitdiddle ben))

#+END_SRC

Or like this (variation of [[Exercise 4.56][Exercise 4.56]] c.):
#+BEGIN_SRC scheme
;;; Query input:
(and (lisp-value > ?a1 ?a2)
     (can-be-replaced-by ?p1 ?p2) (salary ?p1 ?a1)
     (salary ?p2 ?a2))

;;; Query results:
(and (lisp-value > 150000 25000) (can-be-replaced-by (warbucks oliver) (aull dewitt)) (salary (warbucks oliver) 150000) (salary (aull dewitt) 25000))
(and (lisp-value > 40000 35000) (can-be-replaced-by (hacker alyssa p) (fect cy d)) (salary (hacker alyssa p) 40000) (salary (fect cy d) 35000))

#+END_SRC

With this, our =lives-near= rule has not use =andthen=, just =and=:
#+BEGIN_SRC scheme
(rule (lives-near ?person-1 ?person-2)
      ;; (andthen (and (address ?person-1 (?town . ?rest-1))
      ;;               (address ?person-2 (?town . ?rest-2)))
      ;;          (not (same ?person-1 ?person-2)))
      (and (not (same ?person-1 ?person-2))
           (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))))
#+END_SRC

Then
#+BEGIN_SRC scheme
;;; Query input:
(lives-near ?who ?neighbor)

;;; Query results:
(lives-near (reasoner louis) (aull dewitt))
(lives-near (aull dewitt) (reasoner louis))
(lives-near (bitdiddle ben) (aull dewitt))
(lives-near (aull dewitt) (bitdiddle ben))
(lives-near (bitdiddle ben) (reasoner louis))
(lives-near (hacker alyssa p) (fect cy d))
(lives-near (reasoner louis) (bitdiddle ben))
(lives-near (fect cy d) (hacker alyssa p))

#+END_SRC
*** Exercise 4.78
We need to map from frames as stream representation to frames as time branches.
We don't need to change all of the procedures from the scratch. Actually we can
re-use all of the procedures that is not specific to the stream representation.

So our pattern matcher and unifier works as before in this new scheme. Even for
the stream specific implementation, the mapping is quite straightforward. That
is, where we processed with stream of frames, we are good to map it to just one
frame instance; where we used =the-empty-stream= to abort current frame, we need
to make that frame fail -- call =(amb)=.

The problem is =disjoin=. What is the counterpart of =interleave-delayed= in
=amb= evaluator? We need to reason about the relationship between the input
streams and the output stream; it produce the stream as if it searched the input
streams in breadth first manner. However, as our =amb= evaluator chose
chronological search order -- so called the /depth first search/ -- it cause
quite huge modification from the very scratch to emulate this BFS (Breadth First
Search) in our =amb= evaluator.

So, here we just =ramb= to implement =disjoin= in our situation. The reasons why
we chose this are
1. If we just used =amb= instead of =ramb= to combine =disjuncts=, it would be
   equivalent for stream version to use =stream-append-delayed= in combining them.
2. It is still true that in =amb= evaluator we can not emulate BFS even with
   =ramb=; however we are able to produce all the answers if the user type
   =try-again= enough times in theory. While, if we stick with =amb=, then the
   probabilities it going to happen goes to 0.


So we better off with =ramb= in =disjoin=.

For the =negate=, we need control structure to "try out" the given frame with
the =nagated-query= of given =operands=. As we postulated above,
=the-empty-stream= is equivalent =(amb)= in =amb= evaluator. So what we need
here is to check whether the given evaluation is going to fail, if so, do
something, else do others. This is exactly what =if-fail= does:
#+BEGIN_SRC scheme
(define (negate operands frame)
  (define callback
    (let ((vars (extract-vars (negated-query operands))))
      (make-callback
       (lambda (frame)
         (has-constants? vars frame))
       (lambda (frame)
         (if-fail
          (begin
            (qeval (negated-query operands)
                   (remove-callbacks frame))
            'failed)
          frame)))))
  (filter-failed (add-callback callback frame)))
#+END_SRC
Unfortunately, the above implementation would blindly pass =frame= whether or
not we have given =negated-query= fails or not:
#+BEGIN_SRC scheme
;; Test negate
(define (simulate-negate-action)
  (if-fail
   (begin (amb 1 2 3 4)
          'failed)
   'bilndly-pass-through))
(filter-failed (simulate-negate-action))
#+END_SRC

Then (for the definition of =filter-failed=, please reference the whole code
will appear below):
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(filter-failed (simulate-negate-action))

;;; Starting a new problem
;;; Amb-Eval value:
bilndly-pass-through
#+END_SRC

It is due to mainly our deficiency in the behavior we expect from =negate=. We
need to specify the behavior of =negate= abstractly enough to be implemented in
any programming language framework.

After some reasoning we can deduce abstract behavior of =negate= in =amb=
language:
1. The frame branches of =qeval= part in =negate= should be empty.
2. Need to traverse the time branches caused by =qeval= part then if it success
   ever, then it should signal this fact to the caller of =qeval=.


For the implementation details, we can achieve the second behavior of above
using assignment; however with the same argument as =disjoin=, we can not /fast
escape/ in =amb= language as we did in stream version. That is to abort as soon
as it found that the produced frames are not empty, it quits to evaluate
subsequent frames otherwise it would produced.

The reason behind this fact is that we aren't have any explicit method for
manipulating the time branches =amb= evaluation. We can not teleport the time
point into specific point in the time tree[fn:0]. So we need to traverse all the
time branches produced by
#+BEGIN_SRC scheme
(qeval (negated-query operands)
       (remove-callbacks frame))
#+END_SRC
just to abort. It may produce infinite number of frame branches; in that case,
the evaluation of =negate= would also run forever without returning the control
to the caller.

This is huge difference and unfortunate from the stream version of query
language.

Anyway we can implement this idea as
#+BEGIN_SRC scheme
(define (negate operands frame)
  (define callback
    (let ((vars (extract-vars (negated-query operands))))
      (make-callback
       (lambda (frame)
         (has-constants? vars frame))
       (lambda (frame)
         (let ((succeed? false))
           (if-fail
            (begin (qeval (negated-query operands)
                          (remove-callbacks frame))
                   (permanent-set! succeed? true))
            'ignore)
           (if succeed?
               'failed
               frame))))))
  (filter-failed (add-callback callback frame)))
#+END_SRC

Here we used the combination of =if-fail= and =permanent-set!= as we did [[Exercise 4.53][before]]
to cope with the time branch abortion.

Then (unit) test:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(define (simulate-negate-action-failed)
  (let ((succeed? false))
    (if-fail
     (begin (amb 1 2 3 4)
            (permanent-set! succeed? true))
     'ignore)
    (if succeed? 'failed
        'frame)))

;;; Starting a new problem
;;; Amb-Eval value:
ok

;;; Amb-Eval input:
(define (simulate-negate-action-succeed)
  (let ((succeed? false))
    (if-fail
     (amb)
     'ignore)
    (if succeed? 'failed
        'frame)))

;;; Starting a new problem
;;; Amb-Eval value:
ok

;;; Amb-Eval input:
(filter-failed (simulate-negate-action-failed))

;;; Starting a new problem
;;; There are no more values of
(filter-failed (simulate-negate-action-failed))

;;; Amb-Eval input:
(filter-failed (simulate-negate-action-succeed))

;;; Starting a new problem
;;; Amb-Eval value:
frame

#+END_SRC

Yet another difficulty is =execute=. If we chose ordinary =eval/apply=
interpreter as evaluator for backbone of query language, it is easy to
implement; however in our =amb= evaluator, as the implementation of that
evaluator consisted of =succeed/fail= chains, to reason about this chains to
implement the counterparts of =apply= and =eval=.

Here we also try to capture the behavior we want from =execute=:
- Just extract the expression off the quoted expression and then evaluate that
  with the received =env=, =succeed=, =fail=.


Here is the implementation:
#+BEGIN_SRC scheme
(define (execute? exp) (tagged-list? exp 'execute))
(define (execute-expression exp) (cadr exp))

(define (analyze-execute exp)
  (lambda (env succeed fail)
    ((analyze-quoted (execute-expression exp))
     env
     (lambda (exp2 fail2)
       ((analyze exp2) env
        succeed fail2))
     fail)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(execute '(> 5 4))

;;; Starting a new problem
;;; Amb-Eval value:
#t

#+END_SRC

From this implementation, we got the point that the nondeterministic evaluator
does offer quite restricted freedom to user for the purpose to support the
automatic search.

Rest is quite rather simple task than above ones.

Then test:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(query-driver-loop)

;;; Starting a new problem

;;; Query input:
(lives-near ?who ?neighbor)

;;; Query results:
(lives-near (aull dewitt) (reasoner louis))

;;; Query input:
next-result

;;; Query results:
(lives-near (aull dewitt) (bitdiddle ben))

;;; Query input:
#+END_SRC

=unique= test:
#+BEGIN_SRC scheme
;;; Query input:
(unique (job ?x (computer wizard)))

;;; Query results:
(unique (job (bitdiddle ben) (computer wizard)))

;;; Query input:
(unique (job ?x (computer programmer)))

;;; Query results:
(lives-near (reasoner louis) (bitdiddle ben))

;;; Query input:
#+END_SRC

The last response is quite quirk. We can fix this with =if-fail=:
#+BEGIN_SRC scheme
(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (if (eq? input 'next-result)
        (begin
          (newline)
          (display output-prompt)
          (newline)
          (amb))
        (let ((q (query-syntax-process input)))
          (cond ((assertion-to-be-added? q)
                 (add-rule-or-assertion! (add-assertion-body q))
                 (newline)
                 (display "Assertion added to data base.")
                 (query-driver-loop))
                (else
                 (newline)
                 (display output-prompt)
                 ;; [extra newline at end] (announce-output output-prompt)
                 (newline)
                 (if-fail
                  (display
                   (instantiate q
                                (qeval q empty-frame)
                                (lambda (v f)
                                  (contract-question-mark v))))
                  (begin
                    (display ";;; There are no more result of")
                    (newline)
                    (display
                     (instantiate
                      q empty-frame
                      (lambda (v f)
                        (contract-question-mark v))))))
                 (query-driver-loop)))))))
#+END_SRC

Then
#+BEGIN_SRC scheme
;;; Query input:
(unique (job ?x (computer wizard)))

;;; Query results:
(unique (job (bitdiddle ben) (computer wizard)))

;;; Query input:
next-result

;;; Query results:
;;; There are no more result of
(unique (job ?x (computer wizard)))

;;; Query input:
(unique (job ?x (computer programmer)))

;;; Query results:
;;; There are no more result of
(unique (job ?x (computer programmer)))

;;; Query input:
#+END_SRC

Others also works fine:
#+BEGIN_SRC scheme
;;; Query input:
(outranked-by ?who (Bitdiddle Ben))

;;; Query results:
(outranked-by (tweakit lem e) (bitdiddle ben))

;;; Query input:
next-result

;;; Query results:
(outranked-by (fect cy d) (bitdiddle ben))

;;; Query input:
#+END_SRC

Then as we noted above, the difference of this implementation from the stream
version is the followings:
#+BEGIN_SRC scheme
;;; Query input:
(not (infinite answer))

;;; Query results:
  C-c C-c;Quit!
#+END_SRC

Or the =or= from [[Exercise 4.72][the previous example]]:
#+BEGIN_SRC scheme
;;; Starting a new problem

;;; Query input:
(or (infinite ?x)
    (outranked-by ?who (Bitdiddle Ben)))

;;; Query results:
(or (infinite ?x) (outranked-by (tweakit lem e) (bitdiddle ben)))

;;; Query input:
next-result

;;; Query results:
(or (infinite ?x) (outranked-by (fect cy d) (bitdiddle ben)))
#+END_SRC

And:
#+BEGIN_SRC scheme
;;; Query input:
(or (infinite ?x)
    (outranked-by ?who (Bitdiddle Ben)))

;;; Query results:
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))

;;; Query input:
next-result

;;; Query results:
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))

...

;;; Query input:
next-result

;;; Query results:
(or (infinite answer) (outranked-by ?who (bitdiddle ben)))

#+END_SRC

As noted above.
*** Exercise 4.79
Here we try to change the implementation details from the scratch; that is, we
change our model of evaluation or control system from stream (or branches) of
frames to environment model as we learned in section 3 and implemented the
preceding parts of this section.

To emigrate to environment, first, we need to understand what feature of
environment model we are going to implement and what new aspect we need to add
that we haven't encountered in previous evaluation model.

So we re-learn about the environment model as the text indicates. In the problem
statement, they posted the examples that illustrate the killer feature --
avoiding the name capture. This is one of the most important concept in the
lambda calculus, which is the backbone of all of the computer science theory.

Contrast with which, so far in this query language implementation, we escaped
this name capture problem by issuing the unique name every each time we apply
the rule. Actually we can use this alternative strategy to our meta circular
evaluator which used environment model instead in that time.

The "issuing" unique variable name is quite simple and clever idea especially in
this query language since the query itself can (and usually do) have variable,
which yet unbound in that time. If the variable failed to be bound as the result
of query, this specific implementation detail helps a lot or make sense the
representation of this fact.

Think about the =(last-pair <list> <last-pair>)= query with the =<list>= part
unbound. As we seen from ex [[Exercise 4.62][4.62]], it unfolds all possible answers using the
unbound variable and using "different" variable representation. It make sense
since in our language, same variable name indicates has to be bound with same
value. But in that example, all of the variable do not need to be bound at same
value. In other cases, where the result unbound variables should be bound at
same value when it be bound, our current implementation deals with those without
any problem also.

Exactly this is the difference between our previous evaluation situation from
current query language implementation. Can our new implementation deals with
this problem without any confusing? Or should we implement this behavior? That
is, to inform the user those are possibly different variables even it bound
using same rule. Or is it good enough to be consistent with those concept
internally, i.e. in machine information.

Previously, we did not concern with those concept or need not be bothered by
those since our evaluation or computation progress in unidirectional way: When
we apply given procedure, the argument should be bound with some constant value.
So if we hand over the values of given arguments to the procedure, we are free
from worrying about the environment where the evaluation made; The environment
part of procedure to be applied would be used afterward evaluation.

One way to deal with the unbound variables in procedural style is to make
unbound object whenever we encounter with those; and hand over those to
subsequent rule application arguments. And those objects would be bound
afterward evaluations (or queries). This is similar strategy we took in
constraint based arithmetic language in section 3.
* Footnotes

[fn:0] If we could have that ability, we
can implement BFS. But it would cause chaos into the evaluator.
