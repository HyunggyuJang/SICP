#+TITLE: Metalinguistic Abstraction
/Metalinguistic Abstraction/ -- establishing new languages -- plays an important
role in all branches of engineering design. It is particularly important to
computer programming, because in programming /not only can we formulate new
languages but we can also implement these languages by constructing evaluators/.

* The Metacircular Evaluator
** The Core of the Evaluator
In this section we use the syntax operations (the representation for the syntax
of language being implemented) to implement the =eval= and =apply= process. Our
evaluator uses several ADTs each for syntax for language being implemented and the
internal representations for internal evaluation model -- environment.
*** Exercise 4.1
We can force the order by using =let= statement -- since it is just syntactic
sugar for lambda application, the value of each bindings of =let= expression
evaluated before evaluating the body of it.
#+BEGIN_SRC scheme
;;; Left to Right
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((first (eval (first-operand exps) env)))
        (cons first
              (list-of-values (rest-operands exps) env)))))
;;; Right to Left
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((rest (list-of-values (rest-operands exps) env)))
        (cons (eval (first-operand exps) env)
              rest))))
#+END_SRC
** Representing Expressions
It is reminiscent of the symbolic differentiation program discussed in section
2.3.2; each expression has its own type tag in it, so our evaluator dispatch on
this type and recursively evaluate the nested expression.
*** Exercise 4.2
**** a.
It will deal the assignment expression as if it is procedure application since
procedure application expression doesn't have any type for specifying it so any
the pairs not sifted by the =cond= clauses before that clause treated as
procedure application. So =(define x 3)= are treated procedure application and,
in turn, evaluator lookup the =define= variable; since it couldn't find any it
will signal error -- undefined variable.
**** b.
Here is the fix:
#+BEGIN_SRC scheme
(define (application? exp) (tagged-list? exp 'call))
#+END_SRC
*** Exercise 4.3
We can rely on the data-directed style only for the tagged expressions:
#+BEGIN_SRC scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        (else
         (let ((op (and (tagged-exp? exp)
                        (get 'eval (type-tag exp)))))
           (cond (op (op exp env))
                 ((application? exp)
                  (apply (eval (operator exp) env)
                         (list-of-values (operands exp) env)))
                 (else
                  (error "Unknown expression type -- EVAL" exp)))))))
#+END_SRC

The procedures of =tagged-exp= ADT:
#+BEGIN_SRC scheme
(define (type-tag exp)
  (car exp))
(define (tagged-exp? exp)
  (pair? exp))
#+END_SRC

Then install the contents:
#+BEGIN_SRC scheme
(define (install-eval-clauses)
  (put 'eval 'quote (lambda (exp env) (text-of-quotation exp)))
  (put 'eval 'set! eval-assignment)
  (put 'eval 'define eval-definition)
  (put 'eval 'if eval-if)
  (put 'eval 'lambda (lambda (exp env)
                       (make-procedure (lambda-parameters exp)
                                       (lambda-body exp)
                                       env)))
  (put 'eval 'begin (lambda (exp env)
                      (eval-sequence (begin-actions exp) env)))
  (put 'eval 'cond (lambda (exp env)
                     (eval (cond->if exp) env)))
  'done)
#+END_SRC

I've implemented the type tags directly for simplicity.
*** Exercise 4.4
**** As special expression
#+BEGIN_SRC scheme
(define (install-eval-and-or-direct)
  ;; and eval
  (define (eval-and exp env)
    (eval-and-subs (subexps exp) env))
  (define (eval-and-subs subs env)
    (cond ((null? subs) (eval 'true env))
          ((last-sub? subs) (eval (first subs) env))
          (else
           (if (true? (eval (first-sub subs) env))
               (eval-and-subs (rest-subs subs) env)
               (eval 'false env)))))

  ;; or eval
  (define (eval-or exp env)
    (eval-or-subs (subexps exp) env))
  (define (eval-or-subs subs env)
    (cond ((null? subs) (eval 'false env))
          ((last-sub? subs) (eval (first subs) env))
          (else
           (let ((current
                  (eval (first-sub subs) env)))
             (if (false? current)
                 (eval-or-subs (rest-subs subs) env)
                 current)))))

  ;; selector on And or Or expression
  (define (subexps exp) (cdr exp))
  ;; sub ADT
  (define (last-sub? subs)
    (and (pair? subs) (null? (cdr subs))))
  (define first-sub car)
  (define rest-subs cdr)

  ;; interface with eval procedure
  (put 'eval 'and eval-and)
  (put 'eval 'or eval-or)
  'done)
#+END_SRC

Here we used data-directed style =eval= from [[Exercise 4.3][ex 4.3]].

Then setup for test:
#+BEGIN_SRC scheme
(define eval-table (make-hash-table))
(define (put op type item)
  (if (eq? op 'eval)
      (hash-table-set! eval-table type item)
      (error "Unallowed operation -- PUT" op)))
(define (get op type)
  (if (eq? op 'eval)
      (hash-table-ref eval-table type (lambda () #f))
      (error "Unknown operation -- GET" op)))
#+END_SRC

Let's run!
#+BEGIN_SRC scheme
1 ]=> (install-eval-clauses)

;Value: done

1 ]=> (install-eval-and-or-direct)

;Value: done

1 ]=> (driver-loop)

;;; M-Eval input:
(and)

;;; M-Eval value:
#t

;;; M-Eval input:
(and 5)

;;; M-Eval value:
5

;;; M-Eval input:
(and false)

;;; M-Eval value:
#f

;;; M-Eval input:
(and false 5 2)

;;; M-Eval value:
#f

;;; M-Eval input:
(and 5 2)

;;; M-Eval value:
2

;;; M-Eval input:
(and 5 false)

;;; M-Eval value:
#f

;;; M-Eval input:
(or)

;;; M-Eval value:
#f

;;; M-Eval input:
(or 5)

;;; M-Eval value:
5

;;; M-Eval input:
(or false 5 false flase)

;;; M-Eval value:
5

;;; M-Eval input:
(or false 5 false)

;;; M-Eval value:
5

;;; M-Eval input:
(or false false 5)

;;; M-Eval value:
5

#+END_SRC

Or we could test this in unit:
#+BEGIN_SRC scheme
(install-eval-clauses)

;Value: done

(install-eval-and-or-direct)

;Value: done

(eval '(and 5) the-global-environment)

;Value: 5

(eval '(and false 5) the-global-environment)

;Value: #f

(eval '(or 5 false) the-global-environment)

;Value: 5
#+END_SRC
**** As derived expression
This is analogous to =cond=:
#+BEGIN_SRC scheme
define (install-eval-and-or-derived)
  (define (expand-or-subs subs)
    (cond ((null? subs) 'false)
          ((null? (cdr subs)) (car subs))
          (else
           (let ((first (car subs)))
             (make-let
              (list (list 'first first))
              (list (make-if 'first
                        'first
                        (expand-or-subs (cdr subs)))))))))
  (define (expand-and-subs subs)
    (cond ((null? subs) 'true)
          ((null? (cdr subs)) (car subs))
          (else
           (make-if (car subs)
                    (expand-and-subs (cdr subs))
                    'false))))

  (define (and->if exp)
    (expand-and-subs (cdr exp)))

  (define (or->if exp)
    (expand-or-subs (cdr exp)))

  (put 'eval 'and (lambda (exp env)
                    (eval (and->if exp) env)))
  (put 'eval 'or (lambda (exp env)
                   (eval (or->if exp) env)))
  'done)
#+END_SRC
For =or=, we used =make-let= to reuse the result of evaluation of first
subexpression in case where it turns out true.

Here is =make-let= syntax procedure that is analogous to =make-lambda=
#+BEGIN_SRC scheme
;; List<binding>, List<expression> -> Let
(define (make-let bindings body)
  (cons 'let (cons bindings body)))
#+END_SRC

Then test!
#+BEGIN_SRC scheme
(install-eval-and-or-derived)

;Value: done

(eval '(and 5) the-global-environment)

;Value: 5

(eval '(and false 5) the-global-environment)

;Value: #f

(eval '(and true 2 true) the-global-environment)

;Value: #t
#+END_SRC

For the =or= part, we delegate the test until we implement the =let= expression
in our evaluator ([[Exercise 4.6][ex 4.6]])
*** Exercise 4.5
We can support this new feature through either special form or derived form. The
key issue is that is it okay re-evaluate the =<test>= expression twice?
- If it is okay, the only change that we should make is the =sequence->exp= part
  of =expand-clauses= into
  #+BEGIN_SRC scheme
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (cond-actions->exp first)
                     (expand-clauses rest))))))

(define (cond-actions->exp clause)
  (let ((actions (cond-actions clause)))
    (if (eq? (car actions) '=>)
        (if (and (pair? (cdr actions))
                 (null? (cddr actions)))
            (list (cadr actions) (cond-predicate clause))
            (error "Illformed expression -- COND-MAP" clause))
        (sequence->exp actions))))
  #+END_SRC

  Then test:
  #+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr)
                         (else false)) the-global-environment)

;Value: 4

(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Illformed expression -- COND-MAP ((cons 3 4) => cdr 3)
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
  #+END_SRC
- If it is not, in other word, we are constrained to evaluate the =cond-predicate=
  only once, we do use =make-let= as we did in the previous exercise.
  #+BEGIN_SRC scheme
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          ; no else clause
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last -- COND->IF"
                       clauses))
            (let ((pred (cond-predicate first)))
              (make-let
               (list (list 'pred pred))
               (list (make-if 'pred
                              (map-or-sequence->exp
                               (cond-actions first) 'pred)
                              (expand-clauses rest)))))))))

(define (map-or-sequence->exp actions pred)
  (if (eq? (car actions) '=>)
      (if (and (pair? (cdr actions))
               (null? (cddr actions)))
          (list (cadr actions) pred)
          (error "Illformed expression -- COND-MAP" clause))
      (sequence->exp actions)))
  #+END_SRC
*** Exercise 4.6
#+BEGIN_SRC scheme
(define (install-eval-let)
  (define (let->combination exp)
    (let* ((bindings (bindings exp))
           (unziped-b
            (fold-right
             (lambda (var-exp vars-exps)
               (cons (cons (car var-exp) (car vars-exps))
                     (cons (cadr var-exp) (cdr vars-exps))))
             (cons '() '())
             bindings))
           (params (car unziped-b))
           (exps (cdr unziped-b)))
      (cons (make-lambda params (body exp))
            exps)))

  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let (lambda (exp env)
                    (eval (let->combination exp) env)))
  'done)
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(eval '(let ((x 1)) (cons x 2)) the-global-environment)

;Value: (1 . 2)

(eval '(let ((x 1)) (cons x 2) (cons 2 x)) the-global-environment)

;Value: (2 . 1)
#+END_SRC

Then now we can test the =or= of derived version:
#+BEGIN_SRC scheme
(install-eval-and-or-derived)

;Value: done

(eval '(or 5 false) the-global-environment)

;Value: 5

(eval '(or false 5 false) the-global-environment)

;Value: 5
#+END_SRC

And derived =cond='s new feature:
#+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr)
                         (else false)) the-global-environment)

;Value: 4

(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Unbound variable: clause
#+END_SRC
By test it we found the bug in our previous error handling. It is easy to fix.
After fixing,
#+BEGIN_SRC scheme
(eval '(cond ((cons 3 4) => cdr 3)
                         (else false)) the-global-environment)

;Illformed expression -- COND-MAP (=> cdr 3)
#+END_SRC
It works as expected.
*** Exercise 4.7
#+BEGIN_SRC scheme
(define (install-eval-let*)
  (define (let*->let exp)
    (define (expand-let* bindings)
      (if (null? bindings)
          (body exp)
          (let ((first (car bindings))
                (rest (cdr bindings)))
            (make-let
             (list first)
             ((if (null? rest)
                  identity-procedure
                  list) ;for the type contraction of make-let
              (expand-let* rest))))))
    (expand-let* (bindings exp)))
  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let* (lambda (exp env)
                     (eval (let*->let exp) env)))
  'done)
#+END_SRC
It suffices to define =let*= as derived expression since subsequent derived
expression reduced to non-derived expression by =eval= and =apply= loop, which
in turn reduced to primitive expressions.

Then test:
#+BEGIN_SRC scheme
(install-eval-let*)

;Value: done

(eval
 '(let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))
 the-global-environment)

;Value: 39
#+END_SRC
*** Exercise 4.8
First let we code the test:
#+BEGIN_SRC scheme
(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)
;; ok
(eval
 '(fib 3)
 the-global-environment)
;; 1
#+END_SRC

And note that by using the environment model, we can deduce named let expression
=(let <var> <bindings> <body>)= is equivalent to
#+BEGIN_SRC scheme
(let ((<var> undef))
  (set! <var>
    (lambda <params of bindings> body))
  (apply <var> <exps of bindings>))
#+END_SRC

So we convert named let expression above equivalent expression.

Here is the result:
#+BEGIN_SRC scheme
(define (install-eval-let-with-named)
  ;; ADT for named
  (define (named? exp)
    (and (pair? exp)
         (pair? (cdr exp))
         (symbol? (cadr exp))))

  (define (named exp)
    (cadr exp))

  (define (except-name-let exp)
    (cdr exp))

  (define (let->combination exp)
    (let* ((bindings (bindings exp))
           (unziped-b
            (fold-right
             (lambda (var-exp vars-exps)
               (cons (cons (car var-exp) (car vars-exps))
                     (cons (cadr var-exp) (cdr vars-exps))))
             (cons '() '())
             bindings))
           (params (car unziped-b))
           (exps (cdr unziped-b)))
      (cons (make-lambda params (body exp))
            exps)))

  (define (named->let-combination exp)
    (let ((var (named exp))
          (comb (let->combination
                 (except-name-let exp))))
      (let ((lambda-part (car comb))
            (exps (cdr comb)))
        (make-let
         (list (list var (list 'quote undef)))
         (list
          (make-assignment var
                           lambda-part)
          (cons var
                exps))))))

  (define bindings cadr)
  (define body cddr)
  (put 'eval 'let (lambda (exp env)
                    (eval (if (named? exp)
                              (named->let-combination exp)
                              (let->combination exp)) env)))
  'done)
#+END_SRC

And the auxiliary parts:
#+BEGIN_SRC scheme
(define undef '*unassigned*)
(define (make-assignment var val)
  (list 'set! var val))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
(install-eval-let-with-named)

;Value: done

(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)

;Value: ok

(eval
 '(fib 3)
 the-global-environment)

;Unbound variable =
#+END_SRC

Huh, we should set ~=~ (and also =-=) as primitive procedure in our environment.
Do that and re-run:
#+BEGIN_SRC scheme
(install-eval-clauses)

;Value: done

(install-eval-let-with-named)

;Value: done

(eval
 '(define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
 the-global-environment)

;Value: ok

(eval
 '(fib 3)
 the-global-environment)

;Value: 2

(eval
 '(fib 2)
 the-global-environment)

;Value: 1
#+END_SRC

Oh-huh there are good news and bad news:
- Our test code was wrong! =(fib 3)= should return 2 not 1 as it count from 0!
- Our code works right!

*** Exercise 4.9
For example, here we try to implement typical imperative control structure,
=while=. Let us think about the what syntax should it be? Analogous to any other
imperative programming language, let we make our syntax as follows:
#+BEGIN_SRC scheme
(while <pred>
  <exp1>
  ...
  <expN>)
#+END_SRC

The semantic of this control structure are followings:
1. Evaluate =<pred>= first.
2. If it true, execute from =<exp1>= until =<expN>= sequentially; Then go to *1.*
3. If it was false, then return the control to consequent structure (return
   undefined value).


All of the above expressions should be evaluated in a same environment; we don't
need to extend the given environment.

Then here is the code:
#+BEGIN_SRC scheme
(define (install-eval-while)
  (define pred cadr)
  (define body cddr)
  (define (eval-while exp env)
    (let ((bexp (sequence->exp (body exp))))
      (let loop ()
        (if (true? (eval (pred exp) env))
            (begin (eval bexp env)
                   (loop))
            'done))))
  (put 'eval 'while eval-while)
  'done)
#+END_SRC

Then here is the test code:
#+BEGIN_SRC scheme
(eval '(begin
         (define x 5)
         (define sum 0)
         (while (> x 0)
           (set! sum (+ x sum))
           (set! x (-1+ x)))
         sum)
      the-global-environment)
;Should return 15
#+END_SRC

And run:
#+BEGIN_SRC scheme
(eval '(begin
         (define x 5)
         (define sum 0)
         (while (> x 0)
           (set! sum (+ x sum))
           (set! x (-1+ x)))
         sum)
      the-global-environment)

;Value: 15
#+END_SRC

Sweet!
*** Exercise 4.10
Here we will use dispatch on type rather than data-directed style since we are
going to mix the infix expressions with prefix expressions. Specifically we will
transform the assignment notation and that of definition into infix notation:
- From =(set! <var> <exp>)= to =(<var> <- <exp>)=;
- From =(define <var> <exp>)= to =(<var> = <exp>)=.


All we need to change is the detectors and selectors:
- From
  #+BEGIN_SRC scheme
;; detector
(define (assignment? exp)
  (tagged-list? exp 'set!))

;; selectors
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
  #+END_SRC
  to
  #+BEGIN_SRC scheme
;; detector
(define (assignment? exp)
  (infix-tag-list? exp '<-))

;; selectors
(define (assignment-variable exp) (car exp))
(define (assignment-value exp) (caddr exp))
  #+END_SRC
- From
  #+BEGIN_SRC scheme
;; detector
(define (definition? exp)
  (tagged-list? exp 'define))

;; selectors
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))
  #+END_SRC
  to
  #+BEGIN_SRC scheme
;; detector
(define (definition? exp)
  (infix-tag-list? exp '=))

;; selectors
(define (definition-variable exp)
  (if (symbol? (car exp))
      (car exp)
      (caar exp)))
(define (definition-value exp)
  (if (symbol? (car exp))
      (caddr exp)
      (make-lambda (cdar exp)
                   (cddr exp))))
  #+END_SRC


Then the test code:
#+BEGIN_SRC scheme
;; Test infix defintion
(eval '(begin (x = 2)
              x)
      the-global-environment)
;; 2
;; procedure definition
(eval
 '((factorial n) = (if (= n 1)
                       1
                       (* n (factorial (-1+ n)))))
 the-global-environment)
;; ok
(eval '(factorial 3) the-global-environment)
;; 6


;; test infix assignment
(eval '(begin (x <- 5)
              x)
      the-global-environment)
;; 5
#+END_SRC

Then let's run
#+BEGIN_SRC scheme
(eval '(begin (x = 2)
              x)
      the-global-environment)

;Value: 2

(eval
 '((factorial n) = (if (= n 1)
                       1
                       (* n (factorial (-1+ n)))))
 the-global-environment)

;Value: ok

(eval '(factorial 3) the-global-environment)

;Value: 6

(eval '(begin (x <- 5)
              x)
      the-global-environment)

;Value: 5
#+END_SRC
** Evaluator Data Structures
*** Exercise 4.11
This is same as replace our frame data structure with table as we did in section
3.3. Then the changes are trivial:
#+BEGIN_SRC scheme
;; For extend-environment
(define (make-frame vars vals)
  (let ((bindings
         ;; provided that the length of both arguments match
         (fold-right
          (lambda (var val bindings)
            (cons (list var val) bindings))
          '()
          vars
          vals))
        (tbl (make-table)))
    (set-bindings! tbl bindings)
    tbl))

;; Table ADT
;; constructor
(define (make-table)
  (list '*table*))
;; mutator
(define set-bindings! set-cdr!)
;; selector
(define bindings cdr)

;; For lookup-variable-value
(define (lookup-variable-value var env)
  (let env-loop ((env env))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (cond ((assoc var (bindings frame)) => cadr)
                (else (env-loop
                       (enclosing-environment env))))))))

;; For set-variable-value!
(define (set-variable-value! var val env)
  (let env-loop ((env env))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (cond ((assoc var (bindings frame))
                 => (lambda (b) (set-car! (cdr b) val)))
                (else (env-loop
                       (enclosing-environment env))))))))

;; For define-variable!
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (cond ((assoc var (bindings frame))
                 => (lambda (b) (set-car! (cdr b) val)))
          (else (set-bindings! frame
                               (cons (list var val)
                                     (bindings frame)))))))
#+END_SRC

By using the built in procedures about the alist structure, we could write our
procedures more succinctly; this leads that we recognize the common patterns in
above procedures more obviously, which we revisit in the next exercise.

Return to our discourse, let we code the test:
#+BEGIN_SRC scheme
;; test definition
(eval '(define test-def 0) the-global-environment)
;; ok

;; test assignment in nested frame
(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)
;; ok

(eval 'test-def the-global-environment)
;; 0

(eval '(test-assignment) the-global-environment)
;; ok

;; test lookup-variable-value
(eval 'test-def the-global-environment)
;; 5

;; verify that we using the new data structure for frame
(caar the-global-environment)
;; *table*
#+END_SRC

Then run:
#+BEGIN_SRC scheme
(eval '(define test-def 0) the-global-environment)

;Value: ok

(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 0

(eval '(test-assignment) the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 5

(caar the-global-environment)

;Value: *table*
#+END_SRC
*** Exercise 4.12
We can capture the common pattern first by recognizing the same code in those
code and then refine them with their role of behavior, namely traversing given
frame and traversing given environment:
#+BEGIN_SRC scheme
;; Var, (Vals -> Any) -> FrameOp
(define (find-var-and-apply-in-frame var vals-op)
  (lambda (null-op frame)
    (let scan ((vars (frame-variables frame))
               (vals (frame-values frame)))
      (cond ((null? vars)
             (null-op))
            ((eq? var (car vars))
             (vals-op vals))
            (else (scan (cdr vars) (cdr vals)))))))

;; FrameOp, void -> Any, Env
;; -> Any
(define (traverse-env-using frame-op empty-env-op env)
  (if (eq? env the-empty-environment)
      (empty-env-op)
      (frame-op (first-frame env)
                (lambda () (traverse-env-using frame-op empty-env-op
                                               (enclosing-environment env))))))
#+END_SRC
Here we, for interfacing the traverser on environment with traverser on frame,
defined new data type, namely =FrameOp= -- ~FrameOp := Frame, NullOp -> Any~,
~NullOp := void -> Any~.

Then our operations on environments get
#+BEGIN_SRC scheme
(define (lookup-variable-value var env)
  (traverse-env-using
   (find-var-and-apply-in-frame var car)
   (lambda () (error "Unbound variable" var))
   env))

(define (set-variable-value! var val env)
  (traverse-env-using
   (find-var-and-apply-in-frame
    var
    (lambda (vals) (set-car! vals val)))
   (lambda () (error "Unbound variable -- SET!" var))
   env))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    ((find-var-and-apply-in-frame
      var
      (lambda (vals) (set-car! vals val)))
     (lambda ()
       (add-binding-to-frame! var val frame))
     frame)))
#+END_SRC

Then test using the test code of previous exercise:
#+BEGIN_SRC scheme
...
(eval 'test-def the-global-environment)

;The object #[compound-procedure 38], passed as the first argument to cdr, is not the correct type.
;To continue, call RESTART with an option number:
; (RESTART 2) => Specify an argument to use in its place.
; (RESTART 1) => Return to read-eval-print level 1.

2 error> (pp #@38)
(lambda ()
  (traverse-env-using frame-op empty-env-op (enclosing-environment env)))
;Unspecified return value
#+END_SRC

Got error! It is due to the ill-ordered argument in =traverse-env-using=. After
fixing that we got:
#+BEGIN_SRC scheme
(eval '(define test-def 0) the-global-environment)

;Value: ok

(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 0

(eval '(test-assignment) the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 5
#+END_SRC

Our code got more cleaner and easier for us to read.
*** Exercise 4.13
As we can think of this new special form as counter expression against =define=,
let we make =make-unbound!= remove only the binding in the first frame of the
environment. To implement this feature, that is to remove specific binding in the
frame, we need to do nearly what we did in =remove-first-item= in agenda data
structure. So, we would not reuse the abstract procedure of previous exercise,
=find-var-and-apply-in-frame=; but the resulting procedure would be nearly same
as that.

To encompass this pattern, we extend =find-var-and-apply-in-frame= with:
#+BEGIN_SRC scheme
(define (find-var-and-apply-to-bindings var find-op bindings-op)
  (lambda (null-op frame)
    (let scan ((vars (frame-variables frame))
               (vals (frame-values frame)))
      (cond ((null? vars)
             (null-op))
            ((eq? var (find-op vars))
             (bindings-op vars vals))
            (else (scan (cdr vars) (cdr vals)))))))
#+END_SRC

Then we can define
#+BEGIN_SRC scheme
(define (find-var-and-apply-in-frame var vals-op)
  (find-var-and-apply-to-bindings
   var car (lambda (vars vals) (vals-op vals))))
#+END_SRC

Or it would better to refine our frame data structure by making the
=frame-variables= and =frame-values= to be headed list respectively to encompass
=make-unbound!= in our scheme uniformly.

As we defined our frame data structure abstractly, all we need to change is the
representation of frame:
#+BEGIN_SRC scheme
;; Change the representation of frame
(define (make-frame variables values)
  (cons (cons '*variables* variables)
        (cons '*values* values)))

(define (frame-variables frame) (cdar frame))
(define (frame-values (cddr frame)))
#+END_SRC

Then we exploit this idea by amending the =find-var-and-apply-to-bindings=
allowing even the selectors and detector for frame:
#+BEGIN_SRC scheme
(define (find-var-and-apply-to-bindings
         var find-op bindings-op frame-vars frame-vals empty-vars?)
  (lambda (null-op frame)
    (let scan ((vars (frame-vars frame))
               (vals (frame-vals frame)))
      (cond ((empty-vars? vars)
             (null-op))
            ((eq? var (find-op vars))
             (bindings-op vars vals))
            (else (scan (cdr vars) (cdr vals)))))))

(define (find-var-and-apply-in-frame var vals-op)
  (find-var-and-apply-to-bindings
   var car (lambda (vars vals) (vals-op vals))
   frame-variables frame-values null?))
#+END_SRC

Then we can define what we wanted:
#+BEGIN_SRC scheme
(define (unbound-variable! var val env)
  (let ((frame (first-frame env)))
    ((find-var-and-apply-to-bindings
      var cadr
      (lambda (h-vars h-vals)
        (set-cdr! h-vars (cddr h-vars))
        (set-cdr! h-vals (cddr h-vals)))
      car cdr (lambda (h-vars) (null? (cdr h-vars))))
     (lambda ()
       (error "Unbound variable in the given frame -- MAKE-UNBOUND!" var))
     frame)))

(define (install-eval-make-unbound)
  (define var cadr)
  (define val caddr)
  (put 'eval 'make-unbound!
       (lambda (exp env)
         (unbound-variable! (var exp)
                            (val exp)
                            env))))
#+END_SRC

Then let we first test the new frame data structure:
#+BEGIN_SRC scheme
(eval '(test-assignment) the-global-environment)

;Unbound variable test-assignment
#+END_SRC
Error! This is due to the =add-binding-to-frame!= as we did not updated that
procedure, which is mutator of frame structure!

Then refine the data structure for frame:
#+BEGIN_SRC scheme
;; Change the representation of frame
(define (make-frame variables values)
  (cons (cons '*variables* variables)
        (cons '*values* values)))

;; selectors for frame
(define (frame-variables frame) (cdar frame))
(define (frame-values frame) (cddr frame))

;; mutators of frame
(define (add-binding-to-frame! var val frame)
  (set-cdr! (car frame) (cons var (frame-variables frame)))
  (set-cdr! (cdr frame) (cons val (frame-values frame))))

(define (remove-binding-from-frame! var frame exception)
  ((find-var-and-apply-to-bindings
      var cadr
      (lambda (h-vars h-vals)
        (set-cdr! h-vars (cddr h-vars))
        (set-cdr! h-vals (cddr h-vals)))
      car cdr (lambda (h-vars) (null? (cdr h-vars))))
     exception
     frame))
#+END_SRC

Then our procedure get clarified as
#+BEGIN_SRC scheme
(define (unbound-variable! var env)
  (remove-binding-from-frame!
   var
   (first-frame env)
   (lambda ()
     (error "Unbound variable in the given frame -- MAKE-UNBOUND!" var))))
#+END_SRC

Re-run our test code:
#+BEGIN_SRC scheme
(eval '(define test-def 0) the-global-environment)

;Value: ok

(eval '(define (test-assignment) (set! test-def 5))
      the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 0

(eval '(test-assignment) the-global-environment)

;Value: ok

(eval 'test-def the-global-environment)

;Value: 5

(eval '(make-unbound! test-def) the-global-environment)

;ok

(eval '(make-unbound! test-def) the-global-environment)

;Unbound variable in the given frame -- MAKE-UNBOUND! test-def
#+END_SRC

Works sweetly!
** Running the Evaluator as a Program
*** Exercise 4.14
1. It is because our evaluator uses data abstraction for decouple the semantics
   from syntaxes of language.
2. Combined with the *1.*, it is due to the difference of how evaluator treats
   application of compound procedure from that of primitive procedure.
3. =Map= needs to apply evaluated procedure to the each element of given list;
   but the value of that procedure is wrapped around by type-tag and it handled
   underlying Scheme's evaluator which don't know how to handle our type-tagged data.
4. So namely, it is not the procedure, which handed over to =map=, in
   implementation language but in language being implemented.
** Data as Programs
*** Exercise 4.15
We can prove this by case analysis with /reductio ad absurdum/:
- =(try try)= \to ='halted=:
  By definition of =try=, it implies that =(halts? try try)= evaluated as
  =false=. Which in turn means =(try try)= raises error or run forever by the
  definition of =halts?=; this is contradiction with our assumption -- =(try
  try)= returns ='halted=, which means it halted.
- =(try try)= \to /run forever/ or /raise error/:
  With the same argument from the previous one, it leads to contradiction with
  assumption in any case -- whether it evaluated as /run forever/ or /raise error/.
** Internal Definitions
*** Exercise 4.16
**** a.
#+BEGIN_SRC scheme
(define (lookup-variable-value var env)
  (traverse-env-using
   (find-var-and-apply-in-frame
    var
    (lambda (vals)
      (let ((val (car vals)))
        (if (eq? val undef)
            (error "Unassigned variable" var)
            val))))
   (lambda () (error "Unbound variable" var))
   env))
#+END_SRC
**** b.
I've designed in the text book with my digital paper:
#+BEGIN_SRC scheme
(define (scan-out-defines proc-body)
  (let ((extrated-exps
         ;; List<Exp> (proc-body) -> List<Exp> x List<Exp>
         ;; We implement this a little bit complicate procedure since
         ;; we want to examine possible user error --
         ;; defenstive programming.
         (fold-right
          (lambda (exp extracted)
            (if (definition? exp)
                (cons (cons exp (car extracted)) (cdr extracted))
                (if (null? (car extracted))
                    (cons (car extracted) (cons exp (cdr extracted)))
                    ;; intertwined internal definitions with others
                    (error "Internal defintions intertwins with others" proc-body))))
          (cons '() '())
          proc-body)))
    (let ((internal-defs (car extrated-exps))
          (rest-body (cdr extrated-exps)))
      (let ((vars (map definition-variable internal-defs))
            (exps (map definition-value internal-defs)))
        (let ((bindings
               (map (lambda (var) (list var (list 'quote undef)))
                    vars))
              (set-exps
               (map (lambda (var val)
                      (make-assignment var val))
                    vars
                    exps)))
          (make-let bindings (append set-exps rest-body)))))))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
;; test for scan-out-defines
(scan-out-defines
 '((define u <e1>)
   (define v <e2>)
   <e3>))
;; should return
(let ((u '*unassigned*)
      (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
#+END_SRC

Then the results:
#+BEGIN_SRC scheme
(pretty-print (scan-out-defines
               '((define u <e1>)
                 (define v <e2>)
                 <e3>)))
(let ((u '*unassigned*) (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
;Unspecified return value
#+END_SRC
as expected.
**** c.
The construction time is better. Note that it is analogous to the choice we made
when we comes with rational number arithmetic package. Since procedure is
"captured common computational process," it is supposed to be applied more than
defining ones; so by make =scan-out-defines= run in the construction time, we'll
get more efficient implementation dynamically.

Then here is the code:
#+BEGIN_SRC scheme
(define (make-procedure parameters body env)
  (list 'procedure parameters
        (scan-out-defines body)
        env))
#+END_SRC
*** Exercise 4.17
I've drawn the required diagram with my digital paper.

For the second question, first we need to recognize what the correct program is;
as jotted in the text book, correct program means what program obeyed the
described restriction -- the defined variables' values can be evaluated without
using any of variables' values. Then we can answer given question: Variables
that can be looked up in evaluating =<e3>= is same in both environment
structure; as an evaluation of any statement can not inspect the environment
directly, the behavior of both should equals among both. More formally, we can
prove the argument using the structure induction on eval/apply; that is,
evaluation of statement achieved by eval/apply, so we need to prove if all the
behavior of the program before the transformation are same, then after that
transformation the evaluation result of each clause should results in same as
before the transformation.

Lastly, we can fix this different environment structure by transforming the
internal definitions into
- Define the variables of them with =*unassigned*= then =set!= the value by
  corresponding expressions afterward, which would do not make any extra frame
  and also satisfy all the specifications described above.
- Note that this fixation does not involve any ill-defined procedure, that is
  the infinite loop where calls itself again and again.


The code:
#+BEGIN_SRC scheme
(define (scan-out-defines2 proc-body)
  (let ((extrated-exps
         ;; List<Exp> (proc-body) -> List<Exp> x List<Exp>
         ;; We implement this a little bit complicate procedure since
         ;; we want to examine possible user error --
         ;; defenstive programming.
         (fold-right
          (lambda (exp extracted)
            (if (definition? exp)
                (cons (cons exp (car extracted)) (cdr extracted))
                (if (null? (car extracted))
                    (cons (car extracted) (cons exp (cdr extracted)))
                    ;; intertwined internal definitions with others
                    (error "Internal defintions intertwines with others" proc-body))))
          (cons '() '())
          proc-body)))
    (let ((internal-defs (car extrated-exps))
          (rest-body (cdr extrated-exps)))
      (let ((vars (map definition-variable internal-defs))
            (exps (map definition-value internal-defs)))
        (let ((def-vars
               (map (lambda (var) (make-definition var (list 'quote undef)))
                    vars))
              (set-exps
               (map (lambda (var val)
                      (make-assignment var val))
                    vars
                    exps)))
          (append def-vars (append set-exps rest-body)))))))

(define (make-definition var val)
  (list 'define var val))
#+END_SRC


Then test again:
#+BEGIN_SRC scheme
(pretty-print (scan-out-defines2
               '((define u <e1>)
                 (define v <e2>)
                 <e3>)))
((define u '*unassigned*) (define v '*unassigned*) (set! u <e1>) (set! v <e2>) <e3>)
#+END_SRC
*** Exercise 4.18
This new version would not work; whereas the version in the text works. We can
reason this as follows:
#+BEGIN_SRC scheme
(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt)) ;does not evaluate dy until it need
  ;; ↑ in this block structure it never needed.
  (define dy (stream-map f y))          ;does evaluate y
  y)
#+END_SRC
1. As noted above annotation, the value expression of =dy= involves =y= and need
   to evaluate that to return the value.
2. Since in this transformation strategy does not change all the occurrence of
   =u= and =v= into =a= and =b= respectively in the =<e1>= and =<e2>= as it
   assume the restriction is obeyed, when it comes to evaluate =y= it lookup and
   signal error as it found =*unassigned*=.
3. This malfunction is due to the modification of the name of definition without
   changing all the expressions that depend on the name of internal definitions
   as we noted above.
*** Exercise 4.19
1. I myself couldn't yet be convinced by why we need to treat internal
   definitions especially; so I support Ben's view since it make me (and
   possibly other people too) easy to understand the behavior of internal
   definition in consistent manner.

   However it is trickier than it seems since the difference between procedure
   and other data. And because of the limitation of text editor environment: We
   are forced to write code in sequential manner; so it forces us to think as if
   we are dealing with sequential events. But it isn't as we discuss below.

   The above discussion is not consistent with that of mutual recursive
   procedures -- it works as if the defines evaluated simultaneously. So in
   theory Eva's view point is the most consistent one.

2. For the second question; yes, we can but it should be implemented in a error
   handling manner: If we got into unassigned value error, then try to delegate
   the execution of that assignment statement (to stack another place and try
   each of them when we reach the end of assignment statement; if there are no
   reduction in stack after one-loop finally it should raise an error -- give
   up!). This algorithm is expensive since it recursively reduces the stacked
   statements until there is no change.
*** Exercise 4.20
**** a.
Here we implement the strategy written in text book. That is, to transform from
#+BEGIN_SRC scheme
(letrec ((u <e1>)
         (v <e2>))
  <e3>)
#+END_SRC
to
#+BEGIN_SRC scheme
(let ((u '*unassigned*)
      (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
#+END_SRC

So we can code the test code using above example:
#+BEGIN_SRC scheme
(pretty-print (letrec->let-assignment
               (letrec ((u <e1>)
                        (v <e2>))
                 <e3>)))
(let ((u '*unassigned*)
      (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
;Unspecified return value
#+END_SRC

Then code:
#+BEGIN_SRC scheme
(define (install-eval-letrec)
  (define bindings cadr)                ;((u <e1>) (v <e2>))
  (define body cddr)                    ;<e3>
  (define (letrec->let-assignment exp)
    (let ((binds (bindings exp))
          (rest-body (body exp)))
      (let ((vars (map car binds))
            (exps (map cadr binds)))
        (make-let
         (map (lambda (var) (list var (list 'quote undef)))
              vars)
         (append
          (map (lambda (var exp) (make-assignment var exp))
               vars exps)
          rest-body)))))
  (put 'eval 'letrec
       (lambda (exp env)
         (eval (letrec->let-assignment exp) env)))
  ;; test
  (letrec->let-assignment
   '(letrec ((u <e1>)
             (v <e2>))
      <e3>)))
#+END_SRC

And test!
#+BEGIN_SRC scheme
(pretty-print (install-eval-letrec))
(let ((u '*unassigned*) (v '*unassigned*))
  (set! u <e1>)
  (set! v <e2>)
  <e3>)
;Unspecified return value
#+END_SRC
**** b.
Solely let, we cannot express recursive process within the body of procedure.
I've drawn the environment diagram reasoning about this assertion.
*** Exercise 4.21
**** a.
#+BEGIN_SRC scheme
((lambda (n)
   ((lambda (fact)
      (fact fact n))
    (lambda (ft k)
      (if (= k 1)
          1
          (* k (ft ft (- k 1)))))))
 10)

;Value: 3628800
#+END_SRC
It works well. By using this technique -- specifically the lambda calculus by
Alonzo Church -- we can reason our program's behavior using, back to our old
friend, substitution model.

Fibonacci number can be calculated by using this strategy:
#+BEGIN_SRC scheme
((lambda (n)
   ((lambda (fibo)
      (fibo fibo n))
    (lambda (fib k)
      (if (< k 2)
          k
          (+ (fib fib (- k 1))
             (fib fib (- k 2)))))))
 4)

;Value: 3
#+END_SRC

The common pattern in above procedures is that the inner procedure, which do all
the serious process, take additional parameter. We can think of this parameter
as /self/ reference; as soon as we calculate the type contract of this /self/
parameter, we realize this is same as that type of the procedure of discourse.
**** b.
#+BEGIN_SRC scheme
(define (f x)
  ((lambda (even? odd?)
     (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? ev? od? (-1+ n))))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? ev? od? (-1+ n))))))
#+END_SRC

then test:
#+BEGIN_SRC scheme
(f 5)

;Value: #f

(f 4)

;Value: #t
#+END_SRC
** Separating Syntactic Analysis from Execution
*** Exercise 4.22
We can get what we want by mapping the expression part to =let->combination= to
=analyze-application=. First let we make our analyzer to be data-directed
style, which is analogous to [[Exercise 4.3][ex 4.3]]:
#+BEGIN_SRC scheme
(define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((variable? exp) (analyze-variable exp))
        (else
         (let ((op (and (tagged-exp? exp)
                        (get 'analyze (type-tag exp)))))
           (cond (op (op exp))
                 ((application? exp)
                  (analyze-application exp))
                 (else
                  (error "Unknown expression type -- ANALYZE" exp)))))))
#+END_SRC

Then extend our =eval= /ad-hoc/ table into more general 2 dimensional
hash-table:
#+BEGIN_SRC scheme
(define operation-table (make-hash-table))
(define (put op type item)
  (let ((type-table (hash-table-ref operation-table op (lambda () #f))))
    (if type-table
        (hash-table-set! type-table type item)
        (let ((type-table (make-hash-table)))
          (hash-table-set! type-table type item)
          (hash-table-set! operation-table op type-table)))))
(define (get op type)
  (let ((type-table
         (hash-table-ref operation-table op (lambda () #f))))
    (and type-table
         (hash-table-ref type-table type (lambda () #f)))))
#+END_SRC

And then
#+BEGIN_SRC scheme
(define (install-analyze-clauses)
  (put 'analyze 'quote analyze-quoted)
  (put 'analyze 'set! analyze-assignment)
  (put 'analyze 'define analyze-definition)
  (put 'analyze 'if analyze-if)
  (put 'analyze 'lambda analyze-lambda)
  (put 'analyze 'begin (lambda (exp) (analyze-sequence (begin-actions exp))))
  (put 'analyze 'cond (lambda (exp) (analyze (cond->if exp))))
  'done)
#+END_SRC

Finally we can return our original task:
#+BEGIN_SRC scheme
(define (install-analyze-let)
  (define let->combination
    (cadr (assq 'let->combination (install-eval-let))))
  (put 'analyze 'let (lambda (exp) (analyze-application (let->combination exp)))))
#+END_SRC

To make available the =let->combination= procedure, which is defined in
=install-eval-let=, I've made following change to the end of =install-eval-let=:
#+BEGIN_SRC scheme
,*** the last line of install-eval-let
  `((let->combination ,let->combination))
#+END_SRC

That is, the alist of procedures, which we want to export. And you may find
[[https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Quoting.html][Scheme manual about quasi-quote]] useful.
*** Exercise 4.23
The procedure of Alyssa's version start to link all the sequence expressions
into one analyzed expression in execution time; whereas the version of text do
link the sequence in the analysis time. As consequence, the number of steps it
needs when it executed are quite different among both. I've wrote the sample
execute in my digital paper using the substitution model since the execution
does not involve any side effect (the side effect of executed statement does not
affect the behavior of this level of abstraction).
*** Exercise 4.24
**** Compare Execution Time
Here we compare the time it needs to execute application of test procedure. For
the test procedure we use procedure which calculate Fibonacci number using multi
recursive process (since it is expensive, we can measure the time more
apparently).

The definition of test procedure:
#+BEGIN_SRC scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
#+END_SRC

And we can extract /only/ the execution of application not the definition by
using =eval=, namely
#+BEGIN_SRC scheme
(eval '(fib 33) the-global-environment)
#+END_SRC

Then we can time it needs to execute whole of this process the variation from
project 3:
#+BEGIN_SRC scheme
(define (timed proc)
  (let ((start (runtime)))
    (let ((val (proc)))
      (newline)
      (display "time expended: ")
      (display (- (runtime) start))
      val)))
#+END_SRC

Then we can use this as
#+BEGIN_SRC scheme
(timed (lambda () (eval '(fib 33) the-global-environment)))
#+END_SRC

As we designed the experiments, now let's run those:
#+BEGIN_SRC scheme
;;; Analysis
(install-analyze-clauses)
(eval
 '(define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1))
                   (fib (- n 2))))))
 the-global-environment)
(timed (lambda () (eval '(fib 20) the-global-environment)))

time expended: 1.6300000000000026
;Value: 6765
#+END_SRC

Turns out =(fib 33)= way more expensive to wait.

Then without analysis version:
#+BEGIN_SRC scheme
(install-eval-clauses)
(eval
 '(define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1))
                   (fib (- n 2))))))
 the-global-environment)
(timed (lambda () (eval '(fib 20) the-global-environment)))

time expended: 3.21
;Value: 6765
#+END_SRC

With analysis, we halved the time it takes. Quite impressive isn't it?

For curiosity, let we run also the primitive evaluator of our Scheme!
#+BEGIN_SRC scheme
(define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 1))
                   (fib (- n 2))))))

;Value: fib

(timed (lambda () (fib 20)))

time expended: .02999999999999936
;Value: 6765
#+END_SRC

Huge difference!
**** Compare the time spent by analysis versus by execution
Here is the previous =fib= procedure's:
#+BEGIN_SRC scheme
(timed
 (lambda ()
   (repeat 1000 (lambda ()
                  (eval '(fib 2)
                        the-global-environment)))))

time expended: .20000000000000018
;Value: done
#+END_SRC

And that of simple execution:
#+BEGIN_SRC scheme
(timed
 (lambda ()
   (repeat 1000 (lambda ()
                  (eval '(fib 1)
                        the-global-environment)))))

time expended: .07000000000000028
;Value: done
#+END_SRC

Or simple recursive execution:
#+BEGIN_SRC scheme
(timed
 (lambda ()
   (repeat 1000 (lambda ()
                  (eval '(fib 2)
                        the-global-environment)))))

time expended: .20000000000000018
;Value: done
#+END_SRC

Here we used =repeat= to measure the time otherwise unable to estimate:
#+BEGIN_SRC scheme
(define (repeat n proc)
  (let loop ((k n))
    (if (> k 0)
        (begin (proc)
               (loop (-1+ k)))
        'done)))
#+END_SRC

Or let us test the sequential statements:
#+BEGIN_SRC scheme
;; Or those of sequential statements
(define test-sequential
  '(define (test-sequential)
     (define x 0)
     (set! x (1+ x))
     (set! x (1+ x))
     (set! x (1+ x))
     (set! x (1+ x))
     (set! x (1+ x))
     x))
;; analysis time
(timed (lambda () (repeat 1000 (lambda () (analyze test-sequential)))))

time expended: .08999999999999986
;Value: done

;; execution time
(eval test-sequential the-global-environment)
(timed (lambda ()
         (repeat 1000 (lambda ()
                        (eval '(test-sequential) the-global-environment)))))

time expended: .17000000000000015
;Value: done
#+END_SRC
* Variations on a Scheme -- Lazy Evaluation
** Normal Order and Applicative Order
*** Exercise 4.25
It will falls into infinite loop since what ever argument we hand over, it
should call itself with different argument to pass the =unless= procedure as
parameter -- as our underlying Scheme evaluate in applicative order, evaluator
first evaluate the operands of application of compound procedure and then apply.

And yes, our procedure will work in normal-order language since in normal-order
language, expressions only got evaluated when the expression is operation in
application or the operation part unwound into primitive procedure.

If we apply above discussion into our =factorial= application, it unwound into
application of =unless=, which in turn got into =if= expression that is special
form; by the rule of =if= evaluation, now the predicate part evaluated and
depending on that value, in turn, whether consequent part of alternative part
got evaluated and so on.
*** Exercise 4.26
Here is the =unless= as derived form:
#+BEGIN_SRC scheme
(define (unless->if exp)
  (make-if (unless-pred exp)
           (unless-alter exp)
           (unless-conseq exp)))
(define unless-pred cadr)
(define unless-conseq caddr)
(define unless-alter cadddr)
#+END_SRC

Let us think the discussion using more simple example -- not =unless= itself --
the =and= or =or= special form. It has the ability to be used as "short circuit" the
code. I couldn't count the number of times if I had =or= as non-special form so
that I can code up with higher order function like =fold-right=.

Back to the original question, we can think about the possibilities if we
allowed to use =unless= with combination of stream processing frame work. By
using that combination, we could code event driven system in functional
programming style as we use the =unless= to control the input stream.

Well, in any case, if we allowed to use =unless= not as special form, we can
pass that as argument of another higher order procedures; or as the value of
application.
** An Interpreter with Lazy Evaluation
*** Exercise 4.27
The first =<response>= should be 1 and that of second =<response>= and third
would be 10 and 2 respectively since
1. The value expression of =w= is evaluated by =eval-definition= but as it's
   application of compound procedure, it will evaluate the body of given
   compound procedure with *delayed* arguments.
2. Since the first statement of the body is special form with application of
   primitive procedure, it will change the value of count from 0 to 1.
3. The last statement of that is variable, it will lookup in the extended
   environment and return the *delayed* value, that is the promise to evaluate
   =(id 10)= in that environment.


Here is the verification:
#+BEGIN_SRC scheme
;;; L-Eval input:
(define count 0)

;;; L-Eval value:
ok

;;; L-Eval input:
(define (id x)
  (set! count (+ count 1))
  x)

;;; L-Eval value:
ok

;;; L-Eval input:
(define w (id (id 10)))

;;; L-Eval value:
ok

;;; L-Eval input:
count

;;; L-Eval value:
1

;;; L-Eval input:
w

;;; L-Eval value:
10

;;; L-Eval input:
count

;;; L-Eval value:
2

#+END_SRC
*** Exercise 4.28
The example should be the case where the evaluated value is thunk and then it
used as operator in combination.

Generally, we need this extra complexity for dealing with the case where the
expression is itself result of combination of applying compound procedure where
it participate as argument.

We can deduce this using the previous exercise as example. Observe that in the
previous exercise that the arguments in the application (of compound procedure)
are made thunk by =list-of-delayed-args=. By using this observation, we can make
the situation where satisfy the property outlined above:
#+BEGIN_SRC scheme
(((lambda (x) x) +) 2 4)
#+END_SRC

Then verification:
#+BEGIN_SRC scheme
(thunk? (eval '((lambda (x) x) +) the-global-environment))

;Value: #t
#+END_SRC

So we need the =actual-value= to get the value, which in turn applied to given
operands:
#+BEGIN_SRC scheme
(thunk? (actual-value '((lambda (x) x) +) the-global-environment))

;Value: #f
#+END_SRC
*** Exercise 4.29
The good example of such program should exhibit the situation where some object
evaluated more than once; so
#+BEGIN_SRC scheme
(factorial (factorial 20))
#+END_SRC
would make huge difference between with memoization and without that.

And for the second question, we can reason about this as follows:
- For with memoization:
  1. Evaluate =(square (id 10))=, which in turn
  2. extend the environment with binding =x: (thunk (id 10) env)=
     and evaluate =(* x1 x2)= (here we used =x1= and =x2= instead =x= since
     we need to take the time when we accessed to that variable since
     memoization introduce assignment implicitly);
  3. force x_{1}, which in turn evaluate =(id 10)=; it leads to set =count= to
     be 1 and in the environment set =x= to be evaluated thunk with value 10;
  4. force x_{2}, which already evaluated by force x_{1}, so it just return 10;
  5. returned to =(* x1 x2)=, as now the values are obtained, it return 100 as
     final value.
- For without memoization:
  1. Evaluate =(square (id 10))=, which in turn
  2. extend the environment with binding =x: (thunk (id 10) env)=
     and evaluate =(* x1 x2)=;
  3. force x_{1}, which in turn evaluate =(id 10)=; it leads to set =count= to
     be 1;
  4. force x_{2}, which in turn evaluate =(id 10)=; it leads to set =count= to
     be 2;
  5. returned to =(* x1 x2)=, as now the values are obtained, it return 100 as
     final value.


So the first response is same in both as 100; the second are 1, 2 in with
memoization and without that respectively.
*** Exercise 4.30
**** a.
Since
- as this is application of compound procedure;
- it evaluate the body of =for-each= with delayed arguments;
- in turn, =if-predicate= force items to be actual value;
- by the first statement of =begin= of =for-each= is application so =proc= got
  forced;
- it leads the body of =proc= evaluated with thunked =(car items)= -- 57 in this
  example;
- as all of the statement of =proc= is application of primitive procedures the
  argument, =x=, is forced and evaluated -- 57 is displayed at this moment;
- now another =for-each= is evaluated same as above since all the conditions are
  same for applying the above argument.


By above argument all the statements in the sequence got forced.
**** b.
As we noted in [[Exercise 4.28][ex 4.28]], the thunked expression is not evaluated as value without
forcing it -- by =actual-value= --, in turn, user can thunk the expression only
via application of compound procedure.

So by applying this observation to the given Cy's examples with original
=eval-sequence=, we got =(p1 1)= \to =(1 2)= and =(p2 1)= \to 1; since while the
first does not involve any application of compound procedure; the second
assignment thunked and that, in turn, evaluated without forcing it. But with
Cy's modified version return =(1 2)= in both cases since now all the
intermediate statement forced.
**** c.
Since already forced value can not be changed by additional =force-it=. As we
noted in *a.* each statement of in the sequence already fully evaluated --
forced, so the modification does not affect at all to that specific example.
**** d.
Whatever choice we made, the evaluation of sequence being made in unexpected or
hard to be estimated time. It is totally due to the nature of normal-order
evaluation rule: By choosing the normal-order evaluation, we decoupled the time
when the expression got assembled from the time the expression actually got
evaluated. However, using assignment, we are meant to control the "time"
explicitly in the computer, that is when the evaluation is being carried out,
which mirrored the real world. The time is "state." So those -- the assignment
and normal-order rule -- are incompatible in themselves; we shouldn't expect to
use sequence of expressions /per se/ side-effects.
*** Exercise 4.31
We need to change =list-of-delayed-args= to encompass this new extension. And
also we need to change the =force-it= and add additional data structure that is
analogous to =thunk= -- =memo-thunk=.

We decide =thunk= to represent the delayed object without memoized; =memo-thunk=
for delayed object with memoization.

Let us code what we designed using digital paper!
#+BEGIN_SRC scheme
(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env))) ; changed
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (let ((params (procedure-parameters procedure)))
            (extend-environment
             (map param-name params)
             (list-if-delayed-args
              arguments (map param-type params) env) ; changed
             (procedure-environment procedure)))))
        (else
         (error
          "Unknown procedure type -- APPLY" procedure))))

;; param ADT
(define (typed-param? param)
  (and (pair? param)
       (pair? (cdr param))))
(define (param-type param)
  (if (typed-param? param)
      (cadr param)
      'strict))
(define (param-name param)
  (if (typed-param? param)
      (car param)
      param))

(define (list-if-delayed-args exps types env)
  (cond ((no-operands? exps) '())
        ((null? types)
         (error "the number of arguments do not agree with procedure"
                ;; actually whether we should use more sophisticated error message
                ;; or should delegate the error raise to extend-environment
                ;; current error message is not informative enough to be useful.
                exps))
        (else
         (cons
          ((case (first types)
             ((strict) actual-value)
             ((lazy) delay-it)
             ((lazy-memo) delay-memo-it)
             (else (error "Unknown parameter type")))
           (first-operand exps)
           env)
          (list-if-delayed-args (rest-operands exps)
                                (cdr types)
                                env)))))

;; memo-thunk ADT
(define (delay-memo-it exp env)
  (list 'memo-thunk exp env))
(define (memo-thunk? obj)
  (tagged-list? obj 'memo-thunk))

(define (force-it obj)
  (cond ((thunk? obj)
         (actual-value (thunk-exp obj) (thunk-env obj)))
        ((memo-thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)  ; replace exp with its value
           (set-cdr! (cdr obj) '())     ; forget unneeded env
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
#+END_SRC

Then test! Here we use [[Exercise 4.29][ex 4.29]] for test:
#+BEGIN_SRC scheme
;;; L-Eval input:
(define count 0)

;;; L-Eval value:
ok

;;; L-Eval input:
(define count-memo 0)

;;; L-Eval value:
ok

;;; L-Eval input:
(define (id-memo (x lazy-memo))
  (set! count-memo (+ count-memo 1))
  x)

;;; L-Eval value:
ok

;;; L-Eval input:
(define (id-lazy (x lazy))
  (set! count (+ count 1))
  x)

;;; L-Eval value:
ok

;;; L-Eval input:
(define (square-memo (x lazy-memo))
  (* x x))

;;; L-Eval value:
ok

;;; L-Eval input:
(define (square-lazy (x lazy))
  (* x x))

;;; L-Eval value:
ok

;;; L-Eval input:
(square-memo (id-memo 10))

;;; L-Eval value:
100

;;; L-Eval input:
count-memo

;;; L-Eval value:
1

;;; L-Eval input:
(square-lazy (id-lazy 10))

;;; L-Eval value:
100

;;; L-Eval input:
count

;;; L-Eval value:
2

#+END_SRC

Works!
*** Exercise 4.32
Now we can construct /reversed/ stream, that is, we use =car= to traverse and
=cdr= to store elements. With this extra concept combined with original stream,
we can now manipulate line not only ray! -- what we defined as integers in
stream was actually just natural numbers not integers, strictly speaking. More
over, we can manipulate tree operations lazily as well as list structure. So
until this point, to manipulate tree in combination with stream, we needed to
first construct whole tree strictly and then convert that into stream. If we
represent the graph in lazy tree structure, conceptually it equivalent to the
non-deterministic programming, which decomposed automatic search from
computation. We can think this differently: By allowed to manipulate not only
future -- =cdr= part -- but also past -- =car= part; so we can now traverse the
time branches back and forth freely.
*** Exercise 4.33
The reason it produce an error is as follows:
1. Quoted expression processed by the =read= procedure, by which we get the
   input from terminal, of underlying Lisp language; it is "list" in
   implementation language not that in language being implemented.
2. So we need transform from list structure of implementation language into that
   of language being implemented.


Here is the code do the right thing:
#+BEGIN_SRC scheme
(define (list->list lst)
  (fold-right (lambda (item ->list)
                `(cons ,item ,->list))
              '(quote ())
              lst))
(define (text-of-quotation exp)
  (let ((contents (cadr exp)))
    (if (list? contents)
        (eval (list->list contents) the-global-environment)
        contents)))
#+END_SRC

Then let's test!
#+BEGIN_SRC scheme
;;; setup
(eval cons-def the-global-environment)
(eval car-def the-global-environment)
(eval cdr-def the-global-environment)
;;; test quotation
(actual-value '(car '(a b c)) the-global-environment)

;Quit!
#+END_SRC

Unfortunately, it doesn't return the control! It turns out due to the test
=list?= since
#+BEGIN_SRC scheme
(list? '())

;Value: #t
#+END_SRC

So
#+BEGIN_SRC scheme
(actual-value '(quote ()) the-global-environment)

;Quit!
#+END_SRC
runs forever!

Fix the procedure as
#+BEGIN_SRC scheme
(define (text-of-quotation exp)
  (let ((contents (cadr exp)))
    (if (and (not (null? contents))
             (list? contents))
        (eval (list->list contents) the-global-environment)
        contents)))
#+END_SRC

Then re-run:
#+BEGIN_SRC scheme
(actual-value '(car '(a b c)) the-global-environment)

;Unbound variable a
#+END_SRC

Now the problem is that =list->list= does not =quote= the element! Let's fix:
#+BEGIN_SRC scheme
(define (list->list lst)
  (fold-right (lambda (item ->list)
                `(cons ',item ,->list))
              '(quote ())
              lst))
#+END_SRC

Now it produces right result:
#+BEGIN_SRC scheme
(actual-value '(car '(a b c)) the-global-environment)

;Value: a
#+END_SRC
*** Exercise 4.34
To print the pair, we need to recognize whether given object is pair by =pair?=
We can exploit the message passing paradigm:
1. Then =(define (pair? x) (x 'pair?))=
2. This will work if we request only to pair object; but predicate meant to
   check whether given argument satisfy specific condition. So predicate should
   not signal error unless it provided certain condition should be satisfied but
   violated by user (although it is not appropriate to assume informal
   contraction without verification).
3. So we'd better to take another way: Make =cons=, =car=, =cdr= non-strict
   primitive procedure; by including =pair?= as primitive (strict) procedure, we
   got what we wanted.


So we need to modify =apply= to cope with primitive non-strict application, and
the new syntax procedure for non-strict primitive procedures, finally the
=setup-environment=:
#+BEGIN_SRC scheme
 (define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure) ;strict primitive
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env)))
        ((non-strict-primitive-procedure? procedure) ;non-strict primitive
         (apply-primitive-procedure
          procedure
          (list-of-delayed-args arguments env)))
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)
           (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type -- APPLY" procedure))))

(define (non-strict-primitive-procedure? proc)
  (tagged-list? proc 'non-strict))

(define (non-strict-procedure-names)
  (map car
       non-strict-procedures))

(define (non-strict-procedure-objects)
  (map (lambda (proc) (list 'non-strict (cadr proc)))
       non-strict-procedures))

(define (setup-environment)
  (let ((initial-env
         (extend-environment
          (non-strict-procedure-names)
          (non-strict-procedure-objects)
          (extend-environment (primitive-procedure-names)
                              (primitive-procedure-objects)
                              the-empty-environment))))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
;; initialize the startup environment
(define primitive-procedures
  (append (list
           (list 'pair? (lambda (p) (tagged-list? p 'pair)))
           (list 'car cadr)
           (list 'cdr cddr))
          primitive-procedures))

(define non-strict-procedures
  `((cons ,(lambda (x y) (cons 'pair (cons x y))))))
#+END_SRC

We need to make pair as tagged list to discern with other data structure. Also
note that we made only =cons= non-strict; but not the =car= and =cdr= since
there is no need to make those non-strict and further more, if we make them so,
it only make the implementation complicate to select the part appropriately! You
need to reason this by experimenting with non-strict =car= and =cdr=.

Then test!
#+BEGIN_SRC scheme
(actual-value '(car (cons 2 4)) the-global-environment)

;Value: 2

(thunk? (eval '(car (cons 2 4)) the-global-environment))

;Value: #t

(eval '(pair? (cons 2 4)) the-global-environment)

;Value: #t
#+END_SRC

Now we return to display the lazy pair appropriately. Here we used structural
induction on object. For the pair object, we also used induction on depth
combined with structural induction on =o2=. Finally for the choice of
representation of thunk, we took that of stream:
#+BEGIN_SRC scheme
(define (represent-object o)
  (cond ((compound-procedure? o)
         (list 'compound-procedure
                     (procedure-parameters o)
                     (procedure-body o)
                     '<procedure-env>))
        ((thunk? o)
         '...)
        ((evaluated-thunk? o)
         (represent-object (thunk-value o)))
        ((tagged-list? o 'pair)
         (represent-pair (cdr o)))
        (else o)))

(define (represent-pair p)
  (let ((rep1 (represent-object (car p))) ;induction on depth
        (o2 (cdr p)))
    (cond ((thunk? o2)
           (list rep1 (represent-object o2)))
          ((evaluated-thunk? o2)
           (cons rep1 (represent-object o2)))
          ((tagged-list? o2 'pair)
           (cons rep1 (represent-pair (cdr o2))))
          (else                         ;atomic value
           (cons rep1 (represent-object o2))))))
#+END_SRC

Then modify =user-print= as follows:
#+BEGIN_SRC scheme
(define (user-print object)
  (display (represent-object object)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;;; L-Eval input:
(define test-display (cons ((lambda (x) (+ 2 x)) 3) (cons 2 '())))

;;; L-Eval value:
ok

;;; L-Eval input:
test-display

;;; L-Eval value:
(... ...)

;;; L-Eval input:
(car (cdr test-display))

;;; L-Eval value:
2

;;; L-Eval input:
test-display

;;; L-Eval value:
(... 2 ...)

;;; L-Eval input:
(cdr (cdr test-display))

;;; L-Eval value:
()

;;; L-Eval input:
test-display

;;; L-Eval value:
(... 2)

;;; L-Eval input:
(car test-display)

;;; L-Eval value:
5

;;; L-Eval input:
test-display

;;; L-Eval value:
(5 2)

#+END_SRC

For the completeness, here I add to =user-print= additional feature, detect the
shared structure in lazy pair:
#+BEGIN_SRC scheme
(define (pair?* o) (tagged-list? o 'pair))
(define car* cadr)
(define cdr* cddr)

(define (extract-sharings object)
  (let ((tracked '())
        (sharings '()))
    (define scan
      (lambda (o)
        (define (mutate-list! o not-tracked-op)
          (if (memq o tracked)
              (if (not (memq o sharings))
                  (set! sharings (cons o sharings))
                  'done)
              (begin (set! tracked (cons o tracked))
                     (not-tracked-op o))))
        (cond ((evaluated-thunk? o)
               (scan (thunk-value o)))
              ((pair?* o)
               (mutate-list!
                o (lambda (o)
                    (scan (car* o))
                    (scan (cdr* o))))))))
    (scan object)
    sharings))

(define (display-entry object)
  (let ((sharings (extract-sharings object))
        (issue-table '(*issue*)))       ;hash-table won't work!
    (define (issued-number o)
      (cond ((assq o (cdr issue-table)) => cadr)
            (else #f)))
    (define issue!
      (let ((id 0))                     ;identification number
        (lambda (o)
          (let ((to-be-issued id))
            (set-cdr! issue-table (cons (list o to-be-issued)
                                        (cdr issue-table)))
            (set! id (1+ id))
            to-be-issued))))
    (define (display-issued-object id)
      (display "#")
      (display id)
      (display "#"))
    (define (display-issuing id)
      (display "#")
      (display id)
      (display "="))
    (define (display-object o)
      (cond ((compound-procedure? o)
             (display (list 'compound-procedure
                            (procedure-parameters o)
                            (procedure-body o)
                            '<procedure-env>)))
            ((thunk? o)
             (display '...))
            ((evaluated-thunk? o)
             (display-object (thunk-value o)))
            ((pair?* o)
             (display-pair o))
            (else (display o))))
    (define (display-pair p)
      (define (display-pair-entry p)
        (display "(")
        (display-object (car* p))
        (display-iter (cdr* p))
        (display ")"))
      (define (display-shared-or-default exp default-op pad1-op pad2-op)
        (if (memq exp sharings)         ;it is shared structure
            (let ((id (issued-number exp)))
              (if id
                  (begin (pad1-op)
                         (display-issued-object id))
                  (begin (pad2-op)
                         (display-issuing (issue! exp))
                         (display-pair-entry exp))))
            (default-op exp)))
      (define (display-iter exp)
        (cond ((null? exp))
              ((evaluated-thunk? exp)
               (display-iter (thunk-value exp)))
              ((pair?* exp)
               (display-shared-or-default
                exp
                (lambda (p)
                  (display " ")
                  (display-object (car* p))
                  (display-iter (cdr* p)))
                (lambda () (display " . "))
                (lambda () (display " "))))
              ((thunk? exp)
               (display " ")
               (display-object exp))
              (else
               (display " . ")
               (display-object exp))))
      (display-shared-or-default
       p (lambda (p) (display-pair-entry p))
       (lambda () 'ignore)
       (lambda () 'ignore)))
    (display-object object)
    (set-cdr! issue-table '())))        ;clear the cached
#+END_SRC

Then our =user-print= became
#+BEGIN_SRC scheme
(define (user-print object)
  ;; (display (represent-object object))
  (display-entry object))
#+END_SRC

Then test code:
#+BEGIN_SRC scheme
;;; L-Eval input:
(define ones (cons 1 ones))

;;; L-Eval value:
ok

;;; L-Eval input:
ones

;;; L-Eval value:
(... ...)

;;; L-Eval input:
(car ones)

;;; L-Eval value:
1

;;; L-Eval input:
(cdr ones)

;;; L-Eval value:
#0=(1 . #0#)

;;; L-Eval input:
(define one (cons 1 two))               ;mutual recursive definition

;;; L-Eval value:
ok

;;; L-Eval input:
(define two (cons 2 one))

;;; L-Eval value:
ok

;;; L-Eval input:
(car one)

;;; L-Eval value:
1

;;; L-Eval input:
(cdr one)

;;; L-Eval value:
(... ...)

;;; L-Eval input:
(car two)

;;; L-Eval value:
2

;;; L-Eval input:
(cdr two)

;;; L-Eval value:
#0=(1 2 . #0#)

;;; L-Eval input:
one

;;; L-Eval value:
#0=(1 2 . #0#)

;;; L-Eval input:
two

;;; L-Eval value:
#0=(2 1 . #0#)

#+END_SRC
* Variations on a Scheme -- Nondeterministic Computing
** Amb and Search
*** Exercise 4.35
Note that this procedure should behave similar with =an-element-of=:
#+BEGIN_SRC scheme
(define (an-integer-between low high)
  (require (<= low high))
  (amb low (an-integer-between (1+ low) high)))
#+END_SRC

Then here is the test:
#+BEGIN_SRC scheme
;;; Amb-Eval input:
(an-integer-between 1 10)

;;; Starting a new problem
;;; Amb-Eval value:
1

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
2

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
3

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
4

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
5

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
6

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
7

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
8

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
9

;;; Amb-Eval input:
try-again

;;; Amb-Eval value:
10

;;; Amb-Eval input:
try-again

;;; There are no more values of
(an-integer-between 1 10)
#+END_SRC
