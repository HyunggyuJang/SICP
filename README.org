#+TITLE: SICP Study Note
* Building Abstractions with Data
** Hierarchical Data and the Closure Property
*** Repersenting Sequences
- Does it prints same as list to construct a sequence by conses?
  #+BEGIN_SRC scheme
(cons 1 (cons 2 (cons 3 (cons 4 '()))))
  #+END_SRC

  #+RESULTS:
  | 1 | 2 | 3 | 4 |

  #+BEGIN_SRC scheme
(list 1 2 3 4)
  #+END_SRC

  #+RESULTS:
  | 1 | 2 | 3 | 4 |

  →Yeah, looks same.
**** Exercise 2.17
#+BEGIN_SRC scheme
(define (last-pair items)               ;assume items is non empty list
  (let ((next-p (cdr items)))
    (if (null? next-p)
        items
        (last-pair next-p))))
#+END_SRC

#+RESULTS:
: #<unspecified>

Let's test with it
#+BEGIN_SRC scheme
(last-pair (list 23 72 149 34))
#+END_SRC

#+RESULTS:
| 34 |

It works.

**** Exercise 2.18
#+BEGIN_SRC scheme
(define (reverse l)
  (define (iter l r)
    (if (null? l)
        r
        (iter (cdr l) (cons (car l) r))))
  (iter l nil))                         ; we don't know what nil is but assume we have
#+END_SRC
Or do not use nil explicitly analogous to last-pair.
#+BEGIN_SRC scheme
(define (reverse l)                     ;assume that l is not empty
  (let ((next-p (cdr l)))
    (if (null? next-p)
        l
        (append (reverse next-p) (list (car l))))))
(define (append l1 l2)
  (if (null? l1)
      l2
      (cons (car l1) (append (cdr l1) l2))))
#+END_SRC

#+RESULTS:
: #<unspecified>

**** Exercise 2.19
Let's review the change-counting program. We know that the number of
change-count can be reduced as follows:
- Exchange the change using the first coin and
- not using the first coin


The above states the reductive process. To complete the whole process of it, we
need to specify the base case:
- when the amount is zero, then we have only one way to change.


It is quite tricky at first why this is true; but think it this way: simulate
the situation with some simple case,e.g. the amount is 6 cents or like that.
Then we come to realize it really need to count as 1 when amount is zero in this
recursive process.

That's not the only base case; by the reductive process we have only two cases left to consider:
- when we have 0 coins to change, we count this as 0 and
- when we have negative amount to change, there is no way to change the amount; 0.


Again, we can got the guts by simulating the simple cases or more formally we
should reason this argument using induction. I think it is reasonable to use the
computer aided proof check like this situation because humankind inherited the
error-prone property. Nonetheless let's code.

Then we can code this recursive process:
#+BEGIN_SRC scheme
(define us-coins (list 50 25 10 5 1))   ;examples of how the parameter, coin-values, constructed
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((< amount 0) 0)
        ((no- wjmore? coin-values) 0)         ;↑base cases
        (else (+ (cc (- amount
                        (first-denomination coin-values)) ;first reduction branch
                     coin-values)
                 (cc amount             ;second (last) reduction branch
                     (except-first-denomination coin-values))))))

(define (no-more? coin-values)
  (null? coin-values)) ;we could (define no-more? null?) but we don't like to mess up the debugger

(define (first-denomination coin-values)
  (car coin-values))                 ;we provided that the coin-values not empty

(define (except-first-denomination coin-values)
  (cdr coin-values))                 ;we provided that the coin-values not empty
#+END_SRC

#+RESULTS:

We can reason that the order of the list ~coin-values~ does not affect the
answer produced by cc; it just only takes more times to evaluate it.

We can assure that by experimenting with some examples:
#+BEGIN_SRC scheme :returns value
(define us-reverse (reverse us-coins))
(cc 100 us-reverse)
(cc 100 us-coins)
(cc 112 us-reverse)
(cc 112 us-coins)
#+END_SRC

#+RESULTS:

The ~us-reverse~ results to same as ~us-coins~. Why should it be?: The reductive
process and base case I've wrote above does not mention about the order of
coins; it should behave as same whatever order is.

Then how about the efficiency (complexity) of space and times? We can guess the
reversed order should be more complex than the previous case; but it is not
obvious.

Let's do some trick. While we have not studied the ~set!~ statement, but it is
useful to estimate the complexity and get some intuition about the general case:
#+BEGIN_SRC scheme
(define (cc amount coin-values)
  (define (cc-counter amount coin-values)
    (cond ((= amount 0)
           (set! count (1+ count))
           1)
          ((< amount 0)
           (set! count (1+ count))
           0)
          ((no-more? coin-values)
           (set! count (1+ count))
           0)                           ;↑base cases
          (else
           (set! count (1+ count))
           (+ (cc-counter (- amount
                     (first-denomination coin-values)) ;first reduction branch
                  coin-values)
              (cc-counter amount                ;second (last) reduction branch
                  (except-first-denomination coin-values))))))
  (define count 0)                      ;count the steps needed to evaluate cc
  (cons count (cc-counter amount coin-values))) ;return the pair of count and number of cc ways
#+END_SRC

Then we can inspect by using that:
#+BEGIN_SRC scheme
(cc 100 us-reverse)                     ;=> (38901 . 292)
(cc 100 us-coins)                       ;=> (15499 . 292)
#+END_SRC

Yeah, as we expected, the reversed version needs more than double steps than original.
How can we reason this? Let's we do some simulation with simple argument using
substitution model. After some experiment, I've realized it is hard to prove
that the reversed one has more step complexity than previous in asymptotic notation.
To prove that the reversed one has more step & space complextity, we should
prove that using inequality sign not asymptotic notation; it will convolve more
subtle argument. We should use proof assistant otherwise it become really tricky
to prove.
**** Exercise 2.20
I've started not to think about the structure. It's the evidence that I've
exhausted completely. Anyway here is the code:
#+BEGIN_SRC scheme
(define (same-parity first . rest)
  (let ((same? (if (even? first)
                   even?
                   odd?)))
    (cons first (filter same? rest))))  ;wishful tinking

(define (filter include? l)
  (if (null? l)
      l
      (let ((hd (car l))                ;it would be clearer if I use the let* notation.
            (tl (cdr l)))               ;but I've not learned yet.
        (let ((filtered
               (filter include? tl)))
          (if (include? hd)
              (cons hd filtered)
              filtered)))))
#+END_SRC
Isn't this obvious to explain? Anyway, I'll skip that.
**** Mapping over lists
#+BEGIN_SRC scheme
(define (map proc items)
  (if null? items)
  nil
  (cons (proc (car items))
        (map proc (cdr items))))
#+END_SRC
**** Exercise 2.21
#+BEGIN_SRC scheme
(define (square-list items)
  (if (null? items)
      nil
      (cons (square (car items) (square-list (cdr items))))))

(define (square-list items)
  (map square items))
#+END_SRC
**** Exercise 2.22
1. Because the structure of the helper procedure iter is same as our first
   definition of [[Exercise 2.18][reverse]].
2. List is, by definition, sequence of pairs. But the tried implementation
   returns something other than list: ~(cons answer (square (car things)))~ is
   not chained pairs.


**** Exercise 2.23
*First try*
#+BEGIN_SRC scheme
(define (for-each proc items)
  (if (null? items)                     ;base case
      true                              ;done case (termination)
.....
#+END_SRC
↑ We can not use if clause for evaluation of sequenced statement.
So we should use cond clause instead.
#+BEGIN_SRC scheme
(define (for-each proc items)
  (cond ((null? items) true)            ;termination (base) case return true, which can be arbitrary value.
        (else
         (proc (car items))
         (for-each proc (cdr items))))
#+END_SRC
Let's test it:
#+BEGIN_SRC scheme
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
#+END_SRC
Yeah works well.
*** Hierarchical Structures
Let's implement the ~count-leaves~. It should behave like follows:
#+BEGIN_SRC scheme
(define x (cons (list 1 2) (list 3 4)))
(length x)                              ;3
(count-leaves x)                        ;4
(list x x)                              ;(((1 2) 3 4) ((1 2) 3 4))
(length (list x x))                     ;2
(count-leaves (list x x))               ;8
#+END_SRC
The implementation of ~count-leaves~ is analogous to ~length~:
- ~count-leaves~ of the empty list is 0.


But in the reduction step, we should take a count the ~car~ part:
- ~count-leaves~ of tree ~x~ is ~count-leaves~ of the ~car~ of ~x~ plus
  ~count-leaves~ of the ~cdr~ of ~x~.


After repeatedly apply the reduction step, we reach the another base case:
- ~count-leaves~ of a leaf is 1.


And we can test whether it is leaf by using the primitive predicate ~pair?~ we
test whether it is pair or not.

Then we can complete the procedure:
#+BEGIN_SRC scheme
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
#+END_SRC
**** Exercise 2.24
I've drawn assigned task in Digital Papper.
**** Exercise 2.25
1. ~(cadaddr (list 1 3 (list 5 7) 9))~ results to 7.
   The notation ~(cadaddr x)~ is abbreviation for ~(car (cdr (car (cdr (cdr x)))))~.
   Let we use this notation from this point for the space.
2. ~(caar (list (list 7)))~.
3. ~(cadadadadadadr x)~, where ~x~ is ~(1 (2 (3 (4 (5 (6 7))))))~.


**** Exercise 2.26
1. ~(append x y)~ would result to ~(1 2 3 4 5 6)~.
2. ~(cons x y)~ would result to ~((1 2 3) 4 5 6)~.
3. ~(list x y)~ would result to ~((1 2 3) (4 5 6))~.


We can verify those by evaluating:
#+BEGIN_SRC scheme
(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y)
(cons x y)
(list x y)
#+END_SRC

Yeah the results are same as above.
**** Exercise 2.27
We should implement, so called, ~deep-reverse~. It behaves as follows:
#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4))) ;((1 2) (3 4))
(reverse x)                             ;((3 4) (1 2))
(deep-reverse x)                        ;((4 3) (2 1))
#+END_SRC

It is obvious that we should use, so called, tree recursion for it. Or wishful
thinking so to say.

Let's start with reduction step:
- We assume that subtrees are /deep reversed/. Then we can complete the whole
  procedure:
  #+BEGIN_SRC scheme
(reverse (cons (deep-reverse (car x)) (deep-reverse (cdr x))))
  #+END_SRC
- Then the results are reduced to the subproblem whose argument is subtree of ~x~.


There are two base case with which the reduction step end up:
- By cdring down the list, we optain nil at the very end.
- Or, we could encounter the leaf, not the pair by caring the list.


As consequence, we can complete the procedure analogous to ~count-leaves~:
#+BEGIN_SRC scheme
(define (deep-reverse x)
  (cond ((null? x) x)
        ((not (pair? x)) x)
        (else (reverse (cons
                        (deep-reverse (car x))
                        (deep-reverse (cdr x)))))))
#+END_SRC
**** Exercise 2.28
Implement ~fringe~. Whose behavior are the followings:
#+BEGIN_SRC scheme
(define x (list (list 1 2) (list 3 4)))
(fringe x)                              ;(1 2 3 4)
(fringe (list x x))                     ;(1 2 3 4 1 2 3 4)
#+END_SRC

The strategy is similar with [[Exercise 2.27][above]]:
#+BEGIN_SRC scheme
(define (fringe x)
  (cond ((null? x) x)
        ((not (pair? x)) (list x))
        (else (append (fringe (car x))
                      (fringe (cdr x))))))
#+END_SRC

Note that we return the singleton list in the case of leaf; it is necessary at
the reduction step.
**** Exercise 2.29
Here we model the binary mobile, which consists of two branches--a left branch
and right branch. Each branch is a rod of a certain length, from which hangs
either a weight or another binary mobile.

We can construct it by using ~list~:
#+BEGIN_SRC scheme
(define (make-mobile left right)
  (list left right))
#+END_SRC

A branch is constructed from a ~length~, which must be a number, together with a
~structure~, which may be either a number--a simple weight-- or another mobile:
#+BEGIN_SRC scheme
(define (make-branch length structure)
  (list length structure))
#+END_SRC

***** a.
Then we can implement the selectors, namely ~left-branch~ and ~right-branch~:
#+BEGIN_SRC scheme
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cadr mobile))
#+END_SRC
And the branch' structure:
#+BEGIN_SRC scheme
(define (branch-structure branch)
  (cadr branch))
#+END_SRC

***** b.
The procedure that returns weight of mobile, ~total-weight~, is similar with
above tree recursion processes:[fn::We sense more and more replicative patterns
here]
- Reduction process:
  #+BEGIN_SRC scheme
(+ (total-weight (branch-structure (left-branch mobile)))
   (total-weight (branch-structure (right-branch mobile))))
  #+END_SRC
  which end up with
- Base case:
  #+BEGIN_SRC scheme
(if (not (mobile? x)) x)                ;a simple weight case
  #+END_SRC
  And the ~mobile?~ test whether it is mobile:
  #+BEGIN_SRC scheme
(define (mobile? x) (pair? x))
  #+END_SRC


And then we complete the procedure:
#+BEGIN_SRC scheme
(define (total-weight mobile)
  (if (not (mobile? mobile))
      mobile
      (+ (total-weight (branch-structure (left-branch mobile)))
         (total-weight (branch-structure (right-branch mobile))))))
#+END_SRC
***** c. Design the predicate that tests whether a binary mobile is balanced.
Here we also exploit the wishful thinking about the tree structure:
- Reduction process:
  #+BEGIN_SRC scheme
(let ((left (left-branch mobile))
      (right (right-branch mobile)))
  (let ((mobile-l (branch-structure left))
        (mobile-r (branch-structure right)))
    (if (and (balanced? mobile-l)
             (balanced? mobile-r))
        (= (* (branch-length left)
              (total-weight mobile-l))
           (+ (branch-length right)
              (total-weight mobile-r)))
        false)))
  #+END_SRC
  Here we used the ~branch-length~ whose definition is
  #+BEGIN_SRC scheme
(define (branch-length branch)
  (car branch))
  #+END_SRC
  Yeah, it's quite dirty; but straight forward. We can revise the if clause as
  follow:
  #+BEGIN_SRC scheme
(and (balanced? mobile-l)
     (balanced? mobile-r)
     (= (* (branch-length left)
              (total-weight mobile-l))
           (+ (branch-length right)
              (total-weight mobile-r))))
  #+END_SRC
  as the consequence and alternative of if clause are boolean. This end up with
- Base case (a simple weight):
  #+BEGIN_SRC scheme
(if (not (mobile? x)) true)
  #+END_SRC
  which can be reduced to
  #+BEGIN_SRC scheme
(not (mobile? x))
  #+END_SRC


The complete code:
#+BEGIN_SRC scheme
(define (blanced? mobile)
  (and (not (mobile? mobile))
       (let ((left (left-branch mobile))
             (right (right-branch mobile)))
         (let ((mobile-l (branch-structure left))
               (mobile-r (branch-structure right)))
           (and (balanced? mobile-l)
                (balanced? mobile-r)
                (= (* (branch-length left)
                      (total-weight mobile-l))
                   (+ (branch-length right)
                      (total-weight mobile-r))))))))
#+END_SRC
***** d.
Suppose we change the representation of mobiles so that the constructors are
#+BEGIN_SRC scheme
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
#+END_SRC

Then we should change only the followings:
#+BEGIN_SRC scheme
(define (right-branch mobile)
  (cdr mobile))
(define (branch-structure branch)
  (cdr branch))
#+END_SRC
Boom! That's it. The power of abstract barrier!

**** Mapping over trees
We can define the ~scale-tree~ procedure analogous to ~scale-list~ using ~map~:
#+BEGIN_SRC scheme
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
#+END_SRC
**** Exercise 2.30
Define a procedure ~square-tree~ analogous to the ~square-list~ procedure of [[Exercise
2.21][exercise 2.21]].
That is, ~square-tree~ should behave as follows:
#+BEGIN_SRC scheme
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))                     ;(1 (4 (9 16) 25) (36 49))
#+END_SRC

***** Define ~square-tree~ without higher-order procedures
We can do this by analogy to ~scale-tree~:
#+BEGIN_SRC scheme
(define (square-tree tree)
  (cond ((null? tree) tree)
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree (car tree))
                    (square-tree (cdr tree))))))
#+END_SRC
***** Define ~square-tree~ using ~map~
#+BEGIN_SRC scheme
(define (square-tree tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree sub-tree)
             (square sub-tree)))
       tree))
#+END_SRC

**** Exercise 2.31
Define ~tree-map~ that behave as follows:
#+BEGIN_SRC scheme
(define (square-tree tree) (tree-map square tree))
#+END_SRC
It is easy:
#+BEGIN_SRC scheme
(define (tree-map proc tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (tree-map proc sub-tree)
             (proc sub-tree)))
       tree))
#+END_SRC
**** Exercise 2.32
We can get the whole subsets of ~s~ by reducing that:
- The subsets that include the element ~a~ of ~s~ plus
- The subsets that do not include the element ~a~.


Then we can complete the code:
#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list s)
      (let ((rest (subsets (cdr s))))
        (append rest
                (map (lambda (subset)
                       (cons (car s) subset))
                     rest)))))
#+END_SRC
*** Sequences as Conventional Interfaces
**** Sequence Operations
The main procedures that complete the signal processing interfaces are
followings:
- [[Mapping over lists][map]]
- [[Exercise 2.20][filter]]
- accumulate
  #+BEGIN_SRC scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
  #+END_SRC


All that remains to implement signal-flow diagrams is to enumerate the sequence
of elements to be processed. That is, to make signals which processed afterward.
- make initial signal; produces list.
  To enumerate the interval of integers, we can code
  #+BEGIN_SRC scheme
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
  #+END_SRC

  For tree, we can transform the tree as follows[fn::In fact, it is same
  procedure as [[Exercise 2.28][fringe]].]:
  #+BEGIN_SRC scheme
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
  #+END_SRC

**** Exercise 2.33
By comparing the ~map~ procedure and ~accumulate~ we can define the ~map~ as follows:
#+BEGIN_SRC scheme
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y))
              nil
              sequence))
#+END_SRC
And the others also can be implemented analogous to above:
#+BEGIN_SRC scheme
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (1+ y)) 0 sequence))
#+END_SRC
**** Exercise 2.34
Horner's rule.
#+BEGIN_SRC scheme
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              coefficient-sequence))
;; test
(horner-eval 2 (list 1 3 0 5 0 1))      ;79
#+END_SRC
Actually I've used this in the exercise in [[github:HyunggyuJang/Isabelle][Isabelle]].
**** Exercise 2.35
We can redefine ~count-leaves~ from [[Hierarchical Structures][this]] using ~accumulate~, which means that we
can formulate ~count-leaves~ as signal processing interface.

At first, let's try out without lingering over it; just compare those structure
and code it appropriately:
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate (lambda (x y)
                (if (not (pair? x))
                    (1+ y)
                    (+ (count-leaves x)
                       y)))
              0
              t))
#+END_SRC

It works; but it is not the one the text wanted: Text want we process the ~t~
with ~map~ before feed it to ~accumulate~:
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate <??> <??> (map <??> <??>)))
#+END_SRC
And more, it is no more clear than we did previously; just cramming all of the
messy things from ~count-leaves~ into the ~op~ of ~accumulate~.

We can do better than that. Let's follow text's intention; but how we get the
~count-leaves~ coded? As we trying to formulate this as signal processing
interface, first we need to processing the input ~t~ as 'signal'--list--so that
we can use conventional interfaces for this.

Then the remain is simple:
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate + 0 (map (lambda (x) 1)
                       (enumerate-tree t))))
#+END_SRC

Yeah, who even said that we shouldn't use ~enumerate-tree~ here? I think the
intention of this exercise was in that capturing recursive process in signal
processing framework. It looks silly when we map all the list items into number
~1~ like this; but it will compensate someday I think. Whatever, let's move on.

**** Exercise 2.36
The generalized version of ~accumulate~, ~accumulate-n~ deal with sequence of
sequences that all have same number of elements. The behavior is as follows:
#+BEGIN_SRC scheme
(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
;(22 26 30)
#+END_SRC

Here we use wishful thinking as usual:
- Reduction process:
  Let we assume that we were given the results of
  ~accumulate-n~ with sequence of sequences except the first element of each.
  Then we can complete the process by ~accumulate~ the first element of each and
  then consing it with the given:
  #+BEGIN_SRC scheme
(cons (accumulate op init (map car seqs))
      (accumulate-n op init (map cdr seqs)))
  #+END_SRC

  After repeatedly applying this process we get
- Base case:
  we end up with sequence of ~nil~:
  #+BEGIN_SRC scheme
(if (null? (car seqs))
    (car seqs))
  #+END_SRC
  This is the only base case because ~nil~ is not the sequence of sequences.

Then the complete code can be synthesized as usual:
#+BEGIN_SRC scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      (car seqs)
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))
#+END_SRC

**** Exercise 2.37
From now on, I'll pace up because I've already designed the strucutre of these
exercises on my note.
#+BEGIN_SRC scheme
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map (lambda (m_i) (dot-product m_i u))
       m))
(define (transpose mat)
  (accumulate-n cons '() mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (m_i)
           (matrix-*-vector cols m_i))
         m)))
#+END_SRC

**** Exercise 2.38
To get equal value from both ~fold-right~ and ~fold-left~, ~op~ should satisfy
the associative law of algebra and also commutative law with repect to ~init~.

**** Exercise 2.39
#+BEGIN_SRC scheme
(define (snoc x y)
  (append y (list x)))
(define (reverse sequence)
  (fold-right (lambda (x y)
                (snoc x y))
              '()
              sequence))
(define (reverse sequence)
  (fold-left (lambda (x y)
               (cons y x))
             '()
             sequence))
#+END_SRC

**** Exercise 2.40
#+BEGIN_SRC scheme
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))
(define (unique-pairs n)
  (flatmap
   (lambda (i)
     (map (lambda (j) (list i j))
          (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 n)))
#+END_SRC

**** Exercise 2.41
#+BEGIN_SRC scheme
(define (triple-sum-to-s n s)
  (filter (lambda (triple)
            (= s (fold-right + 0 triple)))
          (flatmap (lambda (k)
                     (map (lambda (p)
                            (snoc k p))
                          (unique-pairs (- k 1))))
                   (enumerate-interval 1 n))))
#+END_SRC

**** Exercise 2.42
#+BEGIN_SRC scheme
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval i board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(define empty-board '())

(define (adjoin-position new-row k rest-of-queens)
  (cons new-row rest-of-queens))

(define (safe? k positions)
  (define (equal-not-to? nr rest)
    (or (null? rest)
        (and (not (= nr (car rest)))
             (equal-not-to? nr (cdr rest)))))
  (define (pm-i-not-equal-to? nr i rest)
    (or (null? rest)
        (and (not (or (= (+ nr i) (car rest))
                      (= (- nr i) (car rest))))
             (pm-i-not-equal-to? nr (1+ i) (cdr rest)))))
  (let ((new-row (car positions))
        (rest-queens (cdr positions)))
    (and (equal-not-to? new-row rest-queens) ;provided that positions not empty
         (pm-i-not-equal-to? new-row 1 rest-queens))))
#+END_SRC
Note that here we didn't use the parameter ~k~ none of helper procedures--
~adjoin-position~ and ~safe?~ -- because we don't need to; I've thought it is
natural to think /the first k-1 columns/ as counted from the rightmost.
#+RESULTS:
: #<unspecified>

**** Exercise 2.43
Because by exchange the order of ~flatmap~ and ~map~ in the procedure
~queen-cols~ now the procedure call ~(queen-cols (- k 1))~ become evaluated
duplicately every ~new-row~ of ~(enumerate-interval 1 board-size)~, i.e
~board-size~ times.

We can reason the asymptotic time complexity of both cases:
- The original one is \theta(n^{3})
- The troubled one is \theta(n^{n})


Here we used the n as ~board-size~. As consequence, when ~board-size~ is 8 and
let the time taken by original one /T/, then the Louis's one takes approximately
more than 8^{5} \times /T/.
*** Example: A Picture Language
**** The picture language
- Primitives: /painter/
- Means of combination: ~beside~, ~below~
  - Create new painter from existing one: ~filp-vert~, ~flip-horiz~
- Means of abstraction: ~define~ in scheme language; As means of combination are
  all procedure in scheme, we can abstract them like any other procedure in scheme.


The results of combination of painter are also painters; by this closure
property with scheme's picture language inherit closure property in complete
sense.

I've tried to configure the picture language framework in mit-scheme; but to no vail.
I've searched the github of mit-scheme, which has the directory named "6001"
that contains ~6001.pkg~; to use that package, I've read the relevant content of
MIT scheme's user manual, also to no use; I've complied it with ~sf~ method in
edwin editor--this package depends on the edwin package, so I have no choice to
use emacs in this case--, and I found myself it is useless I need to put more
time in configuration than solving the exercises. The easiest alternative was to
use racket's sicp package, which I knew but have stuck with using *pure*
mit-scheme as I felt it is more canonical. Well, whatever, I've given up with
that; let's go with racket.
**** Exercise 2.44
We can define ~up-split~ analogous to ~right-split~.
#+BEGIN_SRC scheme
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))
#+END_SRC
**** Exercise 2.45
We can easily abstract this by higher order function:
#+BEGIN_SRC scheme
(define (split tran1 tran2)
  (lambda (painter n)
    (if (= n 0)
        painter
        (let ((smaller ((split tran1 tran2) painter (- n 1))))
          (tran1 painter (tran2 smaller smaller))))))
#+END_SRC
**** Exercise 2.46
Note that I implement ~sub-vect~ using the ~scale-vect~ and ~add-vect~; it is
subtle matter but I thought this definition is more canonical in algebraical
sense:
#+BEGIN_SRC scheme
(define (make-vect x y)
  (cons x y))

(define (xcor-vect v)
  (car v))

(define (ycor-vect v)
  (cdr v))

(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1)
                (xcor-vect v2))
             (+ (ycor-vect v1)
                (ycor-vect v2))))
(define (scale-vect s v)
  (make-vect (* (xcor-vect v) s)
             (* (ycor-vect v) s)))
(define (sub-vect v1 v2)
  (add-vect v1 (scale-vect -1 v2)))
#+END_SRC
**** Exercise 2.47
For first representation, we can implement selectors accordingly:
#+BEGIN_SRC scheme
(define (origin-frame f)
  (car f))
(define (edge1-frame f)
  (cadr f))
(define (edge2-frame f)
  (caddr f))
#+END_SRC
For the latter, similarly:
#+BEGIN_SRC scheme
(define (origin-frame f)
  (car f))
(define (edge1-frame f)
  (cadr f))
(define (edge2-frame f)
  (cddr f))
#+END_SRC
**** Exercise 2.48
Didn't we solved this in exercise 2.2? In there, we made segment using points
not vector but the representation axiom is same in both; we can reuse that
definiiton:
#+BEGIN_SRC scheme
;; Constructor make-segment
(define (make-segment start-pt end-pt)
  (cons start-pt end-pt))
;; Selector start-segment
(define (start-segment segment)
  (car segment))
;; Selector end-segment
(define (end-segment segment)
  (cdr segment))
#+END_SRC
**** Exercise 2.49
***** a.
The painter that draws the outline of the designated frame.
#+BEGIN_SRC scheme
(define outliner
  (let ((o (make-vect 0 0))
        (br (make-vect 1 0))
        (tr (make-vect 1 1))
        (tl (make-vect 0 1)))
    (segments->painter (list (make-segment o br)
                             (make-segment br tr)
                             (make-segment tr tl)
                             (make-segment tl o)))))
#+END_SRC
***** b.
The painter that draws an "X" by connecting opposite corners of the frame.
#+BEGIN_SRC scheme
(define x-liner
  (let ((o (make-vect 0 0))
        (br (make-vect 1 0))
        (tr (make-vect 1 1))
        (tl (make-vect 0 1)))
    (segments->painter (list (make-segment o tr)
                             (make-segment br tl)))))
#+END_SRC
***** c.
The painter that draws a diamond shape by connecting the midpoints of the sides
of the frame.
#+BEGIN_SRC scheme
(define dia-liner
  (let ((o (make-vect 0 0))
        (br (make-vect 1 0))
        (tr (make-vect 1 1))
        (tl (make-vect 0 1)))
    (let ((left (scale-vect 0.5 tl))
          (bottom (scale-vect 0.5 br)))
      (let ((right (add-vect br left))
            (top (add-vect tl bottom)))
        (segments->painter (list (make-segment left top)
                                 (make-segment top right)
                                 (make-segment right bottom)
                                 (make-segment bottom left)))))))
#+END_SRC
***** DONE d.
The wave painter.
#+BEGIN_SRC scheme
(define wave
  (let ((lhl (make-vect 0 0.65))         ;left hand
        (lhh (make-vect 0 0.8))
        (rhh (make-vect 1 0.35))
        (rhl (make-vect 1 0.2))
        (lal (make-vect 0.24 0.45))     ;left arm joint
        (lah (make-vect 0.24 0.6))
        (lsl (make-vect 0.4 0.6))       ;left shoulder
        (lsh (make-vect 0.4 0.65))
        (ln (make-vect 0.45 0.65))
        (rn (make-vect 0.55 0.65))
        (rs (make-vect 0.6 0.65))
        (lfa (make-vect 0.43 0.8))
        (rfa (make-vect 0.57 0.8))
        (lh (make-vect 0.45 1))
        (rh (make-vect 0.55 1))
        (lv (make-vect 0.43 0.55))
        (rv (make-vect 0.57 0.55))
        (lfo (make-vect 0.3 0))
        (rfo (make-vect 0.7 0))
        (lfo1 (make-vect 0.4 0))
        (rfo1 (make-vect 0.6 0))
        (cl (make-vect 0.5 0.3)))
    (segments->painter (list (make-segment lhh lah)
                             (make-segment lah lsh)
                             (make-segment lsh ln)
                             (make-segment ln lfa)
                             (make-segment lfa lh) ;from left hand high to left head
                             (make-segment lhl lal)
                             (make-segment lal lsl)
                             (make-segment lsl lv)
                             (make-segment lv lfo) ;from left hand low to left foot
                             (make-segment lfo1 cl)
                             (make-segment cl rfo1) ;from left foot1 to right foot1
                             (make-segment rfo rv)
                             (make-segment rv rhl) ;from left foot to right hand low
                             (make-segment rhh rs)
                             (make-segment rs rn)
                             (make-segment rn rfa)
                             (make-segment rfa rh)))        ;from left hand high left head
    ))
#+END_SRC
**** Transforming and combining painters
As we noted in the introductive session of this section, the combinators created
new painter element using the existing ones. Now we implement the combinators
using more general procedure, ~transform-painter~:
#+BEGIN_SRC scheme
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter
         (make-frame new-origin
                     (sub-vect (m corner1) new-origin)
                     (sub-vect (m corner2) new-origin)))))))
#+END_SRC
Here we exploit the fact that ~painter~ is actually just procedure, which takes
~frame~ for its arguemnt, so to transform the ~painter~ all we need to do is
transform the ~frame~ appropriately. Also note that we could have chosen ~edge1~
and ~edge2~ for transformation instead ~corner1~ and ~corner2~; we just found
from the use case it is more convenient.

Then we can implement a lot of combinators:
- ~filp-vert~
  #+BEGIN_SRC scheme
(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
  #+END_SRC
- We can also shrink the frame:
  #+BEGIN_SRC scheme
(define (shrink-to-upper-right painter)
  (transform-painter painter
                     (make-vect 0.5 0.5)
                     (make-vect 1.0 0.5)
                     (make-vect 0.5 1.0)))
  #+END_SRC
- Also we can rotate the frame:
  #+BEGIN_SRC scheme
(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
  #+END_SRC
- We can combine two or more paitners
  #+BEGIN_SRC scheme
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              split-point
                              (make-point 0.0 1.0)))
          (paint-right
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.0)
                              (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
  #+END_SRC
**** Exercise 2.50
We can define ~flip-horiz~ analogous to ~flip-vert~:
#+BEGIN_SRC scheme
(define (flip-horiz painter)
  (transform-painter painter
                     (make-vect 1.0 0.0) ;new origin
                     (make-vect 0.0 0.0) ;new end of edge1
                     (make-vect 0.0 1.0))) ;new end of edge2
#+END_SRC
We can define rotating frames in either way, using ~rotate90~ or directly:
- Using ~rotate90~:
  #+BEGIN_SRC scheme
(define (rotate180 painter)
  (rotate90 (rotate90 painter)))
(define (rotate270 painter)
  (rotate90 (rotate180 painter)))
  #+END_SRC
- define directly:
  #+BEGIN_SRC scheme
(define (rotate180 painter)
  (transform-painter painter
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 0.0)))
(define (rotate270 painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
  #+END_SRC
**** Exercise 2.51
- Define ~below~ analogous to ~beside~:
  #+BEGIN_SRC scheme
(define (below painter1 painter2)
  (let ((split-point (make-vect 0.0 0.5)))
    (let ((paint-bottom
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              (make-point 1.0 0.0)
                              split-point))
          (paint-top
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.5)
                              (make-vect 0.0 1.0))))
      (lambda (frame)
        (paint-bottom frame)
        (paint-top frame)))))
  #+END_SRC
- Using ~beside~:
  #+BEGIN_SRC scheme
(define (below painter1 painter2)
  (rotate270 (beside (rotate90 painter2)
                     (rotate90 painter1))))
  #+END_SRC
**** Exercise 2.52
***** a.
Let's add some smile to our ~wave~:
#+BEGIN_SRC scheme
(define wave
  (let ((lhl (make-vect 0 0.65))         ;left hand
        (lhh (make-vect 0 0.8))
        (rhh (make-vect 1 0.35))
        (rhl (make-vect 1 0.2))
        (lal (make-vect 0.24 0.45))     ;left arm joint
        (lah (make-vect 0.24 0.6))
        (lsl (make-vect 0.4 0.6))       ;left shoulder
        (lsh (make-vect 0.4 0.65))
        (ln (make-vect 0.45 0.65))
        (rn (make-vect 0.55 0.65))
        (lm (make-vect 0.48 0.77))      ;smile~
        (rm (make-vect 0.52 0.77))
        (cm (make-vect 0.5 0.75))
        (rs (make-vect 0.6 0.65))
        (lfa (make-vect 0.43 0.8))
        (rfa (make-vect 0.57 0.8))
        (lh (make-vect 0.45 1))
        (rh (make-vect 0.55 1))
        (lv (make-vect 0.43 0.55))
        (rv (make-vect 0.57 0.55))
        (lfo (make-vect 0.3 0))
        (rfo (make-vect 0.7 0))
        (lfo1 (make-vect 0.4 0))
        (rfo1 (make-vect 0.6 0))
        (cl (make-vect 0.5 0.3)))
    (segments->painter (list (make-segment lhh lah)
                             (make-segment lah lsh)
                             (make-segment lsh ln)
                             (make-segment ln lfa)
                             (make-segment lfa lh) ;from left hand high to left head
                             (make-segment lhl lal)
                             (make-segment lal lsl)
                             (make-segment lsl lv)
                             (make-segment lv lfo) ;from left hand low to left foot
                             (make-segment lfo1 cl)
                             (make-segment cl rfo1) ;from left foot1 to right foot1
                             (make-segment rfo rv)
                             (make-segment rv rhl) ;from left foot to right hand low
                             (make-segment rhh rs)
                             (make-segment rs rn)
                             (make-segment rn rfa)
                             (make-segment rfa rh) ;from left hand high left head
                             (make-segment lm cm)
                             (make-segment cm rm))) ;smile~
    ))
#+END_SRC
***** b.
Change ~corner-split~ using only one copy of the ~up-split~ and ~right-split~:
#+BEGIN_SRC scheme
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left up)
              (bottom-right right))
          (beside (below painter top-left)
                  (below bottom-right (corner-split painter (- n 1))))))))
#+END_SRC
***** c.
Modify ~square-limit~ so that the big Mr. Rogers look outward from each corner
of the square:
#+BEGIN_SRC scheme
(define (squre-limit painter n)
  (let ((combine4 (square-of-four flip-vert
                                  rotate180
                                  identity
                                  flip-horiz)))))
#+END_SRC
**** Resulting Pictures
#+BEGIN_SRC racket :session *racket-pict*
#lang racket
(require sicp-pict)
(define/contract wave
  (listof segment?)
  (let ((lhl (make-vect 0 0.65))         ;left hand
        (lhh (make-vect 0 0.8))
        (rhh (make-vect 1 0.35))
        (rhl (make-vect 1 0.2))
        (lal (make-vect 0.24 0.45))     ;left arm joint
        (lah (make-vect 0.24 0.6))
        (lsl (make-vect 0.4 0.6))       ;left shoulder
        (lsh (make-vect 0.4 0.65))
        (ln (make-vect 0.45 0.65))
        (rn (make-vect 0.55 0.65))
        (rs (make-vect 0.6 0.65))
        (lm (make-vect 0.48 0.77))      ;smile~
        (rm (make-vect 0.52 0.77))
        (cm (make-vect 0.5 0.75))
        (lfa (make-vect 0.43 0.8))
        (rfa (make-vect 0.57 0.8))
        (lh (make-vect 0.45 1))
        (rh (make-vect 0.55 1))
        (lv (make-vect 0.43 0.55))
        (rv (make-vect 0.57 0.55))
        (lfo (make-vect 0.3 0))
        (rfo (make-vect 0.7 0))
        (lfo1 (make-vect 0.4 0))
        (rfo1 (make-vect 0.6 0))
        (cl (make-vect 0.5 0.3)))
    (list (make-segment lhh lah)
          (make-segment lah lsh)
          (make-segment lsh ln)
          (make-segment ln lfa)
          (make-segment lfa lh)         ;from left hand high to left head
          (make-segment lhl lal)
          (make-segment lal lsl)
          (make-segment lsl lv)
          (make-segment lv lfo)         ;from left hand low to left foot
          (make-segment lfo1 cl)
          (make-segment cl rfo1)        ;from left foot1 to right foot1
          (make-segment rfo rv)
          (make-segment rv rhl)         ;from left foot to right hand low
          (make-segment rhh rs)
          (make-segment rs rn)
          (make-segment rn rfa)
          (make-segment rfa rh)         ;from left hand high left head
          (make-segment lm cm)
          (make-segment cm rm))         ;smile~
    ))
(define wave-p (segments->painter wave))
(paint wave-p)
#+END_SRC

#+RESULTS:
: (object:image-snip% ...)
** Symbolic Data
*** Quotation
**** Exercise 2.53
This is easy stuff to get familized with quote notation
#+BEGIN_SRC scheme
(list 'a 'b 'c)                         ;(a b c)
(list (list 'george))                   ;((george))
(cdr '((x1 x2) (y1 y2)))                ;((y1 y2))
(pair? (car '(a short list)))           ;#f
(memq 'red '((red shoes) (blue socks))) ;#f
(memq 'red '(red shoes blue socks))     ;(red shoes blue socks)
#+END_SRC
**** Exercise 2.54
We can think ~equal?~ procedure as two independent unit:
- check if two arguments are symbols--not list and if it is then delegate to ~eq?~.
- otherwise, it means both are list; delegate this to another helper procedure
  ~eqList?~.


Here we used our old strategy wishful thinking: We haven't ~eqList?~; we defered
to implement it.
#+BEGIN_SRC scheme
(define (equal? s1 s2)
  (or (and (symbol? s1)
           (symbol? s2)
           (eq? s1 s2))
      (eqList? s1 s2)))
#+END_SRC

Then we should implement ~eqList?~. We can design it using the type constrains,
of which Standard ML is good at:
#+BEGIN_SRC sml
fun eqList [] [] = true
  | eqList _ [] = false
  | eqList [] _ = false
  | eqList (x::xs) (y::ys) = (eq x y) andalso (eqList xs ys);
#+END_SRC

We can translate to scheme easily:
#+BEGIN_SRC scheme
(define (eqList? xs ys)
  (cond ((and (null? xs) (null? ys))
         true)
        ((and (not (null? xs)) (null? ys))
         false)
        ((and (null? xs) (not (null? ys))) ;base case
         false)
        (else (and (eq? (car xs) (car ys)) ;recursive case
                   (eqList? (cdr xs) (cdr ys))))))
#+END_SRC
**** Exercise 2.55
Because ~'...~ is just syntatic sugar for ~(quote ...)~. So it is same as
~(quote (quote ...))~. That is, as inner parts of the outermost ~quote~ are
treated symbolically, ~(car (quote ...))~ is ~quote~. There is no surprise here.
*** Example: Symbolic Differentiation
By allowing the symbolic notation in our language, we can cope with algebraic
manipulation symbolically. For simplicity, here we consider only simple
differentiation rules:
- $\frac{dc}{dx} = 0$ for $c$ a constant or a variable different from $x$
- $\frac{dx}{dx} = 1$
- $\frac{\left( u + v \right)}{dx} = \frac{du}{dx} + \frac{dv}{dx}$
- $\frac{\left( uv \right)}{dx} = u \left( \frac{dv}{dx} \right) + v \left(
  \frac{du}{dx} \right)$


Here we delegate implementing of representation of symbolic differentiation
system by using wishful thinking: We just need specify what we want.

First let's try to code ~deriv~ that calculate the derivative of given
expression with respect to ~var~ along with differentiation rules:
#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplicand exp)
                        (deriv (multiplier exp) var))
          (make-product (deriv (multiplicand exp) var)
                        (multiplier exp))))
        (else
         (error "unknown expression type -- DERIV" exp))))
#+END_SRC

Note that we /just/ used all the procedure that we need without implementing
that. Also note that this ~deriv~ procedure coded directly the differential
rules from calculus.

Can we represent the expression that we used in ~deriv~? Yes sure!
#+BEGIN_SRC scheme
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (symbol? v1) (symbol? v2) (eq? v1 v2)))
(define (make-sum a1 a2)
  (list '+ a1 a2))
(define (make-product m1 m2)
  (list '* m1 m2))
(define (sum? s)
  (and (pair? s) (eq? (car s) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? p)
  (and (pair? p) (eq? (car p) '*)))
(define (multiplier p) (cadr p))
(define (multiplicand P) (caddr p))
#+END_SRC

Here we embedded the symbolic expression analogous to lisp's compound
expression--prefix notation.

Let's test this:
#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)                     ;(+ 1 0)
(deriv '(* x y) 'x)                     ;(+ (* x 0) (* 1 y))
(deriv '(* (* x y) (+ x 3)) 'x)         ;(+ (* (+ x 3) (+ (* y 1) (* 0 x))) (* (+ 1 0) (* x y)))
#+END_SRC

Is what we expected? Well, yes and no: The program produces answer that are
correct with respect with the differentiation rules; but it is so verbose. We
need some simplifying steps; we can accomplish this using the analogy to
rational number arithmetic system; we don't need to alter the ~deriv~ procedure,
which uses the constructors and selectors--the lower lever of language.

Let's specify what we exactly expect from the simplification:
- For multiplication
  - $x \times 0 = 0$
  - $y \times 1 = y$
- For summation
  - $x + 0 = 0$


Also we want to fold the constants:
If the two argument of symbolic operation are both number than we calculate
appropriately, i.e.
- ~('+ 5 4)~ should be simplified to ~9~
- ~('* 5 4)~ should be simplified to ~20~


Then we can implement this by amending the low level language.
#+BEGIN_SRC scheme
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (=number? s n)
  (and (number? s) (= s n)))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2))
         (* m1 m2))
        (else (list '* m1 m2))))
#+END_SRC
**** Exercise 2.56
Add the exponentiation to our symbolic algebraic system.
Our differentiation system become
#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplicand exp)
                        (deriv (multiplier exp) var))
          (make-product (deriv (multiplicand exp) var)
                        (multiplier exp))))
        ((exponentiation? exp)
         (make-product (make-product (exponent exp)
                                     (make-exponentiation (base exp) (- (exponent exp) 1)))
                       (deriv (base exp) var)))
        (else
         (error "unknown expression type -- DERIV" exp))))
#+END_SRC
with the representation
#+BEGIN_SRC scheme
(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        ((and (number? base) (number? exponent))
         (expt base exponent))
        (else (list '** base exponent))))

(define (exponentiation? e)
  (and (pair? e) (eq? (car e) '**)))

(define (base ex)
  (cadr ex))

(define (exponent ex)
  (caddr ex))
#+END_SRC
Let's test it:
- The normal differentiation:
  #+BEGIN_SRC scheme
(deriv '(** x 5) 'x)                    ;(* 5 (** x 4))
  #+END_SRC
- Check if it simplify appropriately:
  #+BEGIN_SRC scheme
(deriv '(** x 2) 'x)                    ;(* 2 x)
  #+END_SRC
**** Exercise 2.57
Extend our program to handle sums and product of arbitrary numbers (two or more)
of terms; e.g.
- our last example of test, ~(deriv '(* (* x y) (+ x 3)) 'x)~, can be expressed
  as ~(deriv '(* x y (+ x 3)) 'x)~.


Just amending the lower level of language--constructors and selectors.
Note that the differential rules-- ~deriv~-- doesn't assume that the $v$ is just
symbol; if we can recognize the $v$ part appropriately, we are done.

Here is the idea:
\[\frac{d\left[ u + \left( v + w + \cdots \right) \right]}{dx} = \frac{du}{dx} +
\frac{d\left( v + w + \cdots \right)}{dx}\]
That is, if we can amend ~(augend exp)~ to return ~(+ v w ...)~ then we complete
our mission.

We can code it directly:
#+BEGIN_SRC scheme
(define (augend s)
;; provided that s has more than two number of terms
  (if (null? (cdddr s))
      (caddr s)                         ;it has exactly two terms addend augend.
      (cons '+ (cddr s))))              ;it has more than that
#+END_SRC

Similarly,
#+BEGIN_SRC scheme
(define (multiplicand m)
;; provided that s has more than two number of terms
  (if (null? (cdddr m))
      (caddr m)                         ;it has exactly two terms.
      (cons '* (cddr m))))              ;it has more than that
#+END_SRC

We don't need to fix any of the constructors. We don't like to fix any so that
our construct afford to make expression with arbitrary terms; that only make
things more complicate.
**** Exercise 2.58
The mathematicians want to use infix form instead of prefix form like lisp
expression. Suppose we have to program our differentiation procedure for such
mathematicians; i.e. we have to modify our differentiation program so that it
works with ordinary mathematical notation--infix form.

***** a. binary infix form
Here we consider the infix operator accept only two terms, i.e. binary infix
operator. By experimenting with some examples, we can conclude that in the
correct syntax form of expression, the operator should position at ~cadr~ of it.

Then we can accomplish it by coding that observation:
#+BEGIN_SRC scheme
(define (sum? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (eq? (cadr iexp) '+)))
#+END_SRC

Here we used ~pair?~ twice to assure it will not raise exception when we call
~(cadr iexp)~. It is necessary not to raise exception because the caller of
~sum?~ doesn't know and doesn't need to know the gross detail like whether
~iexp~ satisfy the constraint of representation of ~sum~; they doesn't need to
know the representation of those.

Likewise,
#+BEGIN_SRC scheme
(define (product? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (eq? (cadr iexp) '*)))
#+END_SRC

The selectors can be expressed as follows
#+BEGIN_SRC scheme
(define (addend is) (car is))
(define (augend is) (caddr is))
(define (multiplier im) (car im))
(define (multiplicand im) (caddr im))
#+END_SRC

Similarly, the constructors represented as
#+BEGIN_SRC scheme
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2)) ;↑ simplification
        (else (list a1 '+ a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) ;↑ simplification
         (* m1 m2))
        (else (list m1 '* m2))))
#+END_SRC

The test works well:
#+BEGIN_SRC scheme
(deriv '((x * 5) + (y + 4)) 'x)         ;5
#+END_SRC
***** b. Standard algebraic notation
Now we want to deal with more general case, standard algebraic notation, e.g.
~(x + 3 * (x + y + 2))~, which drops unnecessary parentheses and assumes that
multiplication is done before addition, i.e. multiplication has higher
precedence than addition.

To simplify the task, we develop new language, that is, the semantics of
standard algebraic notation. We can be rephrased as add new layer under the
representation; or to layer out between semantics and syntax.

First let's experiment with some examples:
~((x + y) * 5 * z)~, ~(x * y + (z + y) * 5)~

We can reconstruct using tree representation. Unfortunately I myself don't know
yet how to print the tree figure here[fn:1]; so I've drew these in my personal
note. Well, anyway there is one way to represent the tree structure in text:
Lisp! As said in text or lecture of SICP, we can represent the tree as list!
If we do that now, we obtain following results:
- ~(* (+ x y) 5 z)~ or ~(* (+ x y) (* 5 z))~
- ~(+ (* x y) (* (+ z y) 5))~


Note that in the first example we can represent in both, binary tree or tree
with arbitrary branches. Also note that this situation exactly match with the
previous exercise, [[Exercise 2.57][ex 2.57]].

Consequently, all we need to do is to convert infix form to prefix form allowed
to have arbitrary number of terms; the rest would be handled by ex 2.57 as said.

Then how? Again by wishful thinking assume that all the subtrees are constructed
appropriately. Let's try out.

If ~(car exp)~ is compound data, then delegate it to subtree constructor and
also we know that if it is correct infix form the ~(cadr exp)~ is
operator[fn:2]. Now we can construct whole tree by delegating the ~(cddr exp)~
and then constructing ~((cadr exp) sub1 sub2)~.

We constructed the abstract design of our code. The thing is, is it correct?
No, it isn't! The second example shows why it is; we have not considered the
precedence relation appropriately! To cope with it, we have to build the whole
tree either when we encounter with the lowest precedence operator or when we
get faced with last operator of expression at the top level.

This time, it works! How can we be sure? Can we prove it? Well, at least it is
worth to prove for practice or because it is not obvious; yet we are left with
long way to go. Let's consider that first. We've built the so called AST--
Abstract Syntactic Tree. Are we good to go and code this idea? Unfortunately no;
there is something we missed: The selectors that used by ~deriv~ should return
infix form not the prefix form as AST.

That is, this time, we have to linger over the opposite way than we have
constructed so far: To convert from AST to infix form. Here we also use the
wishful thinking in recursive case: The subtrees are constructed for us; the
rest is to deal with at the very top level.

For simplicity, let we ignore the unnecessary parentheses, i.e. we don't have to
omit the verbose parenthesis for conciseness when we convert to infix form. Then
we can easily do the task: ~(cov-sub1 op cov-sub2)~

Yeah It was quite long way to accomplish this! We did the design things! All the
left is to code it!

If we code that directly without further design--naive approach, then we get
#+BEGIN_SRC scheme
(define (->AST iexp)
  (define (constructor left stack)
    (let ((op (cadr left)))
      (cond ((or (lowest? op) (last? op left))
             (list op
                   (->AST (cons (car left) stack))
                   (->AST (cddr left))))
            (else (constructor
                   (cddr left)
                   (cons op
                         (cons (car left)
                               stack)))))))
  (cond ((null? (cdr iexp))             ;in the top level, it appears as singlton expression
         (if (pair? (car iexp))
             (->AST (car iexp))         ;compound expression
             (car iexp)))               ;singleton
        (else (constructor iexp '()))))

(define (lowest? op)
  (and (symbol? op) (eq? op '+)))
(define (last? op left)
  (and (symbol? op) (null? (cdddr left))))
#+END_SRC

We can test it; it works:
#+BEGIN_SRC scheme
;; test
(->AST '((x + y) * 5 * z))              ;(* (* 5 (+ x y)) z)
(->AST '(x * y + (z + y) * 5))          ;(+ (* y x) (* (+ z y) 5))
#+END_SRC

The reverse process can be coded likely:
#+BEGIN_SRC scheme
(define (->infix ast)
  (cond ((not (pair? ast)) ast)         ;base case
        (else (list (->infix (cadr ast)) ;recursive case
                    (car ast)
                    (->infix (caddr ast))))))
#+END_SRC

It also works:
#+BEGIN_SRC scheme
(->infix (->AST '((x + y) * 5 * z)))    ;((5 * (x + y)) * z)
#+END_SRC

With those, we can complete the code:
#+BEGIN_SRC scheme
(define (sum? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (let ((ast (->ast iexp)))
         (eq? (car ast) '+))))

(define (product? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (let ((ast (->ast iexp)))
         (eq? (car ast) '*))))

(define (addend iexp)
  (let ((ast (->ast iexp)))
    (->infix (cadr ast))))

(define (augend iexp)
  (let ((ast (->ast iexp)))
    (->infix (caddr ast))))

(define (multiplier iexp)
  (let ((ast (->ast iexp)))
    (->infix (cadr ast))))

(define (multiplicand iexp)
  (let ((ast (->ast iexp)))
    (->infix (caddr ast))))
#+END_SRC

The constructor should work as *a.* without modification.

Let's test it:
#+BEGIN_SRC scheme
(deriv '(x + 3 * (x + y + 2)) 'x)       ;4
(deriv '((x + y) * 5 * z) 'x)           ;(z * 5)
(deriv '(x * y + (z + y) * 5) 'x)       ;y
#+END_SRC

It works well. Phew, we did it.

# Or I've realized that actually it suffice to convert the infix form to prefix
# only at the very top level. If you see the code or example, I think, you got what
# I meant:
# #+BEGIN_SRC scheme
# (define (->pseudoAST iexp)
#   (define (constructor left stack)
#     (let ((op (cadr left)))
#       (cond ((or (lowest? op) (last? op left))
#              (cons op
#                    (cons (cons (car left) stack)
#                          (cddr left))))
#             (else (constructor
#                    (cddr left)
#                    (cons op
#                          (cons (car left)
#                                stack)))))))
#   (if (null? (cdr iexp))
#       (car iexp)
#       (constructor iexp '())))
# #+END_SRC

# And here are the example (or tests):
# #+BEGIN_SRC scheme
# (->pseudoAST '((x + y) * 5 * z))        ;(* (5 * (x + y)) z)
# (->pseudoAST '(x * y + (z + y) * 5))    ;(+ (y * x) (z + y) * 5)
# #+END_SRC

# We have shortcut transforming to AST and back to infix form by this. With this,
# we can easily implement rest:
# - The predicates
#   #+BEGIN_SRC scheme
# (define (sum? iexp)
#   (and (pair? iexp)
#        (pair? (cdr iexp))
#        (let ((pAST (->pseudoAST iexp)))
#          (eq? (car pAST) '+))))

# (define (product? iexp)
#   (and (pair? iexp)
#        (pair? (cdr iexp))
#        (let ((pAST (->pseudoAST iexp)))
#          (eq? (car pAST) '*))))
#   #+END_SRC
# - The selectors
# #+BEGIN_SRC scheme
# (define (addend is)
#   (let ((pAST (->pseudoAST is)))
#     (cadr is)))
# (define (augend is)
#   (let ((pAST (->pseudoAST is)))
#     (cddr is)))
# (define (multiplier im)
#   (let ((pAST (->pseudoAST is)))
#     (cadr im)))
# (define (multiplicand im)
#   (let ((pAST (->pseudoAST is)))
#     (cddr im)))
# #+END_SRC
# - The constructors are same as part *a.*

# ↑ doesn't work. I should have not cheat this.

Well, we did it, but we did not include the exponentiation expression. Our
standard infix form should accommodate that expression? Although the statement
of this exercise did not mention it, isn't it cool if we can handle the
exponentiation? If we can accomplish that thing, we can extend further more!

First we need to redesign our ~->AST~ procedure. It is possible to cope with
exponentiation just modifying our existing procedure; but the result would be
quite mess--hard to recognize and maintain, no logic behind, etc.

****** Try: Let we assume there are specialist who can only handle specific operation.
For instance, ~expt->AST~ can convert only exponentiation to AST and so on.

The flow of overall ~->AST~ procedure can be described as
#+BEGIN_SRC text
infix form => inital setup + handle base case => expt->AST => prod->AST
=> sum->AST => AST(output)
#+END_SRC

We can specify the ~<??>->AST~'s behavior:
- should take infix form with partially built AST.
- should return partially built AST whit rest infix form where the first
  operation is not ~<??>~.


So, for example, the output of ~expt->AST~ should satisfy that its first ~op~ is
either ~+~ or ~*~ (or no operation left in infix form); by the same argument,
when it comes to ~sum->AST~ the first ~op~ should ~+~ (or as mentioned no more
operation).

Let we code it:
#+BEGIN_SRC scheme
(define (->AST iexp)
  (cond ((not (pair? iexp))             ;symbol--singleton
         iexp)
        ((null? (cdr iexp))             ;eof mark
         (if (pair? (car iexp))
             (->AST (car iexp))         ;turns out compound exp
             (car iexp)))               ;it was singleton
        (else (expt->AST (cdr iexp) (->AST (car iexp)))))) ;recursive process
(define (expt->AST iexp AST)
  (cond ((null? iexp) AST)              ;eof
        ((and (symbol? (car iexp))
              (eq? (car iexp) '**))
         (expt->AST (cddr iexp) (list '** AST (->AST (cadr iexp)))))
        (else (prod->AST iexp AST))))
(define (prod->AST iexp AST)
  (cond ((null? iexp) AST)
        ((and (symbol? (car iexp))
              (eq? (car iexp) '*))
         (prod->AST (cddr iexp) (list '* AST (->AST (cadr iexp)))))
        (else (sum->AST iexp AST))))
(define (sum->AST iexp AST)
  (cond ((null? iexp) AST)
        ((and (symbol? (car iexp))
              (eq? (car iexp) '+))
         (list '+ AST (->AST (cdr iexp))))))
#+END_SRC

The results:
#+BEGIN_SRC scheme
(->AST '(x + 3 * (x + y + 2)))          ;(+ x (* 3 (+ x (+ y 2))))
(->AST '(x ** 4 * (x * 2 + y + 2)))     ;(* (** x 4) (+ (* x 2) (+ y 2)))
#+END_SRC

Works well!

The rest are the predicate, selectors and constructors of exponentiation, which
can be accomplished using analogy with others:
#+BEGIN_SRC scheme
(define (exponentiation? iexp)
  (and (pair? iexp)
       (pair? (cdr iexp))
       (let ((ast (->ast iexp)))
         (eq? (car ast) '**))))

(define (base iexp)
  (let ((ast (->ast iexp)))
    (->infix (cadr ast))))

(define (exponent iexp)
  (let ((ast (->ast iexp)))
    (->infix (caddr ast))))

(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        ((and (number? base) (number? exponent))
         (expt base exponent))
        (else (list base '** exponent))))
#+END_SRC

Let's test our last piece:
#+BEGIN_SRC scheme
(deriv '(x ** 4 * (x * 2 + y + 2)) 'x)
;;((((x * 2) + (y + 2)) * (4 * (x ** 3))) + (2 * (x ** 4)))
#+END_SRC

Done.

#  LocalWords:  AST
*** Example: Representing Sets
We can abstract out the representation of set by using data abstraction: As long
as we have ~union-set~, ~intersection-set~, ~element-of-set?~, and ~adjoin-set~
we can do anything as with normal set. Those procedures can be thought as
interface of object set or axioms of set:
- ~(element-of-set? x (union-set S1 S2))~ is equivalent to
  ~(or (element-of-set? x S1) (element-of-set? x S2)~
- ~(element-of-set? x (intersection-set S1 S2))~ is equivalent to
  ~(and (element-of-set? x S1) (element-of-set? x S2)~
- For any element ~x~ and set ~S~, ~(element-of-set? x (adjoin-set x S))~ is ~true~


All the representation that satisfy all the axioms above can be treat as set.

**** Sets as unordered lists
Here we represent a set as list of its elements in which no element appears more
than once. As we are going to represent sets as ordered lists, we name this
representation as unordered list representation.

As we mentioned ~adjoin-set~ should adjoin member if and only if member is not
already ~element-of-set?~:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
#+END_SRC

Then ~element-of-set?~ get straightforward:
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
#+END_SRC

For the ~intersection-set~ we can rely on induction on either of each arguments:
#+BEGIN_SRC scheme
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
#+END_SRC
**** Exercise 2.59
Finally, ~union-set~ can be implemented as append-like procedure:
#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        (else (adjoin-set (car set1)
                          (union-set (cdr set1) set2)))))
#+END_SRC
This procedure has \Theta(n^{2}) step complexity as ~intersection-set~.
**** Exercise 2.60
What if we represent a set as a list allowed to be duplicate? We don't need to
check if the member already in the given set to adjoin:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (cons x set))
#+END_SRC

And others doesn't have to change at all but the complexity change. As
~adjoin-set~ became \Theta(1) of step complexity, ~union-set~, which depends on
~adjoin-set~, get to have \Theta(n) of step complexity, where n is the size of ~set1~.

The complexity of the others-- ~element-of-set?~, ~intersection-set~-- doesn't
change at all but now the concept of size of set has changed; although it is
same along with the specification, the size of it can depend on representation,
e.g. ~{1,2,1,1,1,1}~ has two member in it--1,2-- and also it is ~{1,2}~ but
those differ in size--6, 2 respectively.

If we use ~adjoin-set~ (and ~union-set~) a lot and sarcely ~element-of-set~ (or
~intersection-set~) then current version would be more efficient than previous
one, vice versa.
**** Sets as ordered lists
To simplify our discussion, we consider only the case where the set elements are
numbers. This section is well documented in text book. So we just jot down
necessary procedures here:
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) false)
        (else (element-of-set? x (cdr set)))))

(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1))
            (x2 (car set2)))
        (cond ((= x1 x2) (cons x1 (intersection-set (cdr set1)
                                                    (cdr set2))))
              ((< x1 x2) (intersection-set (cdr set1) set2))
              ((> x1 x2) (intersection-set set1 (cdr set2)))))))
#+END_SRC
**** Exercise 2.61
We know that if the member, which we are about to adjoin in given set, is
smaller then the ~(car set)~ then the member are not contained in given set;
if the member equals to ~(car set)~ then we don't have to do anything,
else we should look up the ~cdr~ of set recursively. Then we end up with
base case--nil of set; we just ~cons~ our member with nil:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (if (null? set)
      (list x)
      (let ((hd (car set)))
        (cond ((< x hd) (cons set))
              ((= x hd) set)
              (else
               (adjoin-set x (cdr set)))))))
#+END_SRC
**** Exercise 2.62
To give \Theta(n) growth ~union-set~, we exploit the idea behind the
~intersection-set~. I've got quite bored with jotting down all the rules that
governs the algorithm; as this implementation is straightforward, let me just
show them:
#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (let ((x1 (car set1))
              (x2 (car set2)))
          (cond ((= x1 x2) (cons x1 (union-set (cdr set1) (cdr set2))))
                ((< x1 x2) (cons x1 (union-set (cdr set1) set2)))
                ((> x1 x2) (cons x2 (union-set set1 (cdr set2))))))))
#+END_SRC
**** Sets as binary trees
Here we represent sets as binary trees--composed by entry, left branch, right
branch. In turns, we have to represent the binary tree which satisfy following
axioms:
- ~(entry (make-tree entry left right))~ equals to ~entry~
- ~(left-branch (make-tree entry left right))~ equals to ~left~
- ~(right-branch (make-tree entry left right))~ equals to ~right~


Here is one of representation that satisfy above axioms:
#+BEGIN_SRC scheme
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
#+END_SRC

Given with above, we can write ~element-of-set?~ procedure:
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (if (null? set)
      false
      (let ((hd (entry set)))
        (cond ((= x hd) true)
              ((< x hd) (element-of-set? x (left-branch set)))
              ((> x hd) (element-of-set? x (right-branch set)))))))
#+END_SRC

For the ~adjoin-set~ we recursively branching down the tree whether entry is
equals to given member or not; if there is no such entry, it end up with empty
tree, at that point, we should construct new tree and put the all pieces
together appropriately:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (if (null? set)
      (make-tree x '() '())
      (let ((hd (entry set)))
        (cond ((= x hd) set)
              ((< x hd) (make-tree hd
                                   (adjoin-set x (left-branch set))
                                   (right-branch set)))
              ((> x hd) (make-tree hd
                                   (left-branch set)
                                   (adjoin-set x (right-branch set))))))))
#+END_SRC
**** Exercise 2.63
#+BEGIN_SRC scheme
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
  (copy-to-list tree '()))
#+END_SRC
***** a.
We prove both produce the same result-- ordered list.
For the former, we can prove the assertion by induction on the depth of tree.
For the latter, we prove the assertion by using the invariance that
~copy-to-list~ returns ordered list of given tree with appending the
~result-list~ at the end.

As consequence, the figure 2.16 end up with ~(1 2 3 4 5 6 7)~.
***** b.
For the former, if we estimate the size of input as number of entries of tree,
then we get the following differential equation:
\[f \left( n \right) - 2 f \left( n/2 \right) = \Theta \left( n/2 \right)\],
which end up with
\[f \left( n \right) = \Theta(n) + \Theta (n \log n)\].
As consequence, we got $\Theta(n \log n)$ step complexity.

For the latter, it becomes
\[ f(n) - 2 f(n/2) = \Theta (1) \];
it can be concluded as
\[f(n) = \Theta(n) + \Theta(\log n) = \Theta(n)\], i.e. $\Theta(n)$ step complexity.
**** Exercise 2.64
#+BEGIN_SRC scheme
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+1 left-size))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts)
                                              right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
#+END_SRC
***** a.
The ~partial-tree~'s behavior is as follows
- given with ordered list ~elts~ it returns pair that contains balanced tree
  with first ~n~ elements from the ~elts~ with ordered list but first ~n~ elements.


This is just specification that we want to implement for ~list->tree~. Then how
to implement it? We have the powerful strategy, wishful thinking:
Let we assume that for all inputs that has less than ~n~ ~partial-tree~
implemented by John. Our task is to complete the ~partial-tree~ for the inputs
with ~n~. Here is the idea:
1. First, build the left half tree with the ~elts~.
2. And then, take one element from the remaining ~elts~ from step 1.
3. Using the rest elements construct right half tree.
4. Build whole tree using ~make-tree~ with above left tree, entry, right tree
   from 1, 2, 3, respectively.
5. Returns pair consisting the tree built from step 4 with remaining elements
   from step 3.


The straightforward implementation is shown above. Note that we used for the
~left-size~ since we have to satisfy the relation-- $n - 1 \ge 2 ~\text{left-size}$.
***** b.
Analogous to [[Exercise 2.63][previous exercise]], we can deduce that the order of growth of this
implementation is \Theta(n).
**** Exercise 2.65
***** ~intersection-set~
After I've played with some examples, I concluded that the ordered list version
of it is quite ideal implementation than using tree. Given with exercise 2.63,
we can revert the (balanced) tree to ordered list.

Then we simply put together all the modules:
#+BEGIN_SRC scheme
(define (intersection-set set1 set2)
  (let ((ol1 (tree->list-2 set1))
        (ol2 (tree->list-2 set2)))
    (list->tree (intersection-setl ol1 ol2))))
#+END_SRC
Here I rephrase the previous version of ~intersection-set~ as
~intersection-setl~ for denoting ordered list.

Similarly, we can do same thing to ~union-set~:
#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (let ((ol1 (tree->list-2 set1))
        (ol2 (tree->list-2 set2)))
    (list->tree (union-setl ol1 ol2))))
#+END_SRC

These have all \Theta(n) order of growth.
**** Exercise 2.66
As we know that ~lookup~ is analogous to ~element-of-set?~, here also we can
implement using that observation:
#+BEGIN_SRC scheme
(define (lookup given-key set)
  (if (null? set)
      false
      (let ((hd (key (entry set))))
        (cond ((= given-key hd) true)
              ((< given-key hd) (lookup given-key (left-branch set)))
              ((> given-key hd) (lookup given-key (right-branch set)))))))
#+END_SRC
*** Example: Huffman Encoding trees
**** Representing Huffman trees
Here we represent Huffman tree as weighted tree. The leaf can be represented as
#+BEGIN_SRC scheme
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
#+END_SRC

A general tree will be a list of left branch, a right branch, a set of symbols,
and as weight. The set of symbols will be simply a list of the symbols, which
contains all the symbols of leaves under the tree. And weight will be number
which indicate sum of leaves' weights under the tree. As I noted before, the
~append~ operation is very similar to ~union~. Here, as we represent the set of
symbols as just list, we can get the behavior of ~union~ using ~append~:
#+BEGIN_SRC scheme
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))
#+END_SRC

The other interface procedures determined by this representation:
#+BEGIN_SRC scheme
(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
#+END_SRC
**** The decoding procedure
Given bits with Huffman tree, we can start decode with each bit from the
leftmost bit to determine how to choose next branch in the tree. If we
encountered with leaf, then it means we decoded one symbol in message.
Repeatedly decoding the symbols, and accumulating the symbols in list, we
complete the decoding process. It is natural to decompose this decoding
procedure to decoding one symbol, procedure to choose branch with the current
bit and branch of tree, accumulating the result symbols and determining
termination condition. Here is one possible implementation:
#+BEGIN_SRC scheme
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bat bit -- CHOOSE-BRANCH" bit))))
#+END_SRC

Here we merged somehow decode one symbol with accumulating & terminating; we
found that it is way more concise than bothering to decompose with the described
fashion.
**** Sets of weighted elements
The tree-generating algorithm requires to choose smallest nodes in the set. To
do this, it is more convenient to represent a set as an ordered list as we did
before. However, in this situation, provided that the element being adjoined to
the set is not in the set. Using this fact we can ~adjoin-set~ more efficiently:
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
#+END_SRC

Using this, we can construct the ordered list of pairs, which contains symbol
with frequency:
#+BEGIN_SRC scheme
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair) ;symbol
                               (cadr pair)) ;frequency
                    (make-leaf-set (cdr pairs))))))
#+END_SRC
**** Exercise 2.67
#+BEGIN_SRC scheme
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
;; test
(decode sample-message sample-tree)     ;(a d a b b c a)
#+END_SRC
**** Exercise 2.68
The ~encode~ process can be decomposed as
#+BEGIN_SRC scheme
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
#+END_SRC

Then we should implement the ~encode-symbol~ procedure that encode one symbol as
sequence of bits. This procedure also should raise exception when there is not
such symbol in the tree. We can deduce the algorithm by playing with it:
1. Test whether the symbol included in tree.
2. If not raise error, else choose next branch that contains given symbol.
3. If we get all the way down to the leaf (which also contains given symbol by
   contract) return the accumulated bits.


When we code this algorithm, we get
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

(define (encode-symbol symbol tree)
  (define (encode-1 current-branch)
    (if (leaf? current-branch)
        '()
        (if (element-of-set? symbol
                             (symbols (left-branch current-branch)))
            (cons 0
                  (encode-1 (left-branch current-branch)))
            (cons 1
                  (encode-1 (right-branch current-branch))))))
  (if (not (element-of-set? symbol (symbols tree)))
      (error "bad symbol -- ENCODE-SYMBOL" symbol)
      (encode-1 tree)))
;; test
(encode (decode sample-message sample-tree) sample-tree) ;(0 1 1 0 0 1 0 1 0 1 1 1 0)
#+END_SRC
**** Exercise 2.69
I've designed in my personal note. The result:
#+BEGIN_SRC scheme
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successive-merge leaf-set)     ;provided that leaf-set is list
  (cond ((null? leaf-set) '())
        ((null? (cdr leaf-set)) (car leaf-set)) ;termination condition
        (else                                   ;provided that it has atleast 2 leaves in this
         (let ((leaf1 (car leaf-set))
               (leaf2 (cadr leaf-set))
               (rest-set (cddr leaf-set)))
         (successive-merge (adjoin-set (make-code-tree leaf1 leaf2)
                                       rest-set))))))
;;test
(define sample-pairs '((A 4) (B 2) (C 1) (D 1)))
(decode sample-message (generate-huffman-tree sample-pairs)) ;(a d a b b c a)
#+END_SRC
**** Exercise 2.70
If we do the instructions, we get
#+BEGIN_SRC scheme
(define rock-pairs '((A 2) (BOOM 1) (GET 2) (JOB 2) (NA 16) (SHA 3) (YIP 9) (WAH 1)))
(define rock-tree (generate-huffman-tree rock-pairs))
(define rock-message '(Get a job
                           Sha na na na na na na na na
                           Get a job
                           Sha na na na na na na na na
                           Wah yip yip yip yip yip yip yip yip yip
                           Sha boom))
(define rock-code (encode rock-message rock-tree))
(length rock-code)                      ;84
#+END_SRC

In Huffman encoding, we need 84 bits for encoding the message. If we have used
fixed-length code for eight-symbol alphabet--we need at least 3 bits per
symbol, we get ~(* 3 (length rock-message))~ that evaluated to 108. We saved
about 22% bits for encoding the message.
**** Exercise 2.71
We can prove by induction on /n/ or on depth of tree that the most frequent
symbol requires 1 bit to encode and for the least frequent one /n-1/ bits.
**** Exercise 2.72
For the given special case, we can prove that for the most frequent one the
order of growth is \Theta(n) and for the least frequent one \Theta(n^{2}) at the
worst case.
*** Data-Directed Programming and Additivity
**** Exercise 2.73
We can convert the symbolic differentiation system to data-directed style:
#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp)) (operands exp) var))))

(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
#+END_SRC
***** a.
Here we recognized the ~exp~ as typed datum as being discussed in this section,
i.e. we found that we use operator only for determining the /type/ of procedure
to be applied at operands; this is exactly what we discussed so far. Note that
we handle the number and variable case explicitly because they aren't attached a
type-- just contents. And also if we strugle to attach auxilary type to those,
our code got cluttered more than present one.

To summarize, ~deriv~ procedure do
1. Check the ~exp~ is number or variable and do the right thing for that
2. If it isn't that means it's compound expression, on which attached type. So
   ~deriv~ look up the table with operation name-- ~deriv~-- and expression
   type-- ~operator~ to get appropriate procedure for that expression.
3. Then apply that procedure given arguments-- ~operands~ with respect to ~var~.
***** b.
We can accomplish this by using analogy with the complex number representation.
Here we decide to use operator's symbol as type consistently:
#+BEGIN_SRC scheme
(define (install-sum--package)
  ;; constructor
  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (list '+ a1 a2))))
  ;; selectors
  (define (addend operands) (car operands))
  (define (augend operands) (cadr operands))
  ;; interface to the rest of the system.
  (put 'make '+ make-sum)
  (put 'addend '+ addend)
  (put 'augend '+ augend)
  ;; For differential algebraic system.
  (put 'deriv '+
       (lambda (operands var) (make-sum (deriv (addend operands) var)
                                        (deriv (augend operands) var))))
  'done)

(define (install-product-package)
  ;;constructor
  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2))
           (* m1 m2))
          (else (list '* m1 m2))))
  ;;selectors
  (define (multiplier p) (car p))
  (define (multiplicand p) (cadr p))
  ;; interface to the rest of the system.
  (put 'make '* make-product)
  (put 'multiplier '* multiplier)
  (put 'multiplicand '* multiplicand)
  ;; For differential algebraic system
  (put 'deriv '*
       (lambda (operands var)
         ((get 'make '+)
          (make-product (multiplier operands)
                        (deriv (multiplicand operands) var))
          (make-product (deriv (multiplier operands) var)
                        (muliplicand operands)))))
  'done)
#+END_SRC
***** c.
To add some additional differentiation rule, all we need to do is to install
that specific package, anything else not affected by that:
#+BEGIN_SRC scheme
(define (install-exponentiation-package)
  ;; constructor
  (define (make-exponentiation base exponent)
    (cond ((=number? exponent 0) 1)
          ((=number? exponent 1) base)
          ((and (number? base) (number? exponent))
           (expt base exponent))
          (else (list '** base exponent))))
  ;; selectors
  (define (base ex)
    (car ex))

  (define (exponent ex)
    (cadr ex))

  ;; differentiation
  (define (deriv-expt operands var)
    (let ((make-product (get 'make '*)))
      (make-product (make-product (exponent operands)
                                  (make-exponentiation (base operands) (- (exponent operands) 1)))
                    (deriv (base operands) var))))
  ;; interface
  (put 'make '** make-exponentiation)
  (put 'base '** base)
  (put 'exponent '** exponent)
  (put 'deriv '** deriv-expt)
  'done)
#+END_SRC
***** d.
If we changed our mind from
#+BEGIN_SRC scheme
...
        (else ((get 'deriv (operator exp)) (operands exp) var))))
...
#+END_SRC
to
#+BEGIN_SRC scheme
...
        (else ((get (operator exp) 'deriv) (operands exp) var))))
...
#+END_SRC

Then, in our implementation, we need change all the code in each package
according to that change:
#+BEGIN_SRC scheme
(define (install-sum-package)
...
(put '+ 'deriv ...)
...
 'done)
(define (install-product-package)
...
(put '* 'deriv ...)
...
 'done)
(define (install-exponentiation-package)
...
(put '** 'deriv ...)
...
 'done)
#+END_SRC
**** Exercise 2.74
We can solve the problem by using the table which contains all the employee's
recode from all the division. As noted in the text, as the data representation
all different from division to division, to use data-directed programming, these
individual division's personal file should have type tag that indicate specific
division. Further more, we can assume that in the specific division they know
how to retrieves a specified employee's record-- as mentioned in the statement
the employee's name would be supplied for specifying.

***** a.
We can think of ~get-record~ take personal file with employee's name specified
for its arguments and then take off the type tag-- division-- from personal
file to retrieve:
#+BEGIN_SRC scheme
(define (get-record record-file employee-name)
;; we assume that each file has division name as its type.
  (let ((division (type-tag record-file)))
    ((get 'get-record division) employee-name)))
#+END_SRC

Here we assume that each division /put/ the procedure to retrieve their
employee's record in that division to table; we can ~get~ that procedure.

More formally we only require that
- each division should attach their record file type tag, which specify their division.
- each division should register their own method for retrieving specific
  employee's record with universal key, employee's name.


As long as those specification satisfied, how the recored structured do not
affect above implementation.
***** b.
By the same argument with *a.*, to select specific information from given
record we should know the division to which the employee belong. So to speak,
each record should have division information as its type.

#+BEGIN_SRC scheme
(define (get-salary record)
  (let ((division (type-tag record)))
    ((get 'get-salary division) record)))
#+END_SRC

It's not our business but if ~get-record~ attach division as type to its return
value-- record, we don't need to modify any code in individual division file to
work with above procedure.
***** c.
Here we only consider one record; it is possible that some employees have same
name, but we do not consider that: as soon as we find record with name given, we
only return that one.

Here we exploit the fact that any scheme data treated as true when it used with
boolean operation:
#+BEGIN_SRC scheme
(or false 0 5)                          ;0
(and true 5)                            ;#t
#+END_SRC

Using this fact, we can implement the given task:
#+BEGIN_SRC scheme
(define (find-employee-record division-files employee-name)
  (fold-left (lambda (x y) (or x y))
             false
             (map (lambda (division-file)
                    (get-record division-file employee-name))
                  division-files)))
#+END_SRC

Note that we assumed ~get-record~ return false if it couldn't find one.
***** d.
To incorporate with the other division, the new division should
- attach its own division name to its personal record file,
- register its own procedure which retrieves its employee's record to the lookup
  table,
- also put procedure that retrieves some information from record data to the
  lookup table.


That's it. It doesn't matter how many the employee's records under that division.
Cool!
**** Message passing
I found this section discuss the skeleton of modern object oriented programming.
To consider how it connected to OOP, we should keep learning the remaining
chapters in it, but I've felt this methodology, message passing, is the most
simple object that contains all the operations that operate on given object. We
can consider the constructor of object as somewhat analogous to class
declaration:
#+BEGIN_SRC scheme
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'manitude)
           (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else
           (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
  dispatch)
#+END_SRC
**** Exercise 2.75
We can do the same thing to ~make-from-mag-ang~ as above:
#+BEGIN_SRC scheme
(define (make-from-mag-ang r a)
  (define (dispatch op)
    (cond ((eq? op 'real-part) (* r (cos a)))
          ((eq? op 'imag-part) (* r (sin a)))
          ((eq? op 'manitude) r)
          ((eq? op 'angle) a)
          (else
           (error "Unknown op -- MAKE-FROM-MAG-ANG" op))))
  dispatch)
#+END_SRC
**** Exercise 2.76
We can characterizes the three strategies as following:
- /data directed programming/ :: dealing with table, i.e. 2 dimensional. We can
     add arbitrary operation or type (data) on the table without interfering
     existing code.
- /dispatch on type/ :: dealing with operation row. Each of the operation can be
     thought as individual entity. We can add new operation without altering
     existing code.
- /message passing/ :: dealing with type (data) column. Each of data can be
     thought as object which has operations that operate on it. We can add new
     data (type) additively.


With these information, we are likely to think /data directed programming/ is
most ideal strategies to deal with big project. However, it has another edge: As
it allow maximum flexibility, the individual cells in the table get likely to
lack of connectivity. For instance, when we modeling the real world object, it
is more intuitive to implement using OOP (in this context, /message passing/).

I've demonstrated enough to answer the given question: For system in which new
types must often be added, /message passing/ would be the best choice, whereas
for system in which new operations must often be added /dispatch on type/ or
/data directed programming/ both can be good choice as we seen in the complex
number system. If you could not determine how your system would evolves then
give /data directed programming/ a shot; it will answer to you.

Or OOP can be thought as the one that takes both advantages of using type and the
intuitive representation of /message passing/.
*** Lecture 4A: Pattern Matching and Rule-based Substitution
In this lecture, the professor discuss the pattern matching algorithm in
general. I think it is main feature of all the functional programming language
such as Haskell, ML, Scala, and so on. In their language-- especially Scala,
which I've used commercially-- user also can add arbitrary pattern variable by
using special notation-- case class in Scala. These feature is the instance of
application of /data-directed programming/ so that we can modify the compiler's
behavior seamlessly.

We can introduce pattern matching feature by ourself:
#+BEGIN_SRC scheme
(define (match pat exp dict)
  (cond ((eq? dict 'failed) 'failed)
        ((not (pair? pat))
         (if (not (pair? exp))
             (if (eq? pat exp)
                 dict
                 'failed)
             'failed))
        ((arbitrary-constant? pat)
         (if (constant? exp)
             (extend-dictionary pat exp dict)
             'failed))
        ((arbitrary-variable? pat)
         (if (variable? exp)
             (extend-dictionary pat exp dict)
             'failed))
        ((arbitrary-expression? pat)
         (extend-dictionary pat exp dict))
        ((not (pair? exp)) 'failed)
        (else
          (match (cdr pat)
                 (cdr exp)
                 (match (car pat)
                        (car exp)
                        dict)))))

(define (arbitrary-constant? pat)
  (and (pair? pat) (eq? (car pat) '?c)))

(define (arbitrary-variable? pat)
  (and (pair? pat) (eq? (car pat) '?v)))

(define (arbitrary-expression? pat)
  (and (pair? pat) (eq? (car pat) '?)))

(define (constant? exp)
  (number? exp))

(define (variable? exp)
  (symbol? exp))

(define (instantiate skeleton dict)
  (define (loop s)
    (cond ((not (pair? s)) s)
          ((skeleton-evaluation? s)
           (evaluate (eval-exp s) dict))
          (else (cons (loop (car s))
                      (loop (cdr s))))))
  (loop skeleton))

(define (skeleton-evaluation? s)
  (and (pair? s) (eq? (car s) ':)))

(define (eval-exp s)
  (cadr s))

(define (simplifier the-rules)
  ; (define (simplify-exp exp)
  ;   (try-rules (if (compound? exp)
  ;                  (simplify-parts exp)
  ;                  exp)))
  ; (define (simplify-parts exp)
  ;   (if (null? exp)
  ;       '()
  ;       (cons (simplify-exp (car exp))
  ;             (simplify-parts (cdr exp)))))
  ;; Another idiom
  (define (simplify-exp exp)
    (try-rules
      (if (compound? exp)
          (map simplify-exp exp)
          exp)))
  (define (try-rules exp)
    (define (scan rules)
      (if (null? rules)
          exp
          (let ((dict
                  (match (pattern (car rules))
                         exp
                         (empty-dictionary))))
            (if (eq? dict 'failed)
                (scan (cdr rules))
                (simplify-exp
                  (instantiate
                    (skeleton (car rules))
                    dict))))))
    (scan the-rules))
  simplify-exp)

(define (pattern rule)
  (car rule))

(define (skeleton rule)
  (cadr rule))

(define (compound? exp) (pair? exp))

(define (evaluate form dict)
  (if (not (pair? form))
      (lookup form dict)
      (apply
        (eval (lookup (car form) dict)
              user-initial-environment)
        (map (lambda (v)
                  (lookup v dict))
                (cdr form)))))

(define (empty-dictionary) '())

(define (extend-dictionary pat dat dict)
  (let ((name (variable-name pat)))
    (let ((v (assq name dict)))
      (cond ((not v)
             (cons (list name dat) dict))
            ((eq? (cadr v) dat) dict)
            (else 'failed)))))

(define (variable-name pat)
  (cadr pat))

(define (lookup var dict)
    (let ((v (assq var dict)))
      (if (not v) var (cadr v))))

;; (cdr '(x . y))                          ;y

(define deriv-rules
  '(
    ( (dd (?c c) (? v))         0           )
    ( (dd (?v v) (? v))         1           )
    ( (dd (?v u) (? v))         0           )

    ( (dd (+ (? x1) (? x2)) (? v))
      (+ (dd (: x1) (: v))
         (dd (: x2) (: v)))                 )
    ( (dd (* (? x1) (? x2)) (? v))
      (+ (* (: x1) (dd (: x2) (: v)))
         (* (dd (: x1) (: v)) (: x2)))      )
    ))

(define algebra-rules
  '(
    (((? op) (?c e1) (?c e2))
     (: (op e1 e2)))
    (((? op) (? e1) (?c e2))
     ((? op) (: e2) (: e1)))
    ((+ 0 (? e))
     (: e))
    ((* 1 (? e))
     (: e))
    ((* 0 (? e))
     0)
    ((* (?c e1) (* (?c e2) (? e3)))
     (* (: (* e1 e2)) (: e3)))
    ((* (? e1) (* (?c e2) (? e3)))
     (* (: e2) (* (: e1) (: e3))))
    ((* (* (? e1) (? e2)) (? e3))
     (* (: e1) (* (: e2) (: e3))))
    ((+ (?c e1) (+ (?c e2) (? e3)))
     (+ (: (+ e1 e2)) (: e3)))
    ((+ (? e1) (+ (?c e2) (? e3)))
     (+ (: e2) (+ (: e1) (: e3))))
    ((+ (+ (? e1) (? e2)) (? e3))
     (+ (: e1) (+ (: e2) (: e3))))
    ((+ (* (?c c) (? a)) (* (?c d) (? a)))
     (* (: (+ c d)) (: a)))
    ((* (? c) (+ (? d) (? e)))
     (+ (* (: c) (: d)) (* (: c) (: e))))
    ))
#+END_SRC

Then we can calculate length of list like Standard ML:
#+BEGIN_SRC scheme
(define length-list
  '(
    ((ll ()) 0)                         ;base case
    ((ll ((? x) . (? y))) (+ 1 (ll (: y)))) ;recursive case
    ))

((simplifier length-list) '(ll (x y z))) ;(+ 1 (+ 1 (+ 1 0)))
((simplifier algebra-rules) ((simplifier length-list) '(ll (x y z)))) ;3
#+END_SRC

Note that here as we don't used stack for recursive process, we have to stack up
explicitly using symbols; then we simplify using algebraic rules.

Then we can test the previous ~deriv~ test using ~dsimp~:
#+BEGIN_SRC scheme
(define dsimp
  (simplifier deriv-rules))
(define asimp
  (simplifier algebra-rules))
(deriv '(* (* x y) (+ x 3)) 'x)         ;(+ (* x y) (* y (+ x 3)))
(asimp (dsimp '(dd (* (* x y) (+ x 3)) x))) ;(+ (* x y) (+ (* 3 y) (* y x)))
#+END_SRC

Well, we need more clever algebraic simplifying rules here.
** Systems with Generic Operations
*** Generic Arithmetic Operations
Now we want to integrate all the arithmetic system to generic arithmetic system;
that is, by just using ~add~ we want to add whatever arithmetic type that we
constructed so far: rational numbers, complex numbers, and primitive numbers in
scheme.

To do so, first we should attach tag at each arithmetic system for
/data-directed programming/. After that we use the generic arithmetic by using
~apply-generic~ as we did in section 2.4.3:
#+BEGIN_SRC scheme
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
#+END_SRC

For the primitive numbers, all we need to do is just attach tag on each
construction:
#+BEGIN_SRC scheme
(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))
  (put 'add (scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub (scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul (scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div (scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  'done)
#+END_SRC

And user of this package would access constructor by following procedure:
#+BEGIN_SRC scheme
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
#+END_SRC

Exploiting /data-directed programming/, we don't need modify any parts of
previous code; we just add the ~put~ s for interfacing others.

Here we show the complex number package for instance, rational numbers can be
implemented similarly (see text book):
#+BEGIN_SRC scheme
(define (install-complex-package)
  ;; improted procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) x y))
  ;; internal procedure
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  ,*** other procedures goes here
  ;; interface to rest of the system
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  ,*** other procedures goes here
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
#+END_SRC

Then users can call the constructor granted the procedure:
#+BEGIN_SRC scheme
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
#+END_SRC

**** Exercise 2.77
By calling
#+BEGIN_SRC scheme
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
#+END_SRC
we can call each selector for complex number. How? let's trace the call, for
instance here we call the ~magnitude~:
1. Call ~(magnitude (make-complex-from-mag-ang r a))~. Then
2. By the definition of
   #+BEGIN_SRC scheme
(define (magnitude z) (apply-generic 'magnitude z))
   #+END_SRC
   ~(magnitude z)~ call ~apply-generic~ (here we abbreviated the object as ~z~)
3. Then apply generic strip the type tag-- complex type-- and look up the /operation-type table/
   to get appropriate operation to apply. By above ~put~ s, the returned
   operation is also ~magnitude~; then apply that procedure to contents of ~z~
4. We do the same thing as step *3.* but with ~'polar~ tag; then ~apply-generic~
   get ~(lambda (z) (car z))~ to apply with contents of ~(r . a)~.
5. It return ~r~ as expected.


So to summarize, the number of invoking ~apply-generic~ is 2 and the first
dispatch returns ~magnitude~ which we just started with and then the last
dispatch do the /real work/.
**** Exercise 2.78
To exploit the internal type system of scheme, we should modify the procedures
that we made for type: ~type-tag~, ~contents~, ~attach-tag~. The naive approach
would add conditional clause that check whether it has internal type:
#+BEGIN_SRC scheme
(define (attach-tag type-tag contents)
  (cond ((number? contents) contents)   ;do nothing: it has internal type system
;; We can add more primitive data here
        (else (cons type-tag contents))))
(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) 'scheme-number)
;; other primitive goes here
        (else (error "Bad tagged datum -- TYPE-TAG" datum))))
(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (else (error "Bad tagged datum -- CONTENTS" datum))))
#+END_SRC

Or we can accomplish this /data-directed/ style (revised):
#+BEGIN_SRC scheme
(define (attach-tag type-tag contents)
  (cond ((number? contents) contents)   ;do nothing: it has internal type system
;; We can add more primitive data here
        (else (cons type-tag contents))))
(define (type-tag datum)
  (cond ((pair? datum) (car datum))
        ((number? datum) ((get 'type 'scheme-number) datum)) ;data-directed programming
;; other primitive goes here
        (else (error "Bad tagged datum -- TYPE-TAG" datum))))
(define (contents datum)
  (cond ((pair? datum) (cdr datum))
        ((number? datum) datum)
        (else (error "Bad tagged datum -- CONTENTS" datum))))
#+END_SRC

+Then we don't need change any parts of previous code.+
Then we need to change =scheme-number= package accordingly:
#+BEGIN_SRC scheme
(define (install-scheme-number-package)
  (define (scheme-number-type num)      ;actually this means we implemented abstract class scheme-number.
    (cond ((and (integer? num) (exact? num)) 'integer)       ;inter? -> exact? for cope with (raise (raise (raise 5)))
          ((real? num) 'real)
          (else (error "Unknown scheme number -- SCHEME-NUMBER-TYPE" num))))
  (put 'type 'scheme-number scheme-number-type) ;for type tag
  (put 'make 'real exact->inexact)
  (put 'make 'integer inexact->exact)
  (define subtypes '(real integer))
  (for-each
   (lambda (t1)
     (for-each
      (lambda (t2)
        (for-each
         (lambda (op)
           (put (car op) (list t1 t2)
                (lambda (x y) ((cdr op) x y))))
         (list (cons 'add +) (cons 'sub -) (cons 'mul *) (cons 'div /))))
      subtypes)
     (put 'make t1 identity-procedure)  ;do nothing just warpping.
     )
   subtypes)
  'done)

(define make-real (get 'make 'real))
(define make-integer (get 'make 'integer))
#+END_SRC
**** Exercise 2.79
We can do this by either modifying each arithmetic packages or adding new
package that add ~equ?~. Here we implement the latter one:
#+BEGIN_SRC scheme
;; Exercise 2.79
(define (install-equ-package)
  ;; import from rational number package
  (define (numerator r) ((get 'numerator '(rational)) r))
  (define (denominator r) ((get 'denominator '(rational)) r))
  ;; internal procedures
  (define scheme-types '(real integer))
  (for-each (lambda (type) (put 'equ? (list type type) =)) scheme-types)
  (put 'equ? '(rational rational) (lambda (r1 r2)
                                   (and (= (numerator r1) (numerator r2))
                                        (= (denominator r1) (denominator r2)))))
  (put 'equ? '(complex complex) (lambda (c1 c2)
                                 (and (= (real-part c1) (real-part c2))
                                      (= (imag-part c1) (imag-part c2)))))
  'done)

(define (equ? x y) (apply-generic 'equ? x y))
#+END_SRC

Here we assumed that the selectors of rational number-- ~numer~, ~denom~--
generally accessible somehow. We can accomplish this adding that procedures in
/operation-type table/ in rational number package.
**** Exercise 2.80
Here we use ~equ?~ for implementing ~=zero?~ and also exploit the fact
~(= 0.0 0); #t~ for ordinary number:
#+BEGIN_SRC scheme
(define (install-zero-package)
  ;; import from rational number package
  (define (numerator r) ((get 'numerator '(rational)) r))
  (define (denominator r) ((get 'denominator '(rational)) r))

  (define scheme-types '(real integer))
  (for-each (lambda (type) (put '=zero? (list type) (lambda (e) (equ? e 0)))) scheme-types)
  (put '=zero? '(rational) (lambda (r) (equ? (numerator r) 0)))
  (put '=zero? '(complex) (lambda (c)
                                   (equ? (attach-tag 'complex c) (make-complex-from-real-imag 0 0))))
  'done)

(define (=zero? x) (apply-generic '=zero? x))
#+END_SRC
*** Combining Data of Different Types
**** Exercise 2.81
We have ~apply-generic~ that cope with coercion:
#+BEGIN_SRC scheme
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else
                         (error "No method for these types"
                                (list op type-tags))))))
              (error "No method for these types"
                                (list op type-tags)))))))
#+END_SRC

***** a.
As ~t1->t2~ is not ~false~ by the self coercion method, we get into infinite loop.
***** b.
It works as it is. Note that in the sub clause of ~t1->t2~ we call again
~apply-generic~ with coerced types; if we coerced already to the same type, and
then also the operation for that types doesn't exist on table, it get into
coerce check again, but this time fails as it should since the coercion to its
own type is not defined at all. However as it is, it has overhead that lookup
the table for checking whether there exist coercion to same type. We can avoid this.
***** c.
Result:
#+BEGIN_SRC scheme
(define (apply-generic op . args)
  (define (raise-exception)
    (error "No method for these types"
                       (list op type-tags)))
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (if (not (eq? type1 type2))
                    (let ((t1->t2 (get-coercion type1 type2))
                          (t2->t1 (get-coercion type2 type1)))
                      (cond (t1->t2
                             (apply-generic op (t1->t2 a1) a2))
                            (t2->t1
                             (apply-generic op a1 (t2->t1 a2)))
                            (else
                             (raise-exception))))
                    (raise-exception))
                (raise-exception))))))
#+END_SRC

It's messy.
**** Exercise 2.82
Extend to arbitary number of operands in ~apply-generic~. Let first we try what
the text suggested: To attempt to coerce all the arguments to the type of the
first argument, then to the type of the second arguemnt, and so on.

Here is the algorithm:
1) Take one type to which all the arguments to be tried to coerce.
2) Then coerce each argument (except the one that taken as "to type" argument).
3) Then try to get operation with coerced types.
4) Keep doing from 1 to 3 steps until either such operation found or tried all
   of the types of given argument (this time we should error appropriately).


It is reasonable to define the step 2 procedure standalone unit. Also this unit
can be decomposed to
- check whether such coerce procedure exist,
  #+BEGIN_SRC scheme
(define (try-coerce-> type types)
  (let ((coercions
         (map (lambda (t)
           (if (eq? t type)
               identity-procedure       ;return taken argument itself
               (get-coercion t type)))
              types)))
    (let ((exist?
           (fold-left (lambda (x y) (and x y))
                      true
                      coercions)))
      (if exist?
          coercions
          false))))
  #+END_SRC
- if it exists, then apply to each arguments.
  #+BEGIN_SRC scheme
(define (apply-each procs args) ;provided that these are same length
  (if (null? procs)
      '()
      (cons ((car procs) (car args))
            (apply-each (cdr procs) (cdr args)))))
  #+END_SRC


Armed with this, we can implement what we want using signal processing scheme:
#+BEGIN_SRC scheme
(define (apply-generic op . args)
  (define (raise-exception)
    (error "no method for these types"
                       (list op type-tags)))
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (cond (proc (apply proc (map contents args)))
            ((fold-left (lambda (t1 t2) ;check whether all the types are same
                          (if t1
                              (if (eq? t1 t2)
                                  t1
                                  false)
                              false))
                        type-tags)
             (raise-exception))         ;error
            (else
             (let ((result (fold-left (lambda (x y) (or x y))
                                      false
                                      (map (lambda (tArgs)
                                             (let ((types (map type-tag tArgs)))
                                               (let ((tProc (get op types)))
                                                 (if tProc
                                                     (cons tProc (map contents tArgs))
                                                     false))))
                                           (map (lambda (coercions)
                                                  (apply-each coercions args))
                                                (filter identity-procedure
                                                        (map (lambda (type)
                                                               (try-coerce-> type type-tags))
                                                             type-tags)))))))
               (if result
                   (apply (car result) (cdr result))
                   (raise-exception))))))))
#+END_SRC
It's total mess. Can you read this? Even for me it's hard to understand there're
a lot of tricks; I should refactor my procedure.

Let think about the situation where this strategy don't work. For instance, we
can think the circumstance where we got task that implement matrix in our
arithmetic systems. In that system, we have to implement scalar multiplication
of matrix; as we wanted to make our system as general as possible, we have
chosen to implement that with complex number (the supremum type of number
system). And our user used that procedure with integer number; however it gives
an error saying "no method for these types". What happend? Think about it.

This time let we try the refactoring. There's no end for it.
***** Try 1: Extract common pattern
#+BEGIN_SRC scheme
(define (apply-generic op . args)
  (define (raise-exception)
    (error "no method for these types"
                       (list op type-tags)))
  (define (try aArgs types?)
    (let ((type-tags (if types?
                         types?
                         (map type-tag aArgs))))
      (let (proc (get op type-tags))
        (if proc
            (cons proc (map contents aArgs))
            false))))
  (let ((type-tags (map type-tag args)))
    (let ((procPair (try args type-tags)))
      (cond (procPair (apply (car procPair) (cdr procPair)))
            ((fold-left (lambda (t1 t2) ;check whether all the types are same
                          (if t1
                              (if (eq? t1 t2)
                                  t1
                                  false)
                              false))
                        type-tags)
             (raise-exception))         ;error
            (else
             (let ((result (fold-left (lambda (x y) (or x y))
                                      false
                                      (map (lambda (tArgs)
                                             (try tArgs false))
                                           (map (lambda (coercions)
                                                  (apply-each coercions args))
                                                (filter identity-procedure
                                                        (map (lambda (type)
                                                               (try-coerce-> type type-tags))
                                                             type-tags)))))))
               (if result
                   (apply (car result) (cdr result))
                   (raise-exception))))))))
#+END_SRC

Well, it's still mess; as I've exploited signal interface I'm persuading myself
that it's the style of that.
***** Conclusion
You have to consider or design the algorithm thoroughly until the end; otherwise
if you jump in the middle of that like me, you get in such trouble.

Let's try thorough design in signal processing scheme:
1) Take type list
2) Filter it with /have coercion to?/
3) Filter it with /have such operation?/
4) If it is null signal error else
5) Then apply ~args~ coerce to ~car~ of it
6) and then apply found operation to it's contents


We can do these by wishful thinking and using conventional interface. Now we
should implement the auxiliary procedures
****** /have-coercion-to?/
We can accomplish this amending ~try-coerce->~:
#+BEGIN_SRC scheme
(define (have-coercion-to? type types)
  (fold-left (lambda (x y) (and x y))
             true
             (map (lambda (t)
                    (if (eq? t type)
                        identity-procedure       ;return taken argument itself
                        (get-coercion t type)))
                  types)))
#+END_SRC
****** /have such operation?/
To implement this we should supply length of ~args~ to test with ~(get op
type)~; this is no problem if we define these procedure in the ~apply-generic~:
#+BEGIN_SRC scheme
(define (have-such-operation? type)
  (get op (map (lambda (t) type)
               args)))
#+END_SRC

****** Put together
#+BEGIN_SRC scheme
(define (apply-generic op . args)
  (define (raise-exception)
    (error "no method for these types"
           (list op type-tags)))
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (cond (proc (apply proc (map contents args)))          ;base case?
            ((have-same-types? type-tags) (raise-exception)) ;error
            (else
             (coerce-and-apply op args type-tags raise-exception))))))

(define (coerce-and-apply op args types exception)
  (define (have-coercion-to? type)
    (fold-left (lambda (x y) (and x y))
               true
               (map (lambda (t)
                      (if (eq? t type)
                          identity-procedure       ;return taken argument itself
                          (get-coercion t type)))
                    types)))
  (define (have-such-operation? type)
    (get op (map (lambda (t) type)
                 args)))
  (let ((avail-type (filter have-such-operation?
                            (filter have-coercion-to?
                                    types))))
    (if (null? avail-type)
        (exception)
        (let ((type (car avail-type)))
          (let ((proc (get op (map (lambda (t) type)
                                  types)))
               (coerced-args (apply-each
                               (map (lambda (t)
                                      (if (eq? t type)
                                          identity-procedure
                                          (get-coercion t type)))
                                    types)
                               args)))
           (apply proc coerced-args))))))

(define (have-same-types? types)
  (fold-left (lambda (t1 t2) ;check whether all the types are same
               (if t1
                   (if (eq? t1 t2)
                       t1
                       false)
                   false))
             (car types)
             (cdr types)))
#+END_SRC
Here we used ~apply-each~, which defined before.

Let's test:
#+BEGIN_SRC scheme
(define (install-test)
  (put 'add '(real real real real) +)
  (put-coercion 'integer 'real exact->inexact)
  (add 5.4 3 2 .43))
#+END_SRC

And to support arbitrary arguments in ~add~ procedure:
#+BEGIN_SRC scheme
(define (add . xs) (apply apply-generic (cons 'add xs)))
#+END_SRC

Then the test return =10.83=. Works well.

Way better. Isn't it?

**** Exercise 2.83
Here we also implement this feature as one isolated package. This is
straightforward:
#+BEGIN_SRC scheme
(define (install-raise)
  ;; import from ratinal number
  (define numer (get 'numerator '(rational)))
  (define denom (get 'denominator '(rational)))
  ;; internal procedures
  (define (real->complex num)
    (make-complex-from-real-imag num 0))
  (define (rational->real num)
    (make-real (/ (numer num) (denom num))))
  (define (integer->rational num)
    (make-rational num 1.0))
  ;; interface to rest system
  (put 'raise '(integer) integer->rational)
  (put 'raise '(rational) rational->real)
  (put 'raise '(real) real->complex)
  'done)
#+END_SRC

We've already coped with this situation in [[Exercise 2.78][previous exercise]].
**** Exercise 2.84
Here is the algorithm:
1. Check all the arguments' type are in tower:
   #+BEGIN_SRC scheme
(define tower '(integer rational real complex))
   #+END_SRC
2. Then, check all the types are equal (=apply-generic= handles the first check).
3. If not, =raise= the arguement whose type is the subtype of others.
4. Do step 3 until all the types are equal. Then apply =apply-generic= to it.

To find the /argument whose type is minimum in the arguments/,
we need to devise the method of comparing the /rank/ of types. The easiest way
is mapping type to rank
1) Maps the type to /rank number/.
2) Then compare the numbers!

Here is the mapping procedure:
#+BEGIN_SRC scheme
(define (type->rank type)
  (define (iter towerstack)
    (cond ((null? towerstack)
           (error "given type not included in tower TYPE->RANK" type))
          ((eq? (car towerstack) type) (length towerstack))
          (else (iter (cdr towerstack)))))
  (iter tower))
#+END_SRC

Or, more straightforward encoding would be
1) Let assume that we compare two types in the tower.
2) If latter type is in the former's supertype then former < latter.
3) else, former \ge latter.


#+BEGIN_SRC scheme
(define (type< t1 t2)
  (define (super-of-t1 towerstack)
    (cond ((null? towerstack)
           (error "given type not included in tower TYPE<" t1))
          ((eq? (car towerstack) t1) (cdr towerstack))
          (else (super-of-t1 (cdr towerstack)))))
  (element-of-set? t2 (super-of-t1 tower)))
#+END_SRC

Using this, we can find the /minimum/ type in given types:
#+BEGIN_SRC scheme
(define (mintype types)                 ;provided that types are in tower
  (fold-left (lambda (t1 t2)
               (if (type< t1 t2)
                   t1
                   t2))
             (car types)
             (cdr types)))
#+END_SRC

Here is the result:
#+BEGIN_SRC scheme
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags))
          (raise-exception
            (lambda () (error "no method for these types"
                              (list op type-tags)))))
      (cond (proc (apply proc (map contents args)))          ;base case?
            ((have-same-types? type-tags) (raise-exception)) ;error
            ((all-in-tower? type-tags)
             (apply
              apply-generic
              (cons op
                    (do-until raise-minimum
                              (lambda (args)
                                (have-same-types? (map type-tag args)))
                              (raise-minimum args)))))
            (else
             (coerce-and-apply op args type-tags raise-exception))))))
#+END_SRC

We capture the common procedure pattern by
#+BEGIN_SRC scheme
(define (all-in-tower? types)
  (fold-left (lambda (t1 t2)
               (and t1
                    (element-of-set? t2 tower)))
             true
             types))

(define (raise-minimum args)
  (let ((minT (mintype (map type-tag args))))
    (map (lambda (arg)
           (if (eq? (type-tag arg) minT)
               (raise arg)
               arg))
         args)))

(define (do-until proc pred args)
  (define (iter args)
    (if (pred args)
        args
        (iter (proc args))))
  (iter args))
#+END_SRC

And we can test this feature:
#+BEGIN_SRC scheme
(add (make-complex-from-real-imag 5 3) 5 (make-rational 9 16) 5.3)
;; (complex rectangular 15.8625 . 3)
#+END_SRC

We used generalized version of arithmetic operations:
#+BEGIN_SRC scheme
(define (add . xs)
  (fold-left (lambda (x y)
               (apply-generic 'add x y))
             (car xs)
             (cdr xs)))
(define (sub . xs)
  (fold-left (lambda (x y)
               (apply-generic 'sub x y))
             (car xs)
             (cdr xs)))
(define (mul . xs)
  (fold-left (lambda (x y)
               (apply-generic 'mul x y))
             (car xs)
             (cdr xs)))
(define (div . xs)
  (fold-left (lambda (x y)
               (apply-generic 'div x y))
             (car xs)
             (cdr xs)))
#+END_SRC
**** Exercise 2.85
***** Implementing =proeject=
As implied in text-- avoided to project =1.5= to =rational=, in fact, the
projection from =real= to =rational= is quite complicate process. For
simplicity, we also avoid the projection from =real= to =rational=.
#+BEGIN_SRC scheme
(define (install-project)
  ;; internal procedures
  (define (complex->real num)
    (make-real (real-part num)))
  (define (real->integer num)
    (make-integer (round num)))
  (define (rational->integer num)
    (make-integer (round (raise num)))) ;depends on raise package
  ;; interface to rest system
  (put 'project '(rational) rational->integer)
  (put 'project '(real) real->integer)
  (put 'project '(complex) complex->real)
  'done)
#+END_SRC
***** Implementing =drop=
We can deduce rules from the text:
1) Check whether =project= defined with respect to the given argument
2) If it is, then try drop one level: Project it and raise to what we started
   with and then check it equals to given argument using =equ?= then project one
   level.
3) Do step 2 until neither step 1 is satisfied nor step 2.


The result:
#+BEGIN_SRC scheme
(define (drop term)
  (let ((type (type-tag term)))
    (cond ((not (get 'project type))
           term)
          (else
           (let ((drop-1 (project term)))
             (if (equ? term
                       (do-until raise
                                 (lambda (arg)
                                   (eq? (type-tag arg)
                                        type))
                                 drop-1))
                 (drop drop-1)
                 term))))))
#+END_SRC
***** Put together to =apply-generic=
#+BEGIN_SRC scheme
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags))
          (raise-exception
            (lambda () (error "no method for these types"
                              (list op type-tags)))))
      (cond (proc (drop (apply proc (map contents args))))   ;simply result
            ((have-same-types? type-tags) (raise-exception)) ;error
            ((all-in-tower? type-tags)
             (apply
              apply-generic
              (cons op
                    (do-until raise-minimum
                              (lambda (args)
                                (have-same-types? (map type-tag args)))
                              (raise-minimum args)))))
            (else
             (coerce-and-apply op args type-tags raise-exception))))))
#+END_SRC

Let's test:
#+BEGIN_SRC scheme
(add (raise 5) (raise (raise (raise 5)))) ;fall into infinite loop!!
#+END_SRC
Uoh, it falls into infinite loop! It's because =raise= itself applied by drop,
and then drop apply =raise= ...

We have to revise this. Note that we don't want to drop every result of
=apply-generic=; for now, it is sufficient to drop the result of clause,
=all-in-tower?=. Then let's redo our test:
#+BEGIN_SRC scheme
(add (raise 5) (raise (raise (raise 5)))) ;10
#+END_SRC

Okay, let's move on.
**** Exercise 2.86
If we can convert all the arithmetic operations used in rectangular and polar
package to generic arithmetic operations, then complex number can be made by
arbitrary type generic arithmetic system supports.

Here we jot down what operations need to be conversed:
- For rectangular package:
  =sqrt=, =atan=, =+=, =*=, =sin=, =cos=, =square=
- For polar package:
  =*=, =+=, =cos=, =sin=, =atan=, =sqrt=, =square=
- For complex package:
  =+=, =/=, =*=, =-=


So, as consequence, we only need to convert the followings:
- =sqrt=, =sin=, =cos=, =atan=, =square=
- =+=, =-=, =*=, =/=


The latter ones are easy: We already have the generic operations namely, =add=,
=sub=, =mul=, =div=.

For the former ones, some of these are hard to think in the domain of complex
number, so we constrain the domain of procedure to real:
#+BEGIN_SRC scheme
(define (raise-until upper x)
  (do-until raise
            (lambda (arg)
              (eq? (type-tag arg) upper))
            x))
(define (make-general<= utype op opname)
  (lambda (x) (let ((type (type-tag x)))
                (cond ((type< type utype)           ;the domain of procedure is until utype
                       (op (raise-until utype x)))
                      ((eq? type utype)
                       (op x))
                      (else
                        (error (string-append "Bad argument type -- " opname) x))))))

(define squareroot
  (make-general<= 'real sqrt "SQUARROOT"))

(define sine
  (make-general<= 'real sin "SINE"))

(define cosine
  (make-general<= 'real cos "COSINE"))

(define (arctan y x)
  (let ((yT (type-tag y))
        (xT (type-tag x))
        (upper 'real))
    (cond ((and (or (type< yT upper)
                    (eq? yT upper))
                (or (type< xT upper)
                    (eq? xT upper)))
           (atan (raise-until upper y)
                 (raise-until upper x)))
          (else
           (error "Bad arguments -- ARCTAN" y x)))))

(define (square-gen x)
  (mul x x))
#+END_SRC

Then the rest is simple.

Then we should test it:
#+BEGIN_SRC scheme
(add (make-complex-from-real-imag (make-rational 5 2) 3)
     (make-complex-from-mag-ang (make-rational 3 2) 3.2))
;; (complex rectangular 1.0025578363078704 . 2.91243878485863)
#+END_SRC

Work!
*** Example: Symbolic Algebra
In this section we will make a new language that manipulate symbolic algebra. As
we have learned from chapter 1, to construct powerful language[fn:3] we need to
specify
- primitives
- means of combination
- means of abstraction
- capturing common pattern


We can think numbers and variables as primitives in symbolic algebra; then we
can compound that primitives using operations like addition and multiplication.
As we embed the language we develop in scheme, we naturally inherite the means
of abstraction of scheme, namely =define=. For capturing common pattern, we have
two method for that: data-directed programming and closure property; with
combination of these, we can obtain generic arithmetic system we developed until
previous section but now extends this as encompass symbolic algebra.

Actually we have construct "partially" the symbolic algebra system when we dealt
with symbolic differentiation in section 2.3.2. In there, we used scheme's
special expression =quote= for representing varibles, and used scheme's number
system as representing numbers. We can exploit this fact or not: We don't need
worry about that in this step; we can defer this implementation detail later.

Let's recap what we've learned in previous section. We've learned the concept
abstract data type, generic operations that operates on various data type,
data-directed programming that enables us to develop each part of language
individually without any interfering with others.

Abstract data type is something that captures the common pattern or natural
entity which combines some data relevant with it. In the context of symbolic
algebra, we can think of linear combination, polynomial, rational function, or
trigonometric fucntion as common pattern where we organize symbolic entities; so
we can think these pattern as type in foregoing dialogue.

Here we construct polynomial data type for the start. To encode polynomial into
computer language, first, we need to specify what the polynomial is. For
simplicity, as wrote in text book, we only consider the univariate polynomial
and also we consider polynomial syntactically, i.e. $x^{2}+x+1$ is different
from $y^{2}+y+1$ although these have the same structure.

Now we consider the arithmetic on polynomials. First, we construct the system
about addition and multiplication and then we can add other operations using
data-directed programming as we did before. We use abstract data type for
representing polynomials, which would add flexibilities to our system. To
interfacing with abstract data type we need to specify what the constructor is
and what the selectors are, in other words, we need to deduce contract between
constructor of polynomial and selectors, which encode the properties of
polynomials naturally. For this task, we can play with polynomials for a while,
if you are done with this stuff, then you can deduce
- polynomials are composed by a variable that is dominant in our univariate
  polynomial with term list where each term consist of its order and coefficient.
- So, for constructing the polynomial we need to hand over term list and
  variable,
- and then we have to select each part of it, i.e. variable and term list appropriately.


Note that we installed abstract layer under the polynomials-- term and term
list; we separated the variable from its term. As we designing polynomials using
term (and its list), we can assume that terms can be combined using addition and
multiplication and so on. With this buildings, we can construct concretely
polynomial arithmetic using the abstract data type:
#+BEGIN_SRC scheme
(define (arith-poly term-op opname)
  (lambda (p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (term-op (term-list p1)
                            (term-list p2)))
        (error (string-append "Polys not in the same var -- " opname) (list p1 p2)))))

(define add-poly
  (arith-poly add-terms "ADD-POLY"))
(define mul-poly
  (arith-poly mul-terms "MUL-POLY"))
#+END_SRC

Here we used =same-variable?= that we defined in section 2.3.2 as we noted since
underlying primitives are same.

We are done with the very top level of our language, now we should tackle with
the lower level language, terms. We need to deduce the rules to terms as we did
with polynomial. Note that terms, or more precisely term list, consist of term.
So syntactically we can think term list constructed using term, i.e. there are
two language namely individual term langauge, term list language that using term.

This time, let we think about constructing term list using underlying term
language. Note that term list, as its name implies, having lots of analogy with
list data structure; so using that analogy, we can construct the rules that
govern term list as
- constructors ::
     - =(adjoin-term term term-list)= that adjoin a =term= at the very
       beginning of =term-list=, which is analogous to =cons=.
     - =(the-empty-termlist)= returns empty termlist upon which we keep constructing
       complex term list. This is analogous to =nil=.
- selectors ::
     - =(first-term term-list)= returns the first term in the =term-list=, which
       is analogous to =car=.
     - =(rest-terms term-list)= returns the term list but the first term, which
       is analogous to =cdr=.
- predicates :: =(empty-termlist? L)= return true when =L= has no term in it,
     else false. That is analogous to =null?=


In addition with these, we make contract with these that =first-term= returns
the highest order of term in the term list. And =adjoin-term= adds term to the
term list and resulting term list in decreasing order in order of term. We could
make this assumption into our code to validate this contract; but for now, we
just relying on these verbal contract.

With these set up we can implement the operations on term list, for the term
language let us construct that as we go:
#+BEGIN_SRC scheme
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1)) (t2 (first-term L2)))
           (cond ((< (order t1) (order t2))
                  (addjoin-term
                   t2
                   (add-terms L1
                              (rest-terms L2))))
                 ((> (order t1) (order t2))
                  (addjoin-term
                   t1
                   (add-terms L2
                              (rest-terms L1))))
                 (else
                  (adjoin-term
                   (make-term (order t1)
                              (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))
#+END_SRC

Here we used what we wish to have in term language:
- construtor :: =make-term= that takes order of the term (integer) with coefficient
- selectors ::
     - =order= that return the order of given term,
     - =coeff= that return the coefficient of given term.


Also note that here we used =add= rather than =+= to incorporate the generic
arithmetic system in term, i.e. we can take complex number as coefficient of
term or even more, if we install our polynomial system into our generic
arithmetic system, then term can take polynomial as its coefficient, which is
equivalent to express the full multivariate polynomial in our system.

Multiplication of terms are litte more trickey. To deduce the algorithm, we can
play with multiplication of polynomials in hand using the knowledges of middle
school algebra. We can break down the whole process by
1. multiply each term of the first addend by the second addend term list
2. and then add each of these results using =add-terms=


We can accomplish these procedure using recursive definiiton:
#+BEGIN_SRC scheme
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))

(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let ((t2 (first-term L)))
        (addjoin-term (make-term (+ (order t1) (order t2))
                                 (mul (coeff t1) (coeff t2)))
                      (mul-term-by-all-term t1 (rest-terms L))))))
#+END_SRC

Note that here we also used =mul= instead of =*= with the same reason above.

**** Representing term lists
Here we made contract that interface term list as a ordered list in decreasing
order in order of term. We could represent the term list as a set of
coefficients keyed by the order of the term or we could let the order of term
incoporated as index of term in the list-- list of coefficients.

The major factor that determine which is better is /density/. For the
sparse[fn:4], the former would be more appropriate; while for the dense
polynomial the latter would be more efficient. Or we could install both
representation simultaneously like rectangular and polar representation of
complex number. Let we first follow the text's flow-- the former one:
#+BEGIN_SRC scheme
(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (cons term term-list)))

(define (the-empty-termlist) '())
(define (first-term term-list) (car term-list))
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) (null? term-list))
(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))
#+END_SRC

Finally we can install our polynomial package into our generic arithmetic
package:
#+BEGIN_SRC scheme
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  ;;[procedures same-variable? and variable? from section 2.3.2]

  ;; representation of terms and term lists
  ;;[procedures adjoin-term ... coeff from text below]

  ;;(define (add-poly p1 p2) ... )
  ;;[procedures used by add-poly]

  ;;(define (mul-poly p1 p2) ... )
  ;;[procedures used by mul-poly]

  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))

  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  'done)

(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1)) (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-term (order t1)
                              (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))

(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))

(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let ((t2 (first-term L)))
        (adjoin-term
         (make-term (+ (order t1) (order t2))
                    (mul (coeff t1) (coeff t2)))
         (mul-term-by-all-terms t1 (rest-terms L))))))


;; Representing term lists

(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (cons term term-list)))

(define (the-empty-termlist) '())
(define (first-term term-list) (car term-list))
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) (null? term-list))

(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))
#+END_SRC
**** Exercise 2.87
We installed ==zero?= package independently from each arithmetic package so far;
however more aggregate the code in that package, harder it gets to maintain. So
I've decided to distribute each ==zero?= procedure to relevant package. Here is
that procedure for polynomial:
#+BEGIN_SRC scheme
 (put '=zero? '(polynomial) (lambda (p) (empty-termlist? (term-list p))))
#+END_SRC

In addition, I've implemented the =equ?= package to polynomial:
#+BEGIN_SRC scheme
 ;; equ package
 (define (equ-poly? p1 p2)
   (and (same-variable? (variable p1) (variable p2))
        (equ-terms? (term-list p1) (term-list p2))))
 (define (equ-terms? L1 L2)
   (cond ((empty-termlist? L1) (empty-termlist? L2))
         ((empty-termlist? L2) false)
         (else
          (let ((t1 (first-term L1)) (t2 (first-term L2)))
            (and (= (order t1) (order t2))
                 (equ? (coeff t1) (coeff t2))
                 (equ-terms? (rest-terms L1)
                             (rest-terms L2)))))))
#+END_SRC
**** Exercise 2.88
Let we assume that we have generic =neg= procedure. Then we can extend
polynomial package to include subtraction that is analogous to addition:
#+BEGIN_SRC scheme
 ;; arithmetic operations on poly ( wrapper operation )
 (define (arith-poly term-op opname)
   (lambda (p1 p2)
     (if (same-variable? (variable p1) (variable p2))
         (make-poly (variable p1)
                    (term-op (term-list p1)
                             (term-list p2)))
         (error (string-append "Polys not in the same var -- " opname) (list p1 p2)))))

(define (sub-terms L1 L2)
   (cond ((empty-termlist? L1) (neg-terms L2))
         ((empty-termlist? L2) L1)
         (else
          (let ((t1 (first-term L1)) (t2 (first-term L2)))
            (cond ((< (order t1) (order t2))
                   (adjoin-term
                    t2
                    (sub-terms L1
                               (rest-terms L2))))
                  ((> (order t1) (order t2))
                   (adjoin-term
                    t1
                    (sub-terms L2
                               (rest-terms L1))))
                  (else
                   (adjoin-term
                    (make-term (order t1)
                               (sub (coeff t1) (coeff t2)))
                    (sub-terms (rest-terms L1)
                               (rest-terms L2)))))))))

 (define sub-poly
   (arith-poly sub-terms "SUB-POLY"))
#+END_SRC

Then we should install =neg= operator to all arithmetic package:
#+BEGIN_SRC scheme
(define (install-scheme-number-package)
...
  (define subtypes '(real integer))
  (for-each
   (lambda (t1)
...
     (put 'neg (list t1) (lambda (e) (- e))))
   subtypes)
  'done)

(define (install-rational-package)
...
  (put 'neg '(rational)
       (lambda (r)
         (tag (make-rat (neg n)
                        (neg d)))))
  'done)

(define (install-complex-package)
...
  (put 'neg '(complex) (lambda (c) (tag (make-from-real-imag ((neg (real-part c))
                                                              (neg (imag-part c)))))))
  'done)

(define (install-polynomial-package)
...
;; neg package
;; (define (neg-terms L)
;;   (map (lambda (term)
;;          (make-term (order term)
;;                     (neg (coeff term))))
;;        L))
;; We should not assume the representation detail about the lower level language.
(define (neg-terms L)
    (if (empty-termlist? L)
        L
        (let ((t (first-term L)))
          (adjoin-term (make-term (order t) (neg (coeff t)))
                       (neg-terms (rest-terms L))))))
 (define (neg-poly p)
   (make-poly (variable p)
              (neg-terms (term-list p))))
...
 'done)
#+END_SRC

Then the generic operator can be called by setting up
#+BEGIN_SRC scheme
(define (neg x) (apply-generic 'neg x))
#+END_SRC
**** Exercise 2.89
As we build up the term list language upon term language, let we decompose term
list language and term language from polynomial package:
#+BEGIN_SRC scheme
(define (install-term-package)
  ;; representation of term
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))
  (define (tag t) (attach-tag 'term t))
  (put 'make 'term (lambda (order coeff) (tag (make-term order coeff))))
  (put 'order '(term) order)
  (put 'coeff '(term) coeff)
  )

(define (install-sparse-termlist)
  ;; dependency
  (install-term-package)
  (define (coeff term) (apply-generic 'coeff term))
  ;; internal procedures
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  ;; interface to rest of the system
  (define (tag L) (attach-tag 'sparse L))
  (put 'adjoin-term '(term sparse) (lambda (t L) (tag (adjoin-term (attach-tag 'term t) L))))
  (put 'first-term '(sparse) first-term)
  (put 'rest-terms '(sparse) (lambda (L) (tag (rest-terms L))))
  (put 'empty-termlist? '(sparse) empty-termlist?)
  (put 'the-empty-termlist 'sparse (lambda () (tag (the-empty-termlist))))
  )
#+END_SRC

Analogous to sparse term list, we can implement dense term list package:
#+BEGIN_SRC scheme
(define (install-dense-termlist)
  ;; dependency
  (install-term-package)
  (define (make-term order coeff) ((get 'make 'term) order coeff))
  (define (order term) (apply-generic 'order term))
  (define (coeff term) (apply-generic 'coeff term))
  ;; internal procedures
  (define (the-empty-termlist) '())
  (define (empty-termlist? term-list) (null? term-list))
  (define (first-term term-list) (make-term (- (length term-list) 1) (car term-list)))
  (define (rest-terms term-list)
    (define (iter list)
      (cond ((empty-termlist? list) list)
            ((=zero? (car list)) (iter (cdr list)))
            (else list)))
    (iter (cdr term-list)))
  (define (adjoin-term term term-list)
    (cond ((=zero? (coeff term)) term-list)
          ((= (order term) (length term-list)) (cons (coeff term) term-list))
          (else (adjoin-term term (cons 0 term-list))))) ;we need consider general zero instead of 0
  ;; interface to rest of the system
  (define (tag L) (attach-tag 'dense L))
  (put 'adjoin-term '(term dense) (lambda (t L) (tag (adjoin-term (attach-tag 'term t) L))))
  (put 'first-term '(dense) first-term)
  (put 'rest-terms '(dense) (lambda (L) (tag (rest-terms L))))
  (put 'empty-termlist? '(dense) empty-termlist?)
  (put 'the-empty-termlist 'dense (lambda () (tag (the-empty-termlist))))
  )
#+END_SRC

By this decomposing we can test each package seperately.
**** Exercise 2.90
Here is the complete code that satisfy all the requirement:
#+BEGIN_SRC scheme
(define (install-polynomial-package)
  ;; dependency
  (install-term-package)
  (install-dense-termlist)
  (install-sparse-termlist)
  ;; import from dependent package
  (define (empty-termlist? L) (apply-generic 'empty-termlist? L))
  (define (adjoin-term t L) (apply-generic 'adjoin-term t L))
  (define (first-term L) (apply-generic 'first-term L))
  (define (rest-terms L) (apply-generic 'rest-terms L))
  (define (the-empty-termlist) (sparse-empty-termlist))
  (define (sparse-empty-termlist) ((get 'the-empty-termlist 'sparse)))
  (define (dense-empty-termlist) ((get 'the-empty-termlist 'dense)))
  (define (make-term order coeff) ((get 'make 'term) order coeff))
  (define (order term) (apply-generic 'order term))
  (define (coeff term) (apply-generic 'coeff term))

  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable
          (->appropriate-rep term-list)))
  (define (variable p)
    (car p))
  (define (term-list p)
    (cdr p))

  ;; from section 2.3.2
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (symbol? v1) (symbol? v2) (eq? v1 v2)))

  ;; arithmetic operations on poly ( wrapper operation )
  (define (arith-poly term-op opname)
    (lambda (p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (term-op (term-list p1)
                              (term-list p2)))
          (error (string-append "Polys not in the same var -- " opname) (list p1 p2)))))

  ;; arithmetic operations on termlist
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
             (cond ((< (order t1) (order t2))
                    (adjoin-term
                     t2
                     (add-terms L1
                                (rest-terms L2))))
                   ((> (order t1) (order t2))
                    (adjoin-term
                     t1
                     (add-terms L2
                                (rest-terms L1))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))

  (define (sub-terms L1 L2)
    (cond ((empty-termlist? L1) (neg-terms L2))
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
             (cond ((< (order t1) (order t2))
                    (adjoin-term
                     t2
                     (sub-terms L1
                                (rest-terms L2))))
                   ((> (order t1) (order t2))
                    (adjoin-term
                     t1
                     (sub-terms L2
                                (rest-terms L1))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (sub (coeff t1) (coeff t2)))
                     (sub-terms (rest-terms L1)
                                (rest-terms L2)))))))))

  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))


  (define add-poly
    (arith-poly add-terms "ADD-POLY"))
  (define mul-poly
    (arith-poly mul-terms "MUL-POLY"))
  (define sub-poly
    (arith-poly sub-terms "SUB-POLY"))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term (make-term (+ (order t1) (order t2))
                                  (mul (coeff t1) (coeff t2)))
                       (mul-term-by-all-terms t1 (rest-terms L))))))

  ;; equ package
  (define (equ-poly? p1 p2)
    (and (same-variable? (variable p1) (variable p2))
         (equ-terms? (term-list p1) (term-list p2))))
  (define (equ-terms? L1 L2)
    (cond ((empty-termlist? L1) (empty-termlist? L2))
          ((empty-termlist? L2) false)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
             (and (= (order t1) (order t2))
                  (equ? (coeff t1) (coeff t2))
                  (equ-terms? (rest-terms L1)
                              (rest-terms L2)))))))
  ;; neg package
  (define (neg-terms L)
    (map (lambda (term)
           (make-term (order term)
                      (neg (coeff term))))
         L))

  (define (neg-poly p)
    (make-poly (variable p)
               (neg-terms (term-list p))))

  ;; number of terms
  (define (number-of-terms L)
    (if (empty-termlist? L)
        0
        (1+ (number-of-terms (rest-terms L)))))

  (define (->appropriate-rep L)
    (let ((ratio 0.5)) ;determine the ratio at which change the representation of term list
      (cond ((empty-termlist? L) L)
            ((< (/ (number-of-terms L) (order (first-term L)))
                ratio)
             (->sparse L))
            (else (->dense L)))))

  (define (->sparse L)
    (define (recur L)
      (if (empty-termlist? L)
          (sparse-empty-termlist)
          (adjoin-term (first-term L)
                       (recur (rest-terms L)))))
    (if (eq? 'sparse (type-tag L))
        L
        (recur L)))

  (define (->dense L)
    (define (recur L)
      (if (empty-termlist? L)
          (dense-empty-termlist)
          (adjoin-term (first-term L)
                       (recur (rest-terms L)))))
    (if (eq? 'dense (type-tag L))
        L
        (recur L)))

  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  (put 'equ? '(polynomial polynomial) equ-poly?)
  (put '=zero? '(polynomial) (lambda (p) (empty-termlist? (term-list p))))
  (put 'neg '(polynomial) (lambda (p) (tag (neg-poly p))))
  'done)
  #+END_SRC

  Also we should check it works as expected:
  #+BEGIN_SRC scheme
(sub (make-polynomial 'x '(dense 1 0 0 0 0 0 0))
     (make-polynomial 'x '(sparse (term 5 1) (term 4 2) (term 1 1))))

(add (make-polynomial 'x '(dense 1 0 0 0 0 0 0))
     (make-polynomial 'x '(sparse (term 5 1) (term 4 2) (term 1 1))))

(mul (make-polynomial 'x '(dense 1 0 0 0 0 0 0))
     (make-polynomial 'x '(sparse (term 5 1) (term 4 2) (term 1 1))))
  #+END_SRC

  As noted in the exercise's statement, unlike the complex number package, this
  require global change rather than local chang, i.e. we should change
  polynomial package to maintain the representation of term list efficiently. We
  maintain the appropriate (efficient) representation every time we make a new
  polynomial.
**** Note
As we noticed that the term list has lots of analogy with list
structure in scheme, we should find that similarity between polynomial with
strictly typed list structure like in ML or Scala, i.e. we can think variable of
polynomial is analogous to type of the list element. Then we can also guess the
work of complier in the strictly typed language as they perform type inference
using the operator table like in this section.

We can find this analogy in foregoing discussion.
**** Exercise 2.91
It is easy: If we follow the specified rules in the text, we can complete the
code accordingly:
#+BEGIN_SRC scheme
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     (div-terms (sub-terms L1
                                           (mul-term-by-all-terms
                                            (make-term new-o new-c)
                                            L2))
                                L2)))
                (cons (adjoin-term (make-term new-o new-c)
                                   (car rest-of-result))
                      (cdr rest-of-result))))))))
#+END_SRC

Let's test:
#+BEGIN_SRC scheme
(div (make-polynomial 'x '(dense 1 0 0 0 0 0 0))
     (make-polynomial 'x '(sparse (term 5 1) (term 4 2) (term 1 1))))
;; (polynomial x dense 1 -2)
#+END_SRC
**** Exercise 2.92
***** The Problem
Our system works well even if we add multivariate polynomial, i.e. univariate
polynomial whose coefficients are also univariate polynomial, by the recursive
type dispatch operation. However that works well only we set up appropriately:
While if we add $x^{2}\left( y + 1 \right) + x \left( y^{2} + y \right) +
y^{2} + y$ with $x \left( y^{3} + y \right)$
using our system, as the nested polynomial agree with variable in each level, it
results in $x^{2}\left( y + 1 \right) + x \left( y^{3} +y^{2} + 2y \right) +
y^{2} + y$;
whereas $x^{2}\left( y + 1 \right) + x \left( y^{2} + y \right) +
y^{2} + y$ with $y^{3} \left( x \right) + y \left( x \right)$
doesn't work at all even if the first and second formula are same in the
algebraic context (by commutative law of multiplication).
To deal with this problem, i.e. to produce "right" answer consistently even if
we hand over the second formula, we consider to impose "canonical" order in
polynomial's variable; e.g. $x$ has higher priority than $y$ so that
$x \left( y^{3} + y \right)$ is canonical form but $y^{3} \left( x \right) + y
\left( x \right)$.

***** Designing
Then how to deal with the addition and multiplication operation with this
impose? So far, we set up the abstraction barrier between each level of nested
formula so that let our generic operator deal with each type of formula
appropriately. Doing that, we actually set up the recursive process on data
type such as =equ?= package and so on.

As we learned in chapter 1 and practicing that skill with exercises-- the
powerful "wishful thinking"-- that recursive process are really good at handling
complex process by capturing local rules by which the process evolve. However,
this time we are about to break that barrier: We should access all the level of
nested polynomial to expand and rearrange.

To design our arithmetic operations in this scheme, we should grasp the gist of
it by playing with multivariate polynomial arithmetic by hand calculation. I've
done this with my digital paper. You should do this process with your own note
or something. After that, we could conclude that if we assume we can expand all
the terms and rearrange that to canonical form, then
- addition is obtained by expanding and rearranging addend and augend all together,
- multiplication can be decomposed to multiply each term of multiplicand with
  multiplier and then expanding and rearranging all together as we did addition.


Also note that multiply each term of one argument to term list of other argument
is analogous to previous =mul-terms= procedure; but here we should notice that
this process is also a part of expansion of terms, as consequence if we can
implement the rearranging process the addition and multiplication of
multivariate polynomial is just by product of it.

****** Expansion
First we need to specify what we want from expansion:
- The output should be ordered list or not, if it should be arranged how?
- Should the output collapse the same form of term appropriately-- add terms?
- How should it deal with constant term -- term with zero order?
- Should we make abstract data type for it? That is, should we make constructor
  and selectors for its result?


After playing with the expansion and reconstruction to canonical form, I found
that
- it should ordered by priority of variable in decreasing order,
- yes, it should collapse appropriately,
- we should consider the zeroth term as place holder -- just strip variable part,
- it is plausible to have abstract data type but type tag.


would make ourself easier to implement that.

******* Data Abstraction

Here is the specification of the abstract data type:
- =(collapse-term-to-each term expansion-list)= :: The motivation of this
     procedure is following: $x \left( x y + 2 \right) = x^{2}y + 2x$, i.e.
     =collapse-term-to-each '(x 1) '(((x 1) (y 1) (num 1)) ((num 2)))= should
     return =(((x 2) (y 1) (num 1)) ((x 1) (num 2)))=
- =(add-term-list-to-expansion termlist expansion-list)= :: This procedure take
     term list that represent each term in the expansion -- $x^{2}y$ in
     $x^{2}y + 2x$ to adjoin in the expansion list, in which each term list
     ordered in decreasing priority.


With those procedure, we can implement recursive process of expansion:
#+BEGIN_SRC scheme
(define (expand nested-poly)
  (cond (<base>)
        (else
         (let ((x (variable nested-poly))
               (L (term-list nested-poly)))
           (let ((t (first-term L))
                 (tl (rest-terms L)))
             (append-expansion
              (collapse-term-to-each
               (make-var-term x (order t))
               (expand (coeff t)))
              (expand (make-polynomial x tl))))))))

(define (append-expansion e1 e2)
  (if (empty-expansion? e1)
      e2
      (add-term-list-to-expansion (first-term-list e1)
                                  (append-expansion (rest-expansion e1) e2))))
#+END_SRC

Or we could decompose =expand= procedure more granularly:
#+BEGIN_SRC scheme
(define (expand nested-poly)
  (cond (<base>)
        (else
         (expand-at-level (variable nested-poly) (term-list nested-poly)))))

(define (expand-at-level x L)
  (cond (<base>)
        (else
         (let ((t (first-term L)) (tl (rest-terms L)))
           (append-expansion
            (collapse-term-to-each
             (make-var-term x (order t))
             (expand (coeff t)))
            (expand-at-level x tl))))))
#+END_SRC

Now we have to consider the base case. Note that in the recursive process, we
pass coefficient of term to =expand=; so the only base case of it is not
polynomial case-- number coefficient:
#+BEGIN_SRC scheme
(define (expand nested-poly)
  (cond ((not (polynomial? nested-poly))
         (add-term-list-to-expansion
          (make-term-list-with-num nested-poly)
          (the-empty-expansion)))
        (else
         (expand-at-level (variable nested-poly) (term-list nested-poly)))))
#+END_SRC

For the =expand-at-level=, the base case is =empty-termlist=:
#+BEGIN_SRC scheme
(define (expand-at-level x L)
  (cond ((empty-termlist? L) (the-empty-expansion))
        (else
         (let ((t (first-term L)) (tl (rest-terms L)))
           (append-expansion
            (collapse-term-to-each (make-var-term x (order t))
                                   (expand (coeff t)))
            (expand-at-level x tl))))))
#+END_SRC

Are we implement all the specification that we started with? Aren't we missed
the constant clause? Well, no since we can deal with that in
=collapse-term-to-each= procedure.

We have introduced bunch of procedures that we didn't specified prior; this is
due to the power of data abstraction: We can add any procedure that we want and
defer the implementation later.

******* Implementation
Now we turn into implementation of representation that we abstracted out.
Let we code the straightforward parts first:
#+BEGIN_SRC scheme
(define (collapse-term-to-each term expansion-list)
  (if (= 0 (order term))                ;constant clause
      expansion-list
      (map (lambda (term-list) (collapse-term term term-list)) expansion-list)))



;; predicate for polynomial
(define (polynomial? p) (eq? 'polynomial (type-tag p)))


;; representation for expansion
(define (the-empty-expansion) '())
;; predicate
(define (empty-expansion? e) (null? e))
;; selectors
(define (first-term-list e) (car e))
(define (rest-expansion e) (cdr e))
;; constructor
(define (add-term-list-to-expansion term-list expansion-list)
  (if (empty-expansion? expansion-list)
      (list term-list)
      (let ((L (first-term-list expansion-list)))
        (cond ((term-list<? L term-list) (cons term-list expansion-list))
              ((term-list<? term-list L)
               (cons L (add-term-list-to-expansion
                        term-list
                        (rest-expansion expansion-list))))
              (else (add-term-list-to-expansion
                     (add-term-list term-list L)
                     (rest-expansion expansion-list)))))))
#+END_SRC

Then we should consider the term list representation:
- Should we treat numeral term same as variable term?
  That is, we should coerce numeral to polynomial term?
- Or should we deal numeral term explicitly other than variable term?


This question leads different representation of term list. We could use multiple
representation as we did complex number and the earlier term list
representation. That means we can develop each representation independently. Let
we first consider the latter representation:
#+BEGIN_SRC scheme
(define (add-term-list L1 L2)
  (make-term-list (var-terms L1) (add (num-term L1) (num-term L2))))

;; term-list representation
(define (the-empty-list-term) '())
;; predicate
(define (empty-var-term-list? L) (null? L))
(define (term-list<? L1 L2)
  (var-term-list<? (var-terms L1) (var-terms L2)))

(define (var-term-list<? L1 L2)
  (cond ((empty-var-term-list? L1) (not (empty-var-term-list? L2)))
        ((empty-var-term-list? L2) false)
        (else
         (let ((t1 (head-term L1)) (t2 (head-term L2)))
           (cond ((variable<? (var t1) (var t2))
                  true)
                 ((variable<? (var t2) (var t1))
                  false)
                 ((< (order t1) (order t2)) true)
                 ((> (order t1) (order t2)) false)
                 (else
                  (var-term-list<? (tail-terms L1) (tail-terms L2))))))))
;; constructor
(define (make-term-list-with-num num-term) (make-term-list '() num-term))
(define (make-term-list var-terms num-term) (cons var-terms num-term))
(define (collapse-term var-term term-list)
  (make-term-list
   (collapse-var-term var-term (var-terms term-list))
   (num-term term-list)))
(define (collapse-var-term term term-list)
  (cond ((empty-var-term-list? term-list) (cons term (the-empty-list-term)))
        (else
         (let ((t (head-term term-list)))
           (cond ((variable<? (var t) (var term))
                  (cons term term-list))
                 ((variable<? (var term) (var t))
                  (cons t
                        (collapse-var-term term
                                       (tail-terms term-list))))
                 (else
                  (cons (make-var-term (var term)
                                       (+ (order term)
                                          (order t)))
                        (tail-terms term-list))))))))
#+END_SRC

The rest is straightforward:
#+BEGIN_SRC scheme
;; term representation
(define (make-var-term var order) (list var order))
;; predicate
(define (variable<? v1 v2)
  (symbol>? v1 v2))

;; selectors
(define (var term) (car term))
(define (order term) (cadr term))
#+END_SRC

Let's test it:
#+BEGIN_SRC scheme
(expand '(polynomial x sparse
                     (term 3 (polynomial y dense (polynomial x dense 5 0 0) 0))
                     (term 1 (polynomial z dense 2 0))))
;Value: ((((x 5) (y 1)) . 5) (((x 1) (z 1)) . 2))
#+END_SRC

Yeah! We did half of our task.
****** Rearrange
We should reverse the expansion list to polynomial in canonical order. We could
accomplish the task that is almost analogous to our first half. As we already
constructed abstract data type in expansion, here we can focus on put together
existing code to make sense. Here is the final code:
#+BEGIN_SRC scheme
(define (rearrange expansion-list)
  (cond ((number-expansion-list? expansion-list)
         (get-number expansion-list))   ; => num
        (else
         (let ((x (var (highest-priority-term expansion-list))))
           (make-polynomial x (gather-termlist x expansion-list)))))) ; => polynomial

(define (highest-priority-term es)
  (head-term (var-terms (first-term-list es))))

(define (number-expansion-list? expansion-list)
  (and (empty-var-term-list?
        (var-terms (first-term-list expansion-list)))
       (empty-expansion? (rest-expansion expansion-list))))

(define (get-number e) (num-term (first-term-list e)))

;; dependency
(define (adjoin-term t L) (apply-generic 'adjoin-term t L))
(define (the-empty-termlist) (sparse-empty-termlist))
(define (sparse-empty-termlist) ((get 'the-empty-termlist 'sparse)))
(define (make-term order coeff) ((get 'make 'term) order coeff))

(define (gather-termlist v es)                       ;=> termlist
  (cond ((empty-expansion? es) (the-empty-termlist)) ;base case 1
        ((number-expansion-list? es) (adjoin-term (make-term 0 (rearrange es)) ;base case 2
                                                  (the-empty-termlist)))
        (else
         (let ((t (highest-priority-term es)))
           (if (not (variable=? v (var t)))
               (adjoin-term (make-term 0 (rearrange es)) ;base case 3
                            (the-empty-termlist))
               (let ((unarranged-result (gather t es)))
                 (let ((gathered (car unarranged-result))
                       (rest (cadr unarranged-result)))
                   (adjoin-term (make-term (var-order t)
                                           (rearrange gathered))
                                (gather-termlist v rest)))))))))

(define (gather t es)
  (cond ((number-expansion-list? es)
         (list (the-empty-expansion) es))
        ((empty-expansion? es)
         (list (the-empty-expansion) (the-empty-expansion)))
        (else
         (let ((t1 (highest-priority-term es)))
           (if (or (not (term=? t t1)))
               (list (the-empty-expansion) es)
               (let ((result (gather t (rest-expansion es))))
                 (list (adjoin-term-list-to-expansion
                        (term-list-except-first-var
                         (first-term-list es))
                        (car result))
                       (cadr result))))))))

(define (term-list-except-first-var ts)
  (make-term-list (tail-terms (var-terms ts))
                  (num-term ts)))

(define (term=? t1 t2)
  (and (variable=? (var t1) (var t2))
       (= (order t1) (order t2))))
#+END_SRC

Here we used the analogy with [[Exercise 2.58][Exercise 2.58]] when we dealt with AST. Also we
exploit the type analysis to design these procedure.

Test!
#+BEGIN_SRC scheme
(define test
  (expand '(polynomial x sparse
                       (term 3 (polynomial y dense
                                           (polynomial y dense 5 0 0) 0))
                       (term 1 (polynomial y dense
                                           (polynomial x dense 3 0 0) 0 0 0)))))
;Value: ((((x 3) (y 3)) . 8))
(rearrange test)
;Value: (polynomial x dense (polynomial y dense 8 0 0 0) 0 0 0)

(define test
  (expand '(polynomial y sparse
                       (term 3 (polynomial y dense (polynomial y dense 5 0 0) 0))
                       (term 1 (polynomial y dense (polynomial x dense 3 0 0) 0 0 0)))))
(rearrange test)
;Value: (polynomial x dense (polynomial y sparse (term 4 3)) 0 (polynomial y sparse (term 6 5)))
#+END_SRC

Yes!
****** Addition
With these armamentarium, we can easily implement addition:
#+BEGIN_SRC scheme
(define (mul-poly-add p1 p2)
  (rearrange (append-expansion (expand p1)
                               (expand p2))))
#+END_SRC
****** Multiplication
We need some auxiliary procedure that is analogous to =union= procedure in
[[Example: Representing Sets][previous section]] with =collapse-term=:
#+BEGIN_SRC scheme
(define (collapse-term-list L1 L2)      ;provided that L1 L2 is not empty
  (make-term-list
   (collapse-var-term-list (var-terms L1)
                           (var-terms L2))
   (mul (num-term L1)
        (num-term L2))))

(define (collapse-var-term-list vs1 vs2)
  (cond ((empty-var-term-list? vs1) vs2)
        ((empty-var-term-list? vs2) vs1)
        (else
         (let ((t1 (head-term vs1))
               (t2 (head-term vs2)))
           (cond ((variable<? (var t1) (var t2))
                  (adjoin-var-term
                   t2
                   (collapse-var-term-list vs1 (tail-terms vs2))))
                 ((variable<? (var t2) (var t1))
                  (adjoin-var-term
                   t1
                   (collapse-var-term-list (tail-terms vs1) vs2)))
                 ((variable=? (var t1) (var t2))
                  (adjoin-var-term (make-var-term (var t1)
                                                  (+ (order t1)
                                                     (order t2)))
                                   (collapse-var-term-list
                                    (tail-terms vs1)
                                    (tail-terms vs2)))))))))
#+END_SRC

This procedure collapse two term list (multiply two term list); using the
algorithm of =mul-term-by-all-terms= in our previous polynomial package, we can
accomplish the multiplication:
#+BEGIN_SRC scheme
(define (mul-poly-mul p1 p2)
  (rearrange
   (mul-expansion (expand p1) (expand p2))))

(define (mul-expansion e1 e2)
  (if (empty-expansion? e1)
      (the-empty-expansion)
      (append-expansion (mul-term-list-by-all-term-lists
                         (first-term-list e1) e2)
                        (mul-expansion (rest-expansion e1) e2))))

(define (mul-term-list-by-all-term-lists L1 e)
  (if (empty-expansion? e)
      (the-empty-expansion)
      (let ((L2 (first-term-list e)))
        (adjoin-term-list-to-expansion
         (collapse-term-list L1 L2)
         (mul-term-list-by-all-term-lists L1 (rest-expansion e))))))
#+END_SRC
Which conclude our example.
****** Deploy
All we have to do is wrap around what we built as pacakge that extends
polynomial pacakge:
#+BEGIN_SRC scheme
(define (install-multivariate-polynomial-package)
  ,*** What we built
  ;; interface to rest of system
  (define (tag p) (attach-tag 'polynomial p)) ;for reattach the tag for working with this package
  (put 'add '(polynomial polynomial) (lambda (p1 p2) (mul-poly-add (tag p1) (tag p2))))
  (put 'mul '(polynomial polynomial) (lambda (p1 p2) (mul-poly-mul (tag p1) (tag p2))))
  (put 'sub '(polynomial polynomial) (lambda (p1 p2) (mul-poly-add (tag p1) (neg (tag p2))))) ;exploit generic operator, neg
  ;; test fragment
  ;; (define test '(polynomial x sparse (term 3 (polynomial y dense (polynomial y dense 5 0 0) 0)) (term 1 (polynomial y dense (polynomial x dense 3 0 0) 0 0 0))))
  ;; (define test1 '(polynomial y sparse (term 3 (polynomial y dense (polynomial y dense 5 0 0) 0)) (term 1 (polynomial y dense (polynomial x dense 3 0 0) 0 0 0))))
  ;; (add test test1)
  ;; (sub test test1)
  ;; (mul test test1)
 )
#+END_SRC
**** Lecture 4B: Generic Operators
In this section, 2.5, we built our system primarily relying on data-directed
programming; using this scheme, we were able to inherit automatically the
ability to compute multivariate polynomial (in limited sense, as we noted
before) by just implementing univariate polynomial arithmetic system and
integrate that in our generic arithmetic system.

In this programming style, we get rid of the "manager" and automated with
generic procedure called =apply-generic=. By doing that, we allowed to develop
our own package without consulting with other package developer; we only needed
to add appropriate procedure in operator table so that =apply-generic= look for
and dispatch on type appropriately.

So far, we are quite happy with our craft; however we start to realize there are
some unfortunate things even in this genuine strategy: As noted in the lecture,
the individual package procedures can freeze the higher level procedure by
adding some procedure that is constrained in some fashion. This "unfortunate"
due to the highly decentralized structure of our programming scheme; for
instance we couldn't decide where specific coercion procedure should be
included: We end up with making up other kind operator table that contains
coercion procedure and we had to modify =apply-generic= accordingly. Even with
that, our coercion scheme is limited in that we had to supply explicitly how our
arithmetic types related each other-- =tower=. It's a very poorly structured
hierarchical system. An obvious example of the freezing generic operation by
user defined structure is [[Exercise 2.94][exercise 2.94]]; previously we defined "simplifying
procedure"-- =drop= -- and integrated in our =apply-generic=. But as we (user)
extends the rational arithmetic system to accommodate all the object that
satisfy the rational arithmetic axioms (see below), the =drop= procedure, which
is specific to number system, start to not work at all. That root from our
crude handling for hierarchical structure with too immense flexibility that we
can not tether.

Further more, in following exercise, we are about to convert rational number to
generic rational object, which encompass all the object that has structure like
rational number-- object that have numerator and denominator with satisfying
rational arithmetic axioms. That allows complex numbered rational object and
rational polynomials and so on, "automatically"; however obvious there is no
"GCD" operators for these. One way to deal with this problem is to give up to
reduce the numerator and denominator to its lowest term, which leads to our
rational number system also to be not the conventional rational number, which we
learned in elementary school.

On the other hand, this generic approach also leads some insight about the
abstract algebra: As polynomial has its own "GCD" like operation as its division
has a lot of analogy with integer division, we can abstract out the object that
we have considered in concrete manner in the more generic context, which can be
used in another specific field that have not considered previously. The other
method for this problem, as I hinted already, use the generic properties of
rational object, that is, to formulate the axioms objects should satisfy to have
rational type; also we have to impose that condition to our rational arithmetic
package to ensure the made rational object can be supplied to any other
arithmetic operations as expected.

Finally, the alternative approach have been adopted in many modern programming
language: OOP. In that approach we can solve the hierarchical structure
elegantly using super type and sub type relation. And more, the strictly typed
language exploit this paradigm to maximize the flexibility, which constrained by
the compile time type checking. Also this scheme capture the ADT concept as
special expression called /class/ using that structure, we can achieve the guts
of ADT more elegantly. Now days, it seems like people found this scheme as most
practical one[fn:5].
**** Exercise 2.93
We can do what text indicated straightforwardly. Then we can test the given
code:
#+BEGIN_SRC scheme
(define p1 (make-polynomial 'x '(sparse (term 2 1) (term 0 1))))
(define p2 (make-polynomial 'x '(sparse (term 3 1) (term 0 1))))
(define rf (make-rational p2 p1))
;Value: (rational (polynomial x dense 1 0 0 1) polynomial x dense 1 0 1)
(add rf rf)
;Value: (rational (polynomial x dense 2 0 2 2 0 2) polynomial x dense 1 0 2 0 1)
#+END_SRC
**** Exercise 2.94
We can support "GCD" procedure in univariate polynomial version by adding
following code to polynomial package:
#+BEGIN_SRC scheme
  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (remainder-terms a b))))

  (define (remainder-terms a b)
    (cadr (div-terms a b)))

  (define gcd-poly
    (arith-poly gcd-terms "GCD-POLY"))

  (put 'gcd '(polynomial polynomial)
       (lambda (p1 p2) (tag (gcd-poly p1 p2))))
#+END_SRC

And we also implement GCD for integer number in scheme number package:
#+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (put 'gcd '(integer integer) gcd)
#+END_SRC

Then rest is the add GCD procedure to our disposal:
#+BEGIN_SRC scheme
(define greatest-common-divisor (make-generic-op 'gcd))
#+END_SRC

Make our rational arithmetic package to exploit this generic operator:
#+BEGIN_SRC scheme
  (define (make-rat n d)
    (let ((g (greatest-common-divisor n d)))
      (cons (div n g) (div d g))))
#+END_SRC
* Footnotes

[fn:5] There is yet another approach, namely type class being adopted and
introduced in Haskell.

[fn:4] The definition of sparse and dense polynomials are defined in the text book.

[fn:3] Here we say "powerful" in that meaning of chapter 1, having closure property in it.

[fn:2] Note that we naturally inherit the lisp's power, that is, of manipulating
list. That means we don't have to parse all the expression to get the token,
which we have to do usually when we implement the complier or interpreter.

[fn:1] Well, there are several candidates for doing this like [[http://plantuml.com/en/][plantUML]], [[https://www.graphviz.org/][dot]]
, etc. If I can afford to learn those, I'd like to upload these study note as
well someday.

#  LocalWords:  SICP
