#+TITLE: Projects from SICP 2005
* Project 1 -- Those amazing Red Sox!
** Purpose
The purpose of Proejct 1 is for you to gain experience with writing and testing
relatively simple procedures. For each problem below, include your code as well
as comments and explanations of your code, *and* demonstrate your code's
functionality against a set of test cases. You should always create and include
your own additional, meaningful test cases in addition to provided test code to
ensure that your code works not only on typical inputs, but also on "boundary"
or difficult cases. Get in the habit of writing and running these test cases
after *every* procedure you write -- no matter how trivial the procedure may
seem to you.
** Scenario
As you may have noticed this past fall (note that the time of being texted was
2005), a remarkable event took place -- the Boston Red Sox won the World Series
for the first time in 86 years! You may also have noticed long time Boston
residents (such as MIT professors) walking about in a state of bliss. Because
many of these folks don't want to have to wait another 86 years for this to
happen again (which happened last year, I mean 2018), "Red Sox Nation" has hired
us to provide some help. In particular, we are to investigate the possibility of
perfecting a baseball robot ("basebot") that can accurately throw and can hit
with power.
** Problem 1: Some simple physics
We are going to begin by modeling how far a baseball can travel -- the same
physics will hold for both hitting a ball and throwing a ball. We are going to
simplify things by assuming that baseballs don't spin as they move (clearly
false but it makes life much easier). This means we can treat the movement of a
baseball as if it were restricted to a two-dimensional plane. So what happens
when a baseball is hit? For the moment, we'll model a baseball as a particle
that moves along a single dimension with some initial position /u/, some initial
velocity /v/, and some initial acceleration /a/. The equation for the position
of the baseball at time /t/, given /a/, /v/, and /u/ is
$u_{t}= 1/2 a t^{2} + v t + u$. Note that this denotes a first order
differential equation in time. Later, we can apply this equation to either the
horizontal ($x$) component of baseball motion, or the vertical ($y$) component
of baseball motion.

Write a procedure that takes as input values for =a, v, u,= and =t= and returns
as output the position of the baseball at time =t=:
#+BEGIN_SRC scheme
(define position
  (lambda (a v u t)
    (+ (* (/ a 2)
	  (square t))
       (* v t)
       u)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
1 (user) => (position 0 0 0 0)

;Value: 0

1 (user) => (position 0 0 20 0)

;Value: 20

1 (user) => (position 0 5 10 10)

;Value: 60

1 (user) => (position 2 2 2 2)

;Value: 10

1 (user) => (position 5 5 5 5)

;Value: 185/2
#+END_SRC

As our code of =position= just return the computed value, not through branch, so
we tested all the branches of the procedure.
** Problem 2: Basic Math
One of our goals is to determine how far a baseball will travel in the air, if
it is hit with some initial velocity at some initial angle with respect to the
ground. To do this, we will need to know when the baseball hits the ground, and
for that we'll want to find when the $y$ coordinate of the baseball's position
reaches zero. This can be discovered by finding the roots of the $y$ position
equation, and selecting the one that is larger (later in time). The proper tool
for this is the quadratic formula. Given the coefficients of the quadratic
equation $a z^{2} + b z + c = 0$, write a procedure to find one of the roots
(call this =root1=), and another procedure to find the other root (call this
=root2=).

#+BEGIN_SRC scheme
(define root1
  (lambda (a b c)
    (let ((D (- (square b)              ;b^2 - 4ac
		(* 4 a c))))
      (if (< D 0)
	  false				;invalid input
	  (/ (- (- b) (sqrt D))
	     (* 2 a))))))

(define root2
  (lambda (a b c)
    (let ((D (- (square b)              ;b^2 - 4ac
		(* 4 a c))))
      (if (< D 0)
	  false				;invalid input
	  (/ (+ (- b) (sqrt D))
	     (* 2 a))))))
#+END_SRC

And also test:
#+BEGIN_SRC scheme
(root1 5 3 6)				;when D < 0
;Value: #f
(root1 1 2 1)				;when D = 0
;Value: -1
(root1 1 4 2)				;when D > 0
;Value: -3.414213562373095
(root2 5 3 6)				;when D < 0
;Value: #f
(root2 1 2 1)				;when D = 0
;Value: -1
(root2 1 4 2)				;when D > 0
;Value: -.5857864376269049
#+END_SRC
This code constitute path-complete test.
** Problem 3: Flight Time
Given an initial upward velocity (in meters per second, or m/s) and initial
elevation or height (in meters, or m), write a procedure that computes how long
the baseball will be in flight. Remember that gravity is a downward acceleration
of 9.8m/s^{2}. Note that to solve this you will need a root of a quadratic
equation. Try using =root1=, and using =root2=. Only one of these solutions
makes sense. Which one? And why? Use this to create a correct version of the
procedure below.

Note that
\begin{align*}
\left.
\begin{matrix}
a &<0\\
b &>0\\
c &>0\\
\end{matrix}
\right\}
\implies
\frac{-b - \sqrt{D}}{2a} > 0 > \frac{-b + \sqrt{D}}{2a}
\end{align*}
as noted above our acceleration is negative initial, velocity would be positive
as it given upward velocity, and as the initial height should be positive, our
situation fit into above equation, which indicate =root1= would suit in our
case:
#+BEGIN_SRC scheme
(define time-to-impact
  (lambda (vertical-velocity elevation)
    (if (and (negative? elevation)
             (negative? vertical-velocity)) ;cannot hit the grount at any time > 0
        false
        (root1 (- (/ gravity 2)) vertical-velocity elevation)))) ;with other possibitities coped by root1 procedure.
#+END_SRC

Also note that in any case, as long as the acceleration is negative, following
equation holds when $D > 0$
\[
\frac{-b - \sqrt{D}}{2a} > \frac{-b + \sqrt{D}}{2a}
\].

So, we used this fact in above procedure.

As usual, here is the test:
#+BEGIN_SRC scheme
(time-to-impact 10 3)			;positive initial velocity with positive elevation
;Value: 2.306284408328438
(time-to-impact -20 3)			;negative initial velocity with positive elevation
;Value: .14485889559025134
(time-to-impact 1 -2)			;positive initial velocity with negative elevation, whose condition cannot hit the ground. Note that it handled by root1 procedure.
;Value: #f
(time-to-impact -2 -3)			;negative initial velocity with negative elevation; cannot hit the ground.
;Value: #f
#+END_SRC

In some cases, we may want to know how long it takes for the ball to drop to a
particular height, other than 0. Using your previous procedures as a template,
write a procedure that computes the time for the ball to reach a given target
elevation.

As we already path-completed the previous procedure, we are good to use that
procedure to this:
#+BEGIN_SRC scheme
(define time-to-height
  (lambda (vertical-velocity elevation target-elevation)
    (time-to-impact vertical-velocity (- elevation target-elevation))))
#+END_SRC
** Problem 4: Flight Distance
Suppose the baseball is hit with some velocity $v$, at a starting angle \alpha
relative to the horizontal (in degrees), and from an initial elevation (in
meters). We wish to compute the distance in the horizontal direction the
baseball will travel by the time it lands.

Write a procedure =travel-distance-simple= that returns the lateral distance the
baseball thrown with given velocity, angle, and initial elevation will travel
before hitting the ground.

We are going to encode following mathematical equation directly:
\begin{align*}
v_{x} &= v \cos \alpha\\
d_{x} &= v \cos \alpha \times t_{\text{impact}}
\end{align*}
#+BEGIN_SRC scheme
(define travel-distance-simple
  (lambda (elevation velocity angle)
    (let ((alpha (degree2radian angle)))
      (let ((v_x (* velocity
                    (cos alpha)))
            (v_y (* velocity
                    (sin alpha))))
        (* v_x
           (time-to-impact v_y elevation))))))
#+END_SRC

Here is the test cases:
#+BEGIN_SRC scheme
(define case1 (travel-distance-simple 1 45 0)) ;case 1
case1                                          ;meter
;Value: 20.32892781536815
(meters-to-feet case1)                         ;feet
;Value: 67.0854617907149
(define case2 (travel-distance-simple 1 45 45)) ;case2
case2                                           ;meter
;Value: 207.6278611514906
(meters-to-feet case2)                          ;feet
;Value: 685.171941799919
(define case3 (travel-distance-simple 1 45 90)) ;case 3
case3                                           ;meter
;Value: 5.496418989612468e-4
(meters-to-feet case3)                          ;feet
;Value: 1.8138182665721145e-3
#+END_SRC

Notice the distance traveled in feet for a ball hit at a 45 degree angle, with
this bat speed. Seems incredible -- right? We'll come back to this in a little bit.

Wow.. 207 meters...
** Problem 5: What's the best angle to hit?
Before we figure out why professional players don't normally hit 700 foot home
runs, let's first see if we can find out the optimal angle at which to launch a
baseball, in order to have it travel the furthest.

To find the best angle to hit, we design iterative process as follows:
1. Set initial max distance with max angle (0 and 0 would suffice).
2. If angle greater than upper bound then return max angle.
3. Calculate distance with the current angle.
4. If that distance greater than max distance, set max distance to current
   distance and max angle to current angle.
5. Increment angle with the given step.
6. Iterate 2 \to 5.


Here is the straightforward encode:
#+BEGIN_SRC scheme
(define (find-best-angle velocity elevation)
  (define upper-bound 90)
  (define increment 1)
  (define (next ang) (+ ang increment))
  (define (iter angle max-dist max-ang)
    (if (> angle upper-bound)
        max-ang
        (let ((dist (travel-distance-simple elevation velocity angle)))
          (let ((next-ang (next angle)))
            (if (> dist max-dist)
                (iter next-ang dist angle)
                (iter next-ang max-dist max-ang))))))
  (iter 0 0 0))
#+END_SRC

And here is the test or sample points:
#+BEGIN_SRC scheme
1 (user) => (find-best-angle 45 1)

;Value: 45

1 (user) => (find-best-angle 23 0.8)

;Value: 45

1 (user) => (find-best-angle 21 10)

;Value: 40
;; ↑ is not practical to our situation where we consider the baseball hitten by batter.
#+END_SRC
So we can conclude that in the baseball hitting case, 45 degrees is best angle
to hit the ball.
** Problem 6: So why aren't baseball outfield 600 feet deep?
Let's go back to our distances. Why are these numbers for distances hit so
unrealistic? -- because we haven't accounted for air fiction or drag. (Of course
there are some other effects, like spin, but we'll just stick with drag). Let's
think about this. Newton's equation basically says that the movement of the ball
will be governed by:
#+BEGIN_CENTER
Drag + gravity = mass * acceleration
#+END_CENTER

We can get the mass of a baseball (.15kg). We know that force due to gravity --
mass * 9.8 m/s^{2}. The force due to drag is given by:
#+BEGIN_CENTER
$1/2 C \rho A V^{2}$
#+END_CENTER
Where $C$ is the drag coefficient (about 0.5 for baseball sized objects); \rho
is the density of air (about 1.25 kg/m^{3} at sea level for moderate humidity --
not a bad approximation for Boston, but about 1.06 for Denver); $A$ is the
cross-sectional area of the baseball (which is $\pi D^{2}/4$, where $D$ is the
diameter of a baseball -- about 0.074 m). Let's denote $1/2 C \rho A$ by the
constant $\beta$. Then we see that the drag on a baseball is basically
proportional to the square of the velocity of the ball. So there is more drag
when the ball is moving faster.

How can we compute the distance traveled by a baseball, but taking into account
this drag effect? Basically we have four coupled linear differential equations:
Let's let $x$ and $y$ denote the two components of position of the baseball, and
let's let $u$ denote the velocity in the horizontal direction, and $v$ denote
the velocity in the vertical direction. We will let *V* denote the magnitude of
the velocity. Then the equations of motion are:
\begin{align*}
dx/dt &= u\\
dy/dt &= v\\
du/dt &= - \frac{1}{m} \sqrt{u^{2} + v^{2}} u \beta \\
dv/dt &= - \frac{1}{m} \sqrt{u^{2} + v^{2}} v \beta - g
\end{align*}

We can rewrite these as
\begin{align*}
dx &= u dt\\
dy &= v dt\\
du &= - \frac{1}{m} \sqrt{u^{2} + v^{2}} u \beta dt\\
dv &= - \left\{ \frac{1}{m} \sqrt{u^{2} + v^{2}} v \beta + g \right\} dt
\end{align*}

We also have some initial conditions on these parameters

\begin{align*}
x_{0} &= 0\\
y_{0} &= h\\
u_{0} &= \text{\bf{V}} \cos \alpha \\
v_{0} &= \text{\bf{V}} \sin \alpha
\end{align*}
where \alpha is the angle of the initial hit with respect to the ground, $V$ is
the initial velocity, and $h$ is the initial height of the ball.

To find the distance traveled, we need to integrate these equation (one can
consider this as second ordered differential equation with respect to $x,y$, but
this equation is not linear; thus we rely on the numerical integration anyway).
That is, starting with the initial values, we want to move forward a small step
in time (say 0.01 seconds), and compute the change in $x$ and $y$. Similarly, we
want to compute the change in $u$ and $v$, and thus, the new values for $u$ and
$v$. We can keep recursively estimating these values until the value for $y$
drops below 0, in which case the value for $x$ tells us the distance traveled.

This constitute algorithm that compute the distance traveled informally; that
is, it dictated termination condition, initial condition, and way to transit one
step. Let's restate what described above as algorithm:
1. Start with initial condition.
2. If termination condition? return $x$
3. Transition one step.
4. Iterate 2 \to 3.


Here as we explained all the details above informal description, omitted that
informations to avoid to get bogged down by that.

And here is the code:
#+BEGIN_SRC scheme
(define integrate                       ;returns x when y becomes negative.
  (lambda (x0 y0 u0 v0 dt g m beta)
    (define (iter x y u v)
      (if (< y 0)                       ;termination condition
          x
          (let ((speed (sqrt (+ (square u)
                                (square v))))
                (v-factor (* (/ 1 m)
                             beta)))
            (let ((dx (* u dt))
                  (dy (* v dt))
                  (du (* (- v-factor)
                         speed
                         u
                         dt))
                  (dv (* (- (+ (* v-factor
                                  speed
                                  v)
                               g))
                         dt)))
              (iter (+ x dx)            ;transition
                    (+ y dy)
                    (+ u du)
                    (+ v dv))))))
    (iter x0 y0 u0 v0)))                ;initial condition
#+END_SRC

And the initial setter:
#+BEGIN_SRC scheme
(define (travel-distance elevation speed angle)
  (let ((alpha (degree2radian angle)))
    (integrate 0
               elevation
               (* speed
                  (cos alpha))
               (* speed
                  (sin alpha))
               0.01
               gravity
               mass
               beta)))
#+END_SRC

And as we told, we determine the distance a baseball will travel with an angle
of 45 degrees, using velocities of 45 m/s, 40 m/s, 35 m/s:
#+BEGIN_SRC scheme
1 (user) => (meters-to-feet (travel-distance 1 45 45))

;Value: 304.3610105268868
; Home run!

1 (user) => (meters-to-feet (travel-distance 1 40 45))

;Value: 269.5039326610774
; Close!

1 (user) => (meters-to-feet (travel-distance 1 35 45))

;Value: 231.99119882455975
; Flyout!!
#+END_SRC

To find out the effect of angle on the travel distance, let we code as follows:
#+BEGIN_SRC scheme
(define (iterate-on-angle method)
  (lambda (velocity elevation)
    (define upper-bound 90)
    (define increment 1)
    (define (next ang) (+ ang increment))
    (define (iter angle max-dist max-ang)
      (if (> angle upper-bound)
          max-ang
          (let ((dist (method elevation velocity angle)))
            (let ((next-ang (next angle)))
              (if (> dist max-dist)
                  (iter next-ang dist angle)
                  (iter next-ang max-dist max-ang))))))
    (iter 0 0 0)))
#+END_SRC
What is generalized =find-best-angle=. We can rewrite =find-best-angle= as
#+BEGIN_SRC scheme
(define find-best-angle
  (iterate-on-angle travel-distance-simple))
#+END_SRC

Back to our task, now we can estimate described effect using:
#+BEGIN_SRC scheme
(define test-effect-of-angle-and-best-angle
  (iterate-on-angle (lambda (elevation velocity angle)
                      (let ((distance (travel-distance elevation velocity angle)))
                        (if (homerun? distance)          ;display result
                            (begin (newline)
                                   (display "Angle (degrees) : ")
                                   (display angle)
                                   (display "\tdistance (meters) : ")
                                   (display distance)
                                   (display "\t(feets) : ")
                                   (display (meters-to-feet distance))))
                        distance))))

(define (homerun? distance)
  (> (meters-to-feet distance) 300))
#+END_SRC
which display each angle with travel distance that let the ball land over the
fence:
#+BEGIN_SRC scheme
1 (user) => (test-effect-of-angle-and-best-angle 45 1)

Angle (degrees) : 31	distance (meters) : 91.51532072764736	(feets) : 302.00055840123633
Angle (degrees) : 32	distance (meters) : 92.06394866247652	(feets) : 303.81103058617254
Angle (degrees) : 33	distance (meters) : 92.68907465558765	(feets) : 305.87394636343925
Angle (degrees) : 34	distance (meters) : 93.0990652827013	(feets) : 307.2269154329143
Angle (degrees) : 35	distance (meters) : 93.4412381854694	(feets) : 308.35608601204905
Angle (degrees) : 36	distance (meters) : 93.5813025098057	(feets) : 308.8182982823588
Angle (degrees) : 37	distance (meters) : 93.79053827815333	(feets) : 309.508776317906
Angle (degrees) : 38	distance (meters) : 93.93134422944617	(feets) : 309.9734359571724
Angle (degrees) : 39	distance (meters) : 93.8787236285791	(feets) : 309.799787974311
Angle (degrees) : 40	distance (meters) : 93.76322959233745	(feets) : 309.4186576547136
Angle (degrees) : 41	distance (meters) : 93.70356375240091	(feets) : 309.22176038292304
Angle (degrees) : 42	distance (meters) : 93.45847229577446	(feets) : 308.4129585760557
Angle (degrees) : 43	distance (meters) : 93.1494935264519	(feets) : 307.3933286372913
Angle (degrees) : 44	distance (meters) : 92.66568484432294	(feets) : 305.7967599862657
Angle (degrees) : 45	distance (meters) : 92.23060925057175	(feets) : 304.3610105268868
Angle (degrees) : 46	distance (meters) : 91.73050392599892	(feets) : 302.7106629557964
Angle (degrees) : 47	distance (meters) : 91.06247282999192	(feets) : 300.50616033897336
;Value: 38
#+END_SRC

So it conclude that if the batter swings the bat at about 100 mph (or 45 m/s),
homerun angle range would be 31 \to 47 degrees; best angle with given situation
is 38 degrees.

If it were Denver, i.e.
#+BEGIN_SRC scheme
;; (define density 1.25)  ; kg/m^3
(define density 1.06)  ; for denver
#+END_SRC

Then the same test results in
#+BEGIN_SRC scheme
1 (user) => (test-effect-of-angle-and-best-angle 45 1)

Angle (degrees) : 25	distance (meters) : 91.80757292364773	(feets) : 302.9649906480375
Angle (degrees) : 26	distance (meters) : 93.23537186687204	(feets) : 307.6767271606778
Angle (degrees) : 27	distance (meters) : 94.39458365678752	(feets) : 311.5021260673988
Angle (degrees) : 28	distance (meters) : 95.47489744142004	(feets) : 315.06716155668613
Angle (degrees) : 29	distance (meters) : 96.6491018216814	(feets) : 318.9420360115486
Angle (degrees) : 30	distance (meters) : 97.5677682297549	(feets) : 321.9736351581912
Angle (degrees) : 31	distance (meters) : 98.24273978796408	(feets) : 324.2010413002815
Angle (degrees) : 32	distance (meters) : 99.00759192365273	(feets) : 326.725053348054
Angle (degrees) : 33	distance (meters) : 99.69345769019637	(feets) : 328.988410377648
Angle (degrees) : 34	distance (meters) : 100.14639278028076	(feets) : 330.4830961749265
Angle (degrees) : 35	distance (meters) : 100.5271971345883	(feets) : 331.73975054414143
Angle (degrees) : 36	distance (meters) : 100.98266355990877	(feets) : 333.24278974769896
Angle (degrees) : 37	distance (meters) : 101.21502833182811	(feets) : 334.0095934950328
Angle (degrees) : 38	distance (meters) : 101.3744208976632	(feets) : 334.53558896228856
Angle (degrees) : 39	distance (meters) : 101.3233691316595	(feets) : 334.36711813447636
Angle (degrees) : 40	distance (meters) : 101.33908658868884	(feets) : 334.4189857426732
Angle (degrees) : 41	distance (meters) : 101.28079791925339	(feets) : 334.22663313353615
Angle (degrees) : 42	distance (meters) : 101.02041185502884	(feets) : 333.3673591215952
Angle (degrees) : 43	distance (meters) : 100.69139652226286	(feets) : 332.28160852346747
Angle (degrees) : 44	distance (meters) : 100.29330967725063	(feets) : 330.9679219349271
Angle (degrees) : 45	distance (meters) : 99.82569987946395	(feets) : 329.42480960223105
Angle (degrees) : 46	distance (meters) : 99.28810645473736	(feets) : 327.6507513006333
Angle (degrees) : 47	distance (meters) : 98.680059495752	(feets) : 325.64419633598163
Angle (degrees) : 48	distance (meters) : 97.89056434436357	(feets) : 323.0388623363998
Angle (degrees) : 49	distance (meters) : 97.14303748827358	(feets) : 320.57202371130285
Angle (degrees) : 50	distance (meters) : 96.21859535764192	(feets) : 317.52136468021837
Angle (degrees) : 51	distance (meters) : 95.2272364727326	(feets) : 314.2498803600176
Angle (degrees) : 52	distance (meters) : 94.16843722545231	(feets) : 310.75584284399264
Angle (degrees) : 53	distance (meters) : 93.04166763942294	(feets) : 307.03750321009574
Angle (degrees) : 54	distance (meters) : 91.84639167839042	(feets) : 303.0930925386884
;Value: 38
#+END_SRC

Quite impressive.
** Problem 7: Throwing instead of hitting
Now let's turn this around. Instead of worrying about how far the ball will
carry when hit, suppose we want a robotic fielder that can throw the ball
accurately and efficiently. For this, we want to determine the best angle to
throw the ball at a given velocity in order to reach a target a given distance
away in the shortest amount of time. We will assume the target is at height 0
(i.e. on the ground) -- we could do this for a given height of the target but
we'll assume that our fielders are good at catching things at ground level!

We need to write a procedure (or set or procedures) that use the same
integration idea to accomplish the following:
- Given an *input velocity* and *desired distance* (plus the other parameters
  such as mass of the ball, the beta coefficient, gravity, and the height at
  which the throw was made),
- we want to *try different initial angles* (ranging from -90 to 90 degrees) at
  which to throw.
- If throwing at a particular angle will result in the ball traveling roughly
  the desired distance (up to some error) then we want to find the time it takes
  for the ball to reach the target using this trajectory. (a variation of our
  =integrate= will do)
- Finally, we want to find the trajectory that results in the shortest time,
  given a fixed initial velocity magnitude (a variation of =find-best-angle=
  will do).


Let's do our job; but we need to consider the case that with given velocity the robotic
fielder can not throw specified distance at all. The problem statement suggests
we should return 0 so that we can tell this case from the others

*** A variation of =integrate=
Now we want =integrate= return time also not only distance. If we allowed to use
data structure called pair it is so easy stuff; but we are supposed not to know
any of that here we use higher order function instead of that.

As the termination condition is as same of the batting, all the change we should
make is trace additional integrate variable -- time. To do this we generalize
=integrate= procedure:
#+BEGIN_SRC scheme
(define (intergrate-gen terminate? select)
  (lambda (x0 y0 u0 v0 dt g m beta)
    (define (iter x y u v t)
      (if (terminate? x y u v t)        ;termination condition
          (select x y u v t)
          (let ((speed (sqrt (+ (square u)
                                (square v))))
                (v-factor (* (/ 1 m)
                             beta)))
            (let ((dx (* u dt))
                  (dy (* v dt))
                  (du (* (- v-factor)
                         speed
                         u
                         dt))
                  (dv (* (- (+ (* v-factor
                                  speed
                                  v)
                               g))
                         dt)))
              (iter (+ x dx)            ;transition
                    (+ y dy)
                    (+ u du)
                    (+ v dv)
                    (+ t dt))))))
    (iter x0 y0 u0 v0 0)))

(define integrate                       ;returns x when y becomes negative.
  (integrate-gen
   (lambda (x y u v t) (< y 0))
   (lambda (x y u v t) x)))
#+END_SRC

Then we can use the following to collect the time:
#+BEGIN_SRC scheme
(define (travel-desired-distance-time desired-distance elevation speed angle)
  (let ((epsilon 0.5))                  ;tolerance (m)
    (travel (integrate-gen
             (lambda (x y u v t)
               (or (< y 0)
                   (> x (+ desired-distance epsilon)))) ;termination
             (lambda (x y u v t)
               (if (and (< y 0)
                        (< (abs (- x desired-distance)) epsilon))
                   t                    ;return
                   0))))                ;default value
    elevation speed angle))
#+END_SRC

Well, in this way we broke the abstraction barrier by the very lower procedure,
=travel= procedure to know about when to terminate and what to return; even
more, the default value, which definitely defined at the very higher level of
procedure, thus we should be able to change that value easily and defer the
decision what the value should be.

Also, as we learned that data structure -- pair -- even before the higher order
procedure! So if we are good to use higher order procedure, so does pair!

Let's reflect that fact to our code:
#+BEGIN_SRC scheme
(define (travel method elevation speed angle)
  (let ((alpha (degree2radian angle)))
    (method 0
            elevation
            (* speed
               (cos alpha))
            (* speed
               (sin alpha))
            0.01
            gravity
            mass
            beta)))

(define (travel-distance-with-time elevation speed angle)
  (travel
   (integrate-gen
    (lambda (x y u v t) (< y 0))
    (lambda (x y u v t) (make-dist-time x t)))
   elevation speed angle))

;; wrapper structure
(define (make-dist-time x t) (cons x t))
(define (dist p) (car p))
(define (time p) (cdr p))
#+END_SRC

*** A variation of =find-best-angle=
We modified integration procedure to return the pair of traveled distance and
traveled time. Using this procedure we can find the minimum travel time when we
throw the ball to desired distance:
#+BEGIN_SRC scheme
(define (iterate-on-angle lower upper method update? return)
  (lambda (velocity elevation)
    (define increment 0.1)
    (define (next ang) (+ ang increment))
    (define (iter angle extremum ext-ang)
      (if (>= angle upper)
          (return ext-ang extremum)
          (let ((result (method elevation velocity angle)))
            (let ((next-ang (next angle)))
              (if (update? result extremum)
                  (iter next-ang result angle)
                  (iter next-ang extremum ext-ang))))))
    (iter lower 0 0)))

(define (throw-desired-distance velocity desired-distance height)
  (let ((epsilon 0.5))                  ;distance tolerance (m)
    ((iterate-on-angle
      -90                               ;lower bound angle
      90                                ;upper bound angle
      (lambda (elevation velocity angle)
        (let ((result (travel-distance-with-time elevation velocity angle))) ;distance-time pair
          (if (< (abs (- (dist result) desired-distance)) epsilon)           ;within tolerance?
              (time result)                                                  ;return that time
              0)))                                                           ;return default time
      (lambda (current min)                                                  ;update condition
        (and (not (zero? current))
             (or (zero? min)
                 (< current min))))
      cons)                             ;construct pair that contains angle with minimum travel time
     velocity height)))                 ;initial velocity and height at which the throw made
#+END_SRC

**** With these procedure we can determine the required question: If our catcher has
a gun for an arm, and can throw at 100 mph (or 45 m/s), how long does it take to
reach second base (about 36 m apart from home plate)? How long if he throws at
35 m/s? of at 55 m/s?

Results:
#+BEGIN_SRC scheme
1 (user) => (throw-desired-distance 45 36 1)

;Value: (4.3999999999991655 . .9300000000000006)

1 (user) => (throw-desired-distance 35 36 1)

;Value: (8.399999999999151 . 1.1900000000000008)

1 (user) => (throw-desired-distance 55 36 1)

;Value: (2.399999999999165 . .7600000000000005)
#+END_SRC

The =car= of returned is angle at which the minimum time made, the =cdr= of it
is that minimum time.

**** Note that a really good base runner should be able to get from first to second
base in roughly 3 seconds. If the pitcher is throwing at 90 mph how long does it
take to reach home? If the catcher throws at 90 mph, how much time does he have
to catch and release the ball if he is going to put out a runner trying to steal
second?

Since 90 mph is approximately equals to 40 m/s and the whole distance the ball
travel is about 18 + 36 m, we can estimate what we requested as follows:
#+BEGIN_SRC scheme
1 (user) => (throw-desired-distance 40 18 1)

;Value: (-8.35914670815896e-13 . .47000000000000025)

1 (user) => (throw-desired-distance 40 36 1)

;Value: (5.89999999999916 . 1.0300000000000007)
#+END_SRC

So, the catcher should catch and release the ball in 1.5 seconds.
**** Now we estimate the outfielders.
Suppose an outfielder has a strong arm and can throw at 45 m/s. How quickly can
he throw the ball to a target at a distance of 30m? 60m? 80m? What if he can
throw 55 m/s?

Here is the result:
#+BEGIN_SRC scheme
1 (user) => (throw-desired-distance 45 30 1.8)

;Value: (1.1999999999991642 . .7400000000000004)

1 (user) => (throw-desired-distance 45 60 1.8)

;Value: (10.099999999999145 . 1.7300000000000013)

1 (user) => (throw-desired-distance 45 80 1.8)

;Value: (17.499999999999144 . 2.5899999999999888)

1 (user) => (throw-desired-distance 55 30 1.8)

;Value: (-.30000000000083593 . .6100000000000003)

1 (user) => (throw-desired-distance 55 60 1.8)

;Value: (5.99999999999916 . 1.390000000000001)

1 (user) => (throw-desired-distance 55 80 1.8)

;Value: (10.699999999999143 . 2.0500000000000003)
#+END_SRC

With a weaker outfielder, the same distance results into
#+BEGIN_SRC scheme
1 (user) => (throw-desired-distance 35 30 1.8)

;Value: (4.3999999999991655 . .9600000000000006)

1 (user) => (throw-desired-distance 35 60 1.8)

;Value: (18.999999999999165 . 2.3099999999999947)

1 (user) => (throw-desired-distance 35 80 1.8)

;Value: (0 . 0)
#+END_SRC

This outfielder can not throw the ball to the distance apart 80 m from where the
throw made.
*** Reconsider
We quite struggled to get fitted our task to newly constructed framework that we
generalized. We did that since we know that it decomposes monolithic procedures
into several procedures, each of which are general enough to do have meaning
what they are computing. This concept was supposed to be dealt with in the next
project -- not here. Actually our problem statement also implies this fact -- it
guides us to write procedures by explanatory description of algorithm informally.

Here we follow that step not to be obsessed by clever implementing. Here is the
informal algorithm we are going to code:
1. Take velocity, desired distance, etc for formal parameter our whole
   procedure -- i.e. as entry point.
2. For each angle \in $[-90, 90]$, integrate whose termination condition is $(x
   > \text{desired distance})~or~(y < 0)$
   , which means terminate integral whenever our throwing turns out to overshoot the target
   or hit the ground.
3. For updating step of integration, we call another procedure if the
   termination condition satisfy given situation:
   If ($x$ in the range -- desired distance \pm tolerance) then if $t$ is less
   than the minimum time being searched so far, update the minimum time with the
   corresponding angle (we can do this by calling outermost loop with updated
   minimum time and angle).
4. If the loop end by exceeding the upper limit of angle (90 degrees in our
   case), return the minimum time (as we will set the initial minimum time
   traveled as 0, so if there is not any trajectory that can reach the desired
   distance then it would return 0 as default value).


Here is the result:
#+BEGIN_SRC scheme
(define (throw-desired-distance velocity desired-distance height)
  (define tolerance 0.5)                ;tolerance 0.5m
  (define upper-limit 90)
  (define lower-limit -90)
  (define increment 0.1)
  (define (next ang) (+ ang increment))
  (define (loop angle minimum-time minimum-angle)
    (if (> angle upper-limit)
        minimum-time
        (integrate-and-update angle minimum-time minimum-angle)))
  (define (integrate-and-update angle minimum-time minimum-angle)
    (define (throw-desired-distance velocity desired-distance height)
  (define tolerance 0.5)                ;tolerance 0.5m
  (define upper-limit 90)
  (define lower-limit -90)
  (define increment 0.1)
  (define (next ang) (+ ang increment))
  (define (loop angle minimum-time minimum-angle)
    (if (> angle upper-limit)
        minimum-time
        (integrate-and-update angle minimum-time minimum-angle)))
  (define (integrate-and-update angle minimum-time minimum-angle)
    (define (in-range? x) (< (abs (- desired-distance x)) tolerance))
    (define (hit-ground? y) (< y 0))
    (define (overshoot? x) (> x (+ desired-distance tolerance)))
    (define integrate (lambda (x0 y0 u0 v0 dt g m beta)
                        (define (iter x y u v t)
                          (if (or (hit-ground? y)
                                  (overshoot? x))   ;termination condition
                              (if (and (in-range? x)
                                       (or (zero? minimum-time)
                                           (< t minimum-time)))
                                  (loop (next angle) t angle)
                                  (loop (next angle) minimum-time minimum-angle))
                              (let ((speed (sqrt (+ (square u)
                                                    (square v))))
                                    (v-factor (* (/ 1 m)
                                                 beta)))
                                (let ((dx (* u dt))
                                      (dy (* v dt))
                                      (du (* (- v-factor)
                                             speed
                                             u
                                             dt))
                                      (dv (* (- (+ (* v-factor
                                                      speed
                                                      v)
                                                   g))
                                             dt)))
                                  (iter (+ x dx) ;transition
                                        (+ y dy)
                                        (+ u du)
                                        (+ v dv)
                                        (+ t dt))))))
                        (iter x0 y0 u0 v0 0)))
    (let ((alpha (degree2radian angle)))
      (integrate 0
                 height
                 (* velocity
                    (cos alpha))
                 (* velocity
                    (sin alpha))
                 0.01
                 gravity
                 mass
                 beta)))
  (loop lower-limit 0 0))
#+END_SRC

And the tests:
#+BEGIN_SRC scheme
1 (user) => (throw-desired-distance 45 30 1.8)

;Value: .7400000000000004

1 (user) => (throw-desired-distance 45 60 1.8)

;Value: 1.7300000000000013

1 (user) => (throw-desired-distance 45 80 1.8)

;Value: 2.5899999999999888
#+END_SRC

Finally we can decomposes this monolith by recognizing the duplicative codes:
#+BEGIN_SRC scheme
(define (throw-desired-distance velocity desired-distance height)
  (define tolerance 0.5)                ;tolerance 0.5m
  (define upper-limit 90)
  (define lower-limit -90)
  (define increment 0.1)
  (define (next ang) (+ ang increment))
  (define (loop angle minimum-time minimum-angle)
    (if (> angle upper-limit)
        minimum-time
        (integrate-and-update angle minimum-time minimum-angle)))
  (define (integrate-and-update angle minimum-time minimum-angle)
    (define (in-range? x) (< (abs (- desired-distance x)) tolerance))
    (define (hit-ground? y) (< y 0))
    (define (overshoot? x) (> x (+ desired-distance tolerance)))
    (define integrate
      (integrate-gen
       (lambda (x y u v t) (or (hit-ground? y)
                               (overshoot? x)))
       (lambda (x y u v t)
         (if (and (in-range? x)
                  (or (zero? minimum-time)
                      (< t minimum-time)))
             (loop (next angle) t angle)
             (loop (next angle) minimum-time minimum-angle)))))
    (travel integrate height velocity angle)) ;initial condition setter
  (loop lower-limit 0 0))
#+END_SRC

We could decompose further by generalizing the loop procedure of
=iterate-on-angle=; but I found it would rather make readability of our code
worse. Now, our code get concise enough to be readable yet maintain the
structure of described algorithm above. Also we didn't rely on the data
structure -- pair.
** Problem 8: Do it on a bounce
We noticed from preceding problem that weak outfielders can not get the ball
more than 80m in the air. So he may have to bounce it there. Let's model this
effect.

Specifically, assume that when a ball bounces, it leaves the ground at the same
angle as it was initially thrown (untrue but a reasonable approximation) but
with half the velocity. Our task is to write a procedure that will determine the
distance traveled, accounting for drag, given an initial velocity, an angle of
throw, an initial height, and the number of bounces it will take.

Here is the algorithm we are going to code:
1. Set initial condition.
2. Using =travel-distance= determine traveled distance with no bound and increment
   =sum-dist= by the result of =travel-distance=.
3. If remaining bounce is zero then terminate the loop with =sum-dist=.
4. Else set velocity to half of it and set height to 0.
5. Iterate on 2 \to 4.


Here is the resulting straightforward code:
#+BEGIN_SRC scheme
(define (travel-distance-with-bounces elevation speed angle bounces)
  (define (iter vel remaining-bounces sum-dist)
    (if (zero? remaining-bounces)
        sum-dist
        (iter (/ vel 2.) (1- remaining-bounces)
              (+ sum-dist (travel-distance 0 vel angle)))))
  (iter (/ speed 2.) bounces (travel-distance elevation speed angle)))
#+END_SRC

And here is the test:
#+BEGIN_SRC scheme
1 (user) => (travel-distance-with-bounces 1.8 35 19 3)

;Value: 83.39858829506251
#+END_SRC

Now our outfielder who has weak shoulder can throw the ball to reach apart 80m.

Let we do the case of an arbitrary number of bounces until it stops moving. We
exploit the same strategy of previous problem in robotic fielder -- using error
tolerance for the decision whether the ball stopped.

We can do that by slightly amending the code of fixed numbered bounces version:
By changing the termination condition to /vel < tolerance/:
#+BEGIN_SRC scheme
(define (travel-distance-with-arbitrary-bounces elevation speed angle)
  (define (stop? vel) (< vel .1))
  (define (iter vel sum-dist)
    (if (stop? vel)
        sum-dist
        (iter (/ vel 2.)
              (+ sum-dist (travel-distance 0 vel angle)))))
  (iter (/ speed 2.) (travel-distance elevation speed angle)))
#+END_SRC

Here is the test:
#+BEGIN_SRC scheme
1 (user) => (travel-distance-with-arbitrary-bounces 1.8 35 19)

;Value: 83.8583448733793
#+END_SRC

Unfortunately, our weak outfielders cannot throw the ball to reach to the place
90m apart. It is quite different from the strong outfielders:
#+BEGIN_SRC scheme
1 (user) => (travel-distance-with-arbitrary-bounces 1.8 45 19)

;Value: 120.78963743871626
#+END_SRC
** Problem 9: Do it on a bounce -- again
In Problem 8, we just assumed that the velocity would drop by one half on each
bounce. But in fact we are integrating trajectories in order to account for
drag, we can actually compute the velocity of the ball when it bounces (since we
know the $x$ and $y$ components of velocity when the ball hits the ground).
Using our previous general integration procedure we can easily implement what we
should do:
1. Set the termination condition of the integration to =hits-ground?= as
   previous; but we use this condition as transition to bounce.
2. Set the selection of the integration to if =(stop? vel)= then terminate
   ultimately -- return the $x$ component, else invert the sign of $v$ component
   then continue the iteration (actually to support this code we need to amend
   the =integrate-gen= to pass =iter= to the parameter of =select=).


First, we implement the arbitrary number bounces version:
#+BEGIN_SRC scheme
(define (integrate-gen terminate? select)
  (lambda (x0 y0 u0 v0 dt g m beta)
    (define (iter x y u v t)
      (if (terminate? x y u v t)        ;termination condition
          (select x y u v t iter)
          (let ((speed (sqrt (+ (square u)
                                (square v))))
                (v-factor (* (/ 1 m)
                             beta)))
            (let ((dx (* u dt))
                  (dy (* v dt))
                  (du (* (- v-factor)
                         speed
                         u
                         dt))
                  (dv (* (- (+ (* v-factor
                                  speed
                                  v)
                               g))
                         dt)))
              (iter (+ x dx)            ;transition
                    (+ y dy)
                    (+ u du)
                    (+ v dv)
                    (+ t dt))))))
    (iter x0 y0 u0 v0 0)))

(define (travel-distance-with-arbitrary-bounces2 elevation speed angle)
  (define (hits-the-ground? y) (< y 0))
  (define (stop? vel) (< (abs vel) .1))
  (define integrate
    (integrate-gen
     (lambda (x y . rest) (hits-the-ground? y))
     (lambda (x y u v t iter)
       (if (begin (newline) (display v) (stop? v)) x
           (iter x y u (- v) t)))))
  (travel integrate elevation speed angle))
#+END_SRC

Unfortunately, this doesn't work:
#+BEGIN_SRC scheme
1 (user) => (travel-distance-with-arbitrary-bounces2 1.8 45 19)

-12.888754064178412
12.888754064178412
-12.888754064178412
12.888754064178412
-12.888754064178412
12.888754064178412
-12.888754064178412
...
#+END_SRC

The problem was the termination condition works immediately after we invert =v=
as the =y= is less than 0. So we set the =y= to 0 to fix this:
#+BEGIN_SRC scheme
1 (user) => (travel-distance-with-arbitrary-bounces2 1.8 45 19)

-12.888754064178412
-11.453707821293339
-10.59153109045374
...
-7.104654040674966
-7.104654040675094
-7.104654040674973
-7.104654040675086
;Quit!
#+END_SRC
We fixed our original bug but encountered with another: After experimenting with
the debug code, that is, to change display x not v, we got:
#+BEGIN_SRC scheme
1 (user) => (travel-distance-with-arbitrary-bounces2 1.8 45 19)

82.68319955602507
126.84863975747217
...
379.04242193941747
379.04242193941747
379.04242193941747
;Quit!
#+END_SRC

That is, it indicates that we should use =u= to determine whether the ball
stopped. The reason behind of this is that our drag affect on primarily to velocity
of x component. Then rerun our test:
#+BEGIN_SRC scheme
1 (user) => (travel-distance-with-arbitrary-bounces2 1.8 45 19)

;Value: 361.2999476708538

1 (user) => (travel-distance-with-arbitrary-bounces2 1.8 35 19)

;Value: 338.6223063509878
#+END_SRC

This produces huge difference from the previous calculation: It is mainly due to the
fact that we modeled the bounce as elastic collision, which is not certainly
true.

Now let's turn to the fixed numbered bounces case. To do this, we should hand
over the =bounces= state variable to our integration method to keep track of
that. To make our general integration procedure make this happen, we should
amend that or make another procedure that manipulate state variable:
#+BEGIN_SRC scheme
(define (travel-distance-with-bounces2 elevation speed angle bounces)
  (define (hits-the-ground? y) (< y 0))
  (define (loop remaining-bounces x y u v)
    ((integrate-gen
      (lambda (x y . rest) (hits-the-ground? y))
      (lambda (x y u v . rest)
        (if (zero? remaining-bounces) x ;return accumulated distance
            (loop (-1+ remaining-bounces) x 0 u (- v)))))
     x y u v 0.01 gravity mass beta))   ;intermediate state variables
  (let ((alpha (degree2radian angle)))
    (loop bounces 0 elevation           ;initial condition
          (* speed (cos alpha))
          (* speed (sin alpha)))))
#+END_SRC

Then let's test:
#+BEGIN_SRC scheme
1 (user) => (travel-distance-with-bounces2 1.8 35 19 3)

;Value: 144.40112681673043

1 (user) => (travel-distance-with-bounces2 1.8 35 19 2)

;Value: 123.89518783211233

1 (user) => (travel-distance-with-bounces2 1.8 35 19 1)

;Value: 97.3312222038267

1 (user) => (travel-distance-with-bounces2 1.8 35 19 0)

;Value: 59.61469931243074
#+END_SRC
* Project 2 -- Prisoner's Dilemma
** Purpose
Project 2 focuses on the use of higher order procedures. together with data
structures. We will also further develop and demonstrate our ability to write
clear, intelligible, well-documented procedures, as well as text cases for our
procedures.
** A Fable
In the mid-1920's, the Nebraska State Police achieved what may still be their
finest moment. After a 400-mile car chase over dirt roads and through corn
fields, they finally caught up with the notorious bank robbers Bunny and Clod.
The two criminals were brought back to the police station in Omaha for further
interrogation. Bunny and Clod were questioned in separate rooms, and each was
offered the same deal by the police. The deal went as follows (since both are
the same, we need only describe the version presented to Bunny):

#+BEGIN_QUOTE
"Bunny, Here's the offer that we are making to both you and Clod. If you both
hold out on us and don't confess to bank robbery, then we admit that we don't
have enough proof to convict you. However, we will be able to jail you both for
one year, for reckless driving and endangerment of corn. If you turn state's
witness and help us convict Clod (assuming he doesn't confess) , then you will
go free, and Clod will get twenty years in prison. On the other hand, if you
don't confess and Clod does, then *he* will go free and *you* will get twenty years."

"What happens if both Clod and I confess?" asked Bunny.

"Then you both get ten years," responded the police.
#+END_QUOTE

Bunny, who had been a math major at Cal Tech before turning to crime, reasoned
this way:
#+BEGIN_QUOTE
"Suppose Clod intends to confess. Then if I don't confess, I'll get twenty
years, but if I do confess, I'll only get ten years. On the other hand, suppose
Clod intends to hold out on the cops. Then if I don't confess, I'll go to jail
for a year, but if I do confess, I'll go free. So no matter what Clod intends to
do, I am better off confessing than holding out. So I'd better confess."
#+END_QUOTE

Naturally, Clod employed the very same reasoning. Both criminals confessed, and
both went to jail for ten years (Well, actually they didn't go to jail. When
they were in court, and heard that thy had both turned state's witness, they
strangled each other. But that's another story.) The police, of course, were
triumphant, since the criminals would have been free in a year bad both remained
silent.
** The Prisoner's Dilemma
The Bunny and Clod story is an example of a situation known in mathematical game
theory as the "prisoner's dilemma." A prisoner's dilemma always involves two
"game players," and each has a choice between "cooperating" and "defecting." If
the two players cooperate, they each do moderately well; if they both defect,
they each do moderately poorly. If one player cooperates and the other defects,
then the defector does  extremely well and the cooperator does extremely poorly.
(In the case of the Bunny and Clod story, "cooperating" means cooperating with
one's partner -- i.e. holding out on the police -- and  "defecting" means
confessing to bank robbery.) Before formalizing the prisoner's dilemma
situation, we need to introduce some basic game theory notation.
** A Crash Course in Game Theory
In game theory, we differentiate between a /game/, and a /play/. A /game/ refers
to the set of possible choices and outcomes for the entire range of situations.
A /play/ refers to a specific set of choices by the players, with the associated
outcome for that particular scenario. Thus, in game theory, a /two-person
binary-choice game/ is represented by two-by-two matrix. Here is a hypothetical
game matrix:
|                | *B* cooperates | *B* defects |
|----------------+----------------+-------------|
| *A* cooperates | *A* gets 5     | *A* gets 2  |
|                | *B* gets 5     | *B* gets 3  |
|----------------+----------------+-------------|
| *A* defects    | *A* gets 3     | *A* gets 1  |
|                | *B* gets 2     | *B* gets 1  |

The two players in this case are called *A* and *B*, and the choices are called
"cooperate" and "defect." Players *A* and *B* can play a single game by
separately (and secretly) choosing either to cooperate or to defect. Once each
player has made a choice, he announces it to the other player; and the two then
look up their respective scores in the game matrix. Each entry in the matrix is
a pair of numbers indicating a score for each player, depending on their
choices. Thus, in the example above, if Player *A* chooses to cooperate while
Player *B* defects, then *A* gets 2 points and *B* gets 3 points. If both
players defect, they each get 1 point. Note, by the way, that the game matrix is
a matter of public knowledge; for instance, Player *A* knows before the game
even starts that if he and *B* both choose to defect, they will each get 1
point.

In an /iterated game/, the two players play repeatedly; thus after finishing one
game, *A* and *B* may play another. (Admittedly, there is a little confusion in
the terminology here; thus we refer to each iteration as a "play," which
constitutes a single "round" of the larger, iterated game.) There are a number
of ways in which iterated games may be played; in the simplest situation, *A*
and *B* play for some fixed number of rounds (say 200), and before each round,
they are able to look at the record of all previous rounds. For instance, before
playing the tenth round of their iterated game, both *A* and *B* are able to
study the results of the previous nine rounds.
** An Analysis of a Simple Game Matrix
The game depicted by the matrix above is a particularly easy one to analyze.
Let's examine the situation from Player *A*'s point of view (Player *B*'s point
of view is identical):

#+BEGIN_QUOTE
"Suppose *B* cooperates. Then I do better by cooperating myself (I receive five
points instead of three). On the other hand, suppose *B* defects. I still do
better by cooperating (since I get two points instead of one). So no matter what
*B* does, I am better off cooperating."
#+END_QUOTE

Player *B* will, of course, reason the same way, and both will choose to
cooperate. In the terminology of game theory, both *A* and *B* have a /dominant/
choice -- i.e., a choice that gives a preferred outcome no matter what the other
player chooses to do. The matrix shown above, by the way, does /not/ represent a
prisoner's dilemma situation, since when both players make their dominant
choice, they also both achieve their highest personal scores. We'll see an
example of a prisoner's dilemma game very shortly.

*To re-cap:* in any particular game using the above matrix, we would expect both
 players to cooperate; and in an iterated game, we would expect both players to
 cooperate repeatedly, on every round.
** The Prisoner's Dilemma Game Matrix
Now consider the following game matrix:
|                | *B* cooperates | *B* defects |
|----------------+----------------+-------------|
| *A* cooperates | *A* gets 3     | *A* gets 0  |
|                | *B* gets 3     | *B* gets 5  |
|----------------+----------------+-------------|
| *A* defects    | *A* gets 5     | *A* gets 1  |
|                | *B* gets 0     | *B* gets 1  |

In this case, Players *A* and *B* both have a dominant choice -- namely,
defection. No matter what Player *B* does, Player *A* improves his own score by
defecting, and vice versa.

However, there is something odd about this game. It seems as through the two
players would benefit by choosing to cooperate. Instead of winning only one
point each, they could win three points each. So the "rational" choice of mutual
defection has a puzzling self-destructive flavor.

The second matrix is an example of a prisoner's dilemma game situation. Just to
formalize the situation, let $CC$ be the number of points won by each player
when they both cooperate; let $DD$ be the number of points won when both defect;
let $CD$ be the number of points won by the cooperating party when the other
defects, and let $DC$ be the number of points won by the defecting party when
the other cooperates. Then the prisoner's dilemma situation is characterized by
the following conditions:
\begin{align*}
DC > CC &> DD > CD\\
CC &> \frac{DC + CD}{2}
\end{align*}

In the second game matrix, we have
\[DC = 5,\quad CC = 3,\quad DD = 1,\quad CD = 0\]
so both conditions are met. In the Bunny and Clod story, by the way, you can
verify that:
\[DC = 0,\quad CC= -1,\quad DD = -10,\quad CD = -20\]
Again, these values satisfy the prisoner's dilemma conditions.
** Axelrod's Tournament
In the late 1970's, political scientist Robert Axelrod held a computer
tournament designed to investigate the prisoner's dilemma situation (Actually,
there were two tournaments. Their rules and results are described in Axelrod's
book: /The Evaluation of Cooperation/.). Contestants in the tournament submitted
computer programs that would compete in an iterated prisoner's dilemma game of
approximately two hundred rounds, using the second matrix above. Each
contestant's program played five iterated games against each of the other
programs submitted, and after all games had been played the scores were tallied.

The contestants in Axelrod's tournament included professors of political
science, mathematics, computer science, and economics. The winning program --
the program with the highest average score -- was submitted by Anatol Rapoport,
a professor of psychology at the University of Toronto. In this project, we will
pursue Axelrod's investigations and make up our own Scheme programs to play the
iterated prisoner's dilemma game.

As part of this project, we will be running a similar tournament, but now
involving a three-person prisoner's dilemma.

Before we look at the two-player program, it is worth speculating on what
possible strategies might be employed in the iterated prisoner's dilemma game.
Here are some examples:

- Nasty :: a program using the *Nasty* strategy simply defects on every round of
     every game.
- Patsy :: a program using the *Pasty* strategy cooperates on every round of
     every game.
- Spastic :: this program cooperates or defects on a random basis.
- Egalitarian :: this program cooperates on the first round. On all subsequent
     rounds, *Egalitarian* examines the history of the other player's actions,
     counting the total number of defections and cooperations by the other
     player. If the other player's defections outnumber her cooperations,
     *Egalitarian* will defect; otherwise this strategy will cooperate.
- Eye-for-Eye :: this program cooperates on the first round, and then on every
     subsequent round it mimics the other player's previous move. Thus, if the
     other player cooperates (defects) on the /n/th round, then *Eye-for-Eye*
     will cooperate (defect) on the (/n/+1)st round.


All of these strategies are extremely simple. (Indeed, the first three do not
even pay any attention to the other player; their responses are uninfluenced by
the previous rounds of the game.) Nevertheless, simplicity is not necessarily a
disadvantage. Rapoport's first-prize program employed the *Eye-for-Eye*
strategy, and achieved the highest average score in a field of far more
complicated programs.
** The Two-Player Prisoner's Dilemma Program
A Scheme program for an iterated prisoner's dilemma game is provided as part of
the code for this project. The procedure =play-loop= pits two players (or, to be
more precise, two "strategies") against one another for approximately 100 games,
then prints out the average score of each player.

Player strategies are represented as procedures. Each strategy takes two inputs
-- its own "history" (that is, a list of all its previous "plays," where for
convenience we will use "c" to represent cooperate, and "d" to represent defect)
and its opponent's "history." The strategy returns either the string "c" for
"cooperate" or the string "d" for "defect." (Note that we will need to use
procedures appropriate for comparing strings when we analyze these results.)

At the beginning of an iterated game, each history is an empty list. As the game
progresses, the histories grow (via =extend-history=) into lists of "=c="'s and
"=d="'s, thus each history is stored from most recent to least recent. Note how
each strategy must have its /own/ history as its first input. So in
=play-loop-iter,strat0= has =history0= as its first input, and =strat1= has
=history1= as its first input.

The values from the game matrix are stored in a list named
=*game-association-list*=. This list is used to calculate the scores at the end
of the iterated game.
#+BEGIN_SRC scheme
(define *game-association-list*
  '((("c" "c") (3 3))
    (("c" "d") (0 5))
    (("d" "c") (5 0))
    (("d" "d") (1 1))))
#+END_SRC

Thus, if both players cooperate, the payoff to each player is a 3, if one player
cooperates and the other defects, the defecting player gets a payoff of 5, the
cooperating player gets a zero payoff, if both players defect, each gets a
payoff of 1.

Some sample strategies are given in the code. =Nasty= and =Patsy= are
particularly simple; each returns a constant value regardless of the histories.
=Spastic= also ignores the histories and chooses randomly between cooperation
and defection. We should study =Egalitarian= and =Eye-for-Eye= to see that their
behavior is consistent with the descriptions in the previous section.
** Problem 1
To be able to test out the system, we need to complete a definition for
=extract-entry=. This procedure will retrieve the payoff information from the
game association list. The procedure's behavior is as follows: it takes as input
a play, represented as a list of choices for each strategy (i.e., a "c" or a
"d"), and the game association list. Thus a play will in this case be a list of
two entries (since there are two players), each of which is the choice of action
for that player. Each entry in the game association list is a list itself, with
a first element representing a list of game choices, and the second element
representing a list of scores (or payoffs) for each player. Thus =extract-entry=
wants to search down the game association list trying to match its first
argument against the first element of each entry in the game association list,
one by one. When it succeeds, it returns that whole entry.

For example, we expect the following behavior:
#+BEGIN_SRC scheme
(define a-play (make-play "c" "d"))

;Value: a-play

(extract-entry a-play *game-association-list*)

;Value: (("c" "d") (0 5))
#+END_SRC

It is easy stuff to do: Even though I've got worse condition, could implement
this:
#+BEGIN_SRC scheme
(define (extract-entry play game-assc-list)
  (cond ((null? game-assc-list)
         (error "No matching error: There is no such play -- EXTRACT-ENTRY" play))
        ((equal? play (caar game-assc-list))
         (car game-assc-list))
        (else (extract-entry play (cdr game-assc-list)))))
#+END_SRC

Here is extra tests:
#+BEGIN_SRC scheme
1 (user) => (define b-play (make-play "c" "c"))

;Value: b-play

1 (user) => (extract-entry b-play *game-association-list*)

;Value: (("c" "c") (3 3))

1 (user) => (extract-entry (make-play "d" "d") *game-association-list*)

;Value: (("d" "d") (1 1))

1 (user) => (extract-entry (make-play "d" "c") *game-association-list*)

;Value: (("d" "c") (5 0))
#+END_SRC

We exploited the =equal= procedure that can compare list structure element-wise.
** Problem 2
Use =play-loop= to play games among the five defined strategies. Notice how a
strategy's performance varies sharply depending on its opponent. For example,
=Patsy= does quite well against =Eye-for-Eye= or against another =Patsy=, but it
loses badly to =Nasty=. Pay special attention to =Eye-for-Eye=. Notice how it
never eats its opponent -- but it never loses badly. Create a matrix in which
you show the average score for tournaments pitting all possible pairings of the
five different strategies: =Nasty=, =Patsy=, =Eye-for-Eye=, =Spastic=,
=Egalitarian=. Describe the behavior you observe for the different strategies.

Here is the matrix requested:
|               | =Nasty=         | =Patsy=                  | =Eye-for-Eye=  | =Spastic=                | =Egalitarian=  |
|---------------+-----------------+--------------------------+----------------+--------------------------+----------------|
| =Nasty=       | (1., 1.)        | (5., 0)                  | (1.04, .99)    | (2.684, .579)            | (1.038, .990)  |
| =Patsy=       | (0, 5.)         | (3., 3.)                 | (3., 3.)       | (1.412, 4.059)           | (3., 3.)       |
| =Eye-for-Eye= | (.9897, 1.0412) | (3., 3.)                 | (3., 3.)       | (2.2\dot{8}, 2.2\dot{8}) | (3., 3.)       |
| =Spastic=     | (.523, 2.907)   | (3.9\dot{7}, 1.5\dot{3}) | (2.209, 2.209) | (2.105, 2.248)           | (1.478, 2.239) |
| =Egalitarian= | (.9902, 1.0392) | (3., 3.)                 | (3., 3.)       | (1.71, 3.86)             | (3., 3.)       |

And the average score of each:
| Strategy      | Average score |
|---------------+---------------|
| =Nasty=       |        2.1524 |
| =Patsy=       |        2.0824 |
| =Eye-for-Eye= |       2.45594 |
| =Spastic=     |        2.3331 |
| =Egalitarian= |       2.34004 |

Note that the play between =Spastic= strategy and =Egalitarian=: It results to
win one-side hugely but not fixed -- which one would win is not determined; it
inherit the randomness of =Spastic=. From the average score matrix, we can
verify ourselves that =Eye-for-Eye= strategy got the best score overall -- even
if =Eye-for-Eye= never have won in above plays. Also note that =Nasty= always
win or at least draw the other who matched to play with =Nasty=.

For the other cases, we can observe that =Patsy=, =Eye-for-Eye=, =Egalitarian=
always draw -- cooperate each other, =Spastic= tends to draw with =Eye-for-Eye=
but not with =Egalitarian=.
** Problem 3
Games involving *Egalitarian* tend to be slower than other games. Why is that
so? Use order-of-growth notation to explain our answer.

Let /n/ to be the number of history (it would be same as other history). Then
the step complexity can be deduced as \Theta(n); space complexity is also
\Theta(n). The revised version or iterative version has \Theta(n) as its step
complexity and \Theta(1) space complexity as it is iterative process.

Consequently, the newer version doesn't improved the step complexity in the
terms of order or growth; however the actual time it would take to complete
approximately halved down as now we calculate =cs= and =ds= in a one loop -- not
with separate loop as we did before.
** Problem 4
Write a new strategy =eye-for-two-eyes=. The strategy should always cooperate
unless the opponent defected on both of the previous two rounds. (Looked at
another way: =eye-for-two-eyes= should cooperate if the opponent cooperated on
either of the previous two rounds.) Play =eye-for-two-eyes= against other
strategies. Describe the behavior you observe.

The code is straightforward:
#+BEGIN_SRC scheme
(define (EYE-FOR-TWO-EYE my-history other-history)
  (define (has-history-less-than-2? hist)
    (or (empty-history? hist)
        (empty-history? (rest-of-plays hist))))
  (define (defected-previous-2-rounds? hist)
    (and (string=? (most-recent-play hist) "d")
         (string=? (most-recent-play (rest-of-plays hist)) "d")))
  (cond ((has-history-less-than-2? my-history) "c")
        ((defected-previous-2-rounds? other-history) "d")
        (else                           ;has "c" in previous 2 rounds
         "c")))
#+END_SRC

Here is the observations:
#+BEGIN_SRC scheme
(play-loop nasty eye-for-two-eye)

Player 1 Score:  1.0740740740740742
Player 2 Score:  .9814814814814815

(play-loop patsy eye-for-two-eye)

Player 1 Score:  3.
Player 2 Score:  3.

(play-loop egalitarian eye-for-two-eye)

Player 1 Score:  3.
Player 2 Score:  3.

(play-loop eye-for-eye eye-for-two-eye)

Player 1 Score:  3.
Player 2 Score:  3.

(play-loop spastic eye-for-two-eye)

Player 1 Score:  3.075268817204301
Player 2 Score:  1.7849462365591398
#+END_SRC

The most obvious difference from =eye-for-eye= is that now the strategy lose
hugely against =spastic=; also the difference the scores each strategy would get
when it comes to with =nasty= got bigger than =eye-for-eye=. This is due to the
fact that now the strategy get harder to defect than previous, which results to
the bigger difference it get (this is bad thing since =eye-for-...= always loses
against other strategies).
** Problem 5
Write a procedure =make-eye-for-n-eyes=. This procedure should take a number as
input and return the appropriate =Eye-for-Eye=-like strategy. For example,
=(make-eye-for-n-eyes 2)= should returns a strategy equivalent to
=eye-for-two-eyes=. Use this procedure to create a new strategy and test it
against the other strategies. Describe the observed behavior.

Here is the code:
#+BEGIN_SRC scheme
(define (MAKE-EYE-FOR-n-EYE n)
  (lambda (my-history other-history)
    (define (has-history-less-than-n? n hist)
      (cond ((zero? n) false)
            ((empty-history? hist) true)
            (else
             (has-history-less-than-n? (-1+ n) (rest-of-plays hist)))))
    (define (defected-previous-n-rounds? n hist)
      (or (zero? n)
          (and (string=? (most-recent-play hist) "d")
               (defected-previous-n-rounds? (-1+ n) (rest-of-plays hist)))))
    (cond ((has-history-less-than-n? n my-history) "c")
          ((defected-previous-n-rounds? n other-history) "d")
          (else                           ;has "c" in previous n rounds
           "c"))))
#+END_SRC

And test:
#+BEGIN_SRC scheme
(play-loop nasty (make-eye-for-n-eye 5))

Player 1 Score:  1.2222222222222223
Player 2 Score:  .9444444444444444

(play-loop egalitarian (make-eye-for-n-eye 5))

Player 1 Score:  3.
Player 2 Score:  3.

(play-loop spastic (make-eye-for-n-eye 5))

Player 1 Score:  4.038834951456311
Player 2 Score:  1.4174757281553398

(play-loop eye-for-eye (make-eye-for-n-eye 5))

Player 1 Score:  3.
Player 2 Score:  3.
#+END_SRC

This general procedure inherit the property of =Eye-for-Eye= -- it always loses
against other strategies; it got worse -- the difference even got widen.
** Problem 6
Write a procedure =make-rotating-strategy= which takes as input two strategies
(say, =strat0= and =strat1=) and two integers (say =freq0= and =freq1=).
=make-rotating-strategy= should return a strategy which plays =strat0= for the
first =freq0= rounds in the iterated game, then switches to =strat1= for the
next =freq1= rounds, and so on. (Hint: you may find it useful to think about the
=remainder= procedure in order to decide which strategy to use at each
iteration.) Test it against other strategies and describe the performance.

Here is the code:
#+BEGIN_SRC scheme
(define (length-history hist)
  (if (empty-history? hist) 0
      (1+ (length-history (rest-of-plays hist)))))
(define (make-rotating-strategy strat0 strat1 freq0 freq1)
  (lambda (my-history other-history)
    (if (< (remainder (length-history my-history) (+ freq0 freq1))
           freq0)
        (strat0 my-history other-history)
        (strat1 my-history other-history))))
#+END_SRC

Tests:
#+BEGIN_SRC scheme
(play-loop (make-rotating-strategy nasty eye-for-eye 10 80) egalitarian)

Player 1 Score:  1.0396039603960396
Player 2 Score:  .9900990099009901

(play-loop (make-rotating-strategy nasty eye-for-eye 10 80) eye-for-eye)

Player 1 Score:  1.0396039603960396
Player 2 Score:  .9900990099009901

(play-loop (make-rotating-strategy nasty eye-for-eye 10 80) patsy)

Player 1 Score:  3.2795698924731185
Player 2 Score:  2.5806451612903225

(play-loop (make-rotating-strategy nasty eye-for-eye 10 80) nasty)

Player 1 Score:  1.
Player 2 Score:  1.

(play-loop (make-rotating-strategy nasty eye-for-eye 10 80) spastic)

Player 1 Score:  2.4361702127659575
Player 2 Score:  1.9042553191489362

(play-loop (make-rotating-strategy nasty eye-for-eye 10 80) spastic)

Player 1 Score:  2.297872340425532
Player 2 Score:  1.7127659574468086
#+END_SRC

We mixed =nasty= with =eye-for-eye= to complement each other: It becomes always
win the other one like the original =nasty= and I wished it to get good average
score as =eye-for-eye= does; but it turns out not.
** Problem 7
Write a new strategy, =make-higher-order-spastic=, which takes a list of
strategies as input. It returns a new strategy that loops through this list of
strategies, using the next one in the list for each play, and then starting
again at the beginning of the list when it has used all the strategies. Test
this new strategy against other strategies and describe the performance.

We use the same strategy with the previous problem:
#+BEGIN_SRC scheme
(define (make-higher-order-spastic strats)
  (lambda (my-history other-history)
    (let* ((index (remainder (length-history my-history) (length strats)))
           (strat (list-ref strats index)))
      (strat my-history other-history))))
#+END_SRC

Tests:
#+BEGIN_SRC scheme
(play-loop (make-higher-order-spastic (list eye-for-eye patsy nasty)) eye-for-eye)

Player 1 Score:  2.6989247311827955
Player 2 Score:  2.6451612903225805

(play-loop (make-higher-order-spastic (list eye-for-eye patsy nasty)) patsy)

Player 1 Score:  3.6530612244897958
Player 2 Score:  2.020408163265306

(play-loop (make-higher-order-spastic (list eye-for-eye patsy nasty)) egalitarian)

Player 1 Score:  3.6595744680851063
Player 2 Score:  2.0106382978723403

(play-loop (make-higher-order-spastic (list eye-for-eye patsy nasty)) spastic)

Player 1 Score:  2.31
Player 2 Score:  2.11

(play-loop (make-higher-order-spastic (list eye-for-eye patsy nasty)) spastic)

Player 1 Score:  2.0384615384615383
Player 2 Score:  2.2788461538461537

(play-loop (make-higher-order-spastic (list eye-for-eye patsy nasty)) nasty)

Player 1 Score:  .6568627450980392
Player 2 Score:  2.372549019607843
#+END_SRC
** Problem 8
Write a procedure =gentle=, which takes as input a strategy (say =strat=) and a
number between 0 and 1 (call it =gentleness-factor=). The =gentle= procedure
should return a strategy that plays the same as =strat= except: when =strat=
defects, the new strategy should have a =gentleness-factor= chance of
cooperating. (If =gentleness-factor= is 0, the return strategy performs exactly
the same as =strat=; if =gentleness-factor= is 0.5, the returned strategy
cooperates half the time that =strat= defects; if =gentleness-factor= is 1, the
returned strategy performs the same as =Patsy=.)

Use =gentle= with a low value for =gentleness-factor= -- say, 0.1 -- to create
two new strategies: =slightly-gentle-Nasty= and =slightly-gentle-Eye-for-Eye=.

Here is the code:
#+BEGIN_SRC scheme
(define (gentle strat gentleness-factor)
  (define (gentle-spastic)
    (if (< (random 1.0) gentleness-factor)
        "c"
        "d"))
  (lambda (my-history other-history)
    (let ((result (strat my-history other-history)))
      (if (string=? result "d")
          (gentle-spastic)
          result))))

(define slightly-gentle-Nasty
  (gentle nasty 0.1))

(define slightly-gentle-Eye-for-Eye
  (gentle eye-for-eye 0.1))
#+END_SRC

Here is the test:
#+BEGIN_SRC scheme
(play-loop nasty slightly-gentle-nasty)

Player 1 Score:  1.4210526315789473
Player 2 Score:  .8947368421052632

(play-loop eye-for-eye slightly-gentle-eye-for-eye)

Player 1 Score:  3.
Player 2 Score:  3.

(play-loop spastic slightly-gentle-eye-for-eye)

Player 1 Score:  2.4285714285714284
Player 2 Score:  2.020408163265306

(play-loop nasty slightly-gentle-eye-for-eye)

Player 1 Score:  1.2173913043478262
Player 2 Score:  .9456521739130435
#+END_SRC
** The Three-Player Prisoner's Dilemma
So far, all of our prisoner's dilemma examples have involved two players (and,
indeed, most game-theory research on the prisoner's dilemma has focused on
two-player games). But it is possible to create a prisoner's dilemma game
involve three -- or even more -- players.

Strategies from the two-player game do not necessarily extend to a three-person
game in a natural way. For example, what does =Eye-for-Eye= mean? Should the
player defect if /either/ of the opponents defected on the previous round? Or
only if /both/ opponents defected? And are either of these strategies nearly as
effective in the three-player game as =Eye-for-Eye= is in the two-player game?

Before we analyze the three-player game more closely, we must introduce some
notation for representing the payoffs. We use a notation similar to that used
for the two-player game. For example, we let $DCC$ represent the payoff to a
defecting player if both opponents cooperate. Note that the first position
represents the player under consideration. The second and third positions
represent the opponents.

Another example: $CCD$ represents the payoff to a cooperating player if one
opponent cooperates and the other opponent defects. Since we assume a symmetric
game matrix, $CCD$ could be written as $CDC$. The choice is arbitrary.

Now we are ready to discuss the payoffs for the three-player game. We impose
three rules (Actually, there is no universal definition for the multi-player
prisoner's dilemma. The constraints used here represent one possible version of
the three-player prisoner's dilemma.):

1. Defection should be the dominant choice for each player. In other words, it
   should always be better for a player to defect, regardless of what the
   opponents do. This rule gives three constraints:
   \begin{align*}
   DCC &> CCC\\
   DDD &> CDD\\
   DCD &> CCD
   \end{align*}
2. A player should always be better off if more of his opponents choose to
   cooperate. This rule gives:
   \begin{align*}
   DCC &> DCD > DDD\\
   CCC &> CCD > CDD\\
   \end{align*}
3. If one player's choice is fixed, the other two players should be left in a
   two-player prisoner's dilemma. This rule gives the following constraints:
   \begin{align*}
    CCD &> DDD\\
    CCC &> DCD\\
    CCD &> \frac{CDD + DCD}{2}\\
    CCC &> \frac{CCD + DCC}{2}
   \end{align*}
4. We can satisfy all of these constraints with the following payoffs:
   $$CDD = 0,\quad DDD = 1,\quad CCD = 2,\quad DCD = 3,\quad CCC = 4,\quad DCC =
   5.$$
** Problem 9
Revise the Scheme code for the two-player game to make a three-player iterated
game. The program should take three strategies as input, keep track of three
histories, and print out results for three players. We need to change only three
procedures: =play-loop=, =print-out-results= and =get-scores=.

We also need to change =*game-association-list*= as follows:
#+BEGIN_SRC scheme
(define *game-association-list*
  (list (list (list "c" "c" "c") (list 4 4 4))
        (list (list "c" "c" "d") (list 2 2 5))
        (list (list "c" "d" "c") (list 2 5 2))
        (list (list "d" "c" "c") (list 5 2 2))
        (list (list "c" "d" "d") (list 0 3 3))
        (list (list "d" "c" "d") (list 3 0 3))
        (list (list "d" "d" "c") (list 3 3 0))
        (list (list "d" "d" "d") (list 1 1 1))))
#+END_SRC

Here is the rest of code:
#+BEGIN_SRC scheme
(define (play-loop strat0 strat1 strat2)
  (define (play-loop-iter strat0 strat1 strat2 count history0 history1 history2 limit)
    (cond ((= count limit) (print-out-results history0 history1 history2 limit))
          (else (let ((result0 (strat0 history0 history1 history2))
                      (result1 (strat1 history1 history0 history2))
                      (result2 (strat2 history2 history0 history1)))
                  (play-loop-iter strat0 strat1 strat2 (+ count 1)
                                  (extend-history result0 history0)
                                  (extend-history result1 history1)
                                  (extend-history result2 history2)
                                  limit)))))
  (play-loop-iter strat0 strat1 strat2 0 the-empty-history the-empty-history the-empty-history
                  (+ 90 (random 21))))

(define (print-out-results history0 history1 history2 number-of-games)
  (let ((scores (get-scores history0 history1 history2)))
    (newline)
    (display "Player 1 Score:  ")
    (display (* 1.0 (/ (car scores) number-of-games)))
    (newline)
    (display "Player 2 Score:  ")
    (display (* 1.0 (/ (cadr scores) number-of-games)))
    (newline)
    (display "Player 3 Score:  ")
    (display (* 1.0 (/ (caddr scores) number-of-games)))
    (newline)
    ))

(define (get-scores history0 history1 history2)
  (define (get-scores-helper history0 history1 history2 score0 score1 score2)
    (cond ((empty-history? history0)
           (list score0 score1 score2))
          (else (let ((game (make-play (most-recent-play history0)
                                       (most-recent-play history1)
                                       (most-recent-play history2))))
                  (get-scores-helper (rest-of-plays history0)
                                     (rest-of-plays history1)
                                     (rest-of-plays history2)
                                     (+ (get-player-points 0 game) score0)
                                     (+ (get-player-points 1 game) score1)
                                     (+ (get-player-points 2 game) score2))))))
  (get-scores-helper history0 history1 history2 0 0 0))
#+END_SRC
** Problem 10
Write strategies =Patsy-3=, =Nasty-3=, and =spastic-3= that will work in a
three-player game. Try them out to make sure our code is working.

Write two new strategies: =tough-Eye-for-Eye= and =soft-Eye-for-Eye=.
=tough-Eye-for-Eye= should defect if /either/ of the opponents defected on the
previous round. =soft-Eye-for-Eye= should defect only if =both= opponents
defected on the previous round. Play some games using these two new strategies.
Describe the observed behavior of the strategies.

First task:
#+BEGIN_SRC scheme
(define (NASTY-3 my-history other-history another-history)
  "d")

(define (PATSY-3 my-history other-history another-history)
  "c")

(define (SPASTIC-3 my-history other-history another-history)
  (if (= (random 2) 0)
      "c"
      "d"))
#+END_SRC

And test:
#+BEGIN_SRC scheme
(play-loop nasty-3 patsy-3 spastic-3)

Player 1 Score:  4.08
Player 2 Score:  1.08
Player 3 Score:  2.46
#+END_SRC

Second task:
#+BEGIN_SRC scheme
(define (tough-EYE-FOR-EYE my-history other-history another-history)
  (cond ((empty-history? my-history) "c")
        ((or (string=? (most-recent-play other-history) "d")
             (string=? (most-recent-play another-history) "d"))
         "d")
        (else "c")))

(define (soft-EYE-FOR-EYE my-history other-history another-history)
  (cond ((empty-history? my-history) "c")
        ((and (string=? (most-recent-play other-history) "d")
              (string=? (most-recent-play another-history) "d"))
         "d")
        (else "c")))
#+END_SRC

And the behavior:
#+BEGIN_SRC scheme
(play-loop nasty-3 soft-eye-for-eye tough-eye-for-eye)

Player 1 Score:  1.0588235294117647
Player 2 Score:  1.
Player 3 Score:  1.0294117647058822

(play-loop patsy-3 soft-eye-for-eye tough-eye-for-eye)

Player 1 Score:  4.
Player 2 Score:  4.
Player 3 Score:  4.

(play-loop spastic-3 soft-eye-for-eye tough-eye-for-eye)

Player 1 Score:  2.4479166666666665
Player 2 Score:  1.9166666666666667
Player 3 Score:  3.0104166666666665

(play-loop spastic-3 soft-eye-for-eye tough-eye-for-eye)

Player 1 Score:  2.172727272727273
Player 2 Score:  1.7363636363636363
Player 3 Score:  2.690909090909091
#+END_SRC

=soft-Eye-for-Eye= inherit the characteristic property of =Eye-for-Eye= -- never
win against others; =tough-Eye-for-Eye= now tends to win with a slight
difference against others.
** Problem 11
Write a procedure =make-combined-strategies= which takes as input two
/two-player/ strategies and a "combining" procedure. =make-combined-strategies=
should return a /three-player/ strategy that plays one of the two-player
strategies against one of the opponents, and the other two-player strategy
against the other opponents, then calls the "combining" procedure on the two
two-player results. Here's an example: this call to =make-combined-strategies=
returns a strategy equivalent to =tough-Eye-for-Eye= in Problem 10.

The resulting strategy plays =Eye-for-Eye= against each opponent, and then calls
the combining procedure on the two results. If either of the two two-player
strategies has returned "d", then the three-player strategy will also return
"d".

#+BEGIN_SRC scheme
(make-combined-strategies
   Eye-for-Eye Eye-for-Eye
   (lambda (r1 r2) (if (or (string=? r1 "d") (string=? r2 "d")) "d" "c")))
#+END_SRC

Here's another example. This call to =make-combined-strategies= returns a
three-player strategy that plays =Eye-for-Eye= against one opponent,
=Egalitarian= against another, and choose randomly between the two results:
#+BEGIN_SRC scheme
(make-combined-strategies
   Eye-for-Eye Egalitarian
   (lambda (r1 r2) (if (= (random 2) 0) r1 r2)))
#+END_SRC

The code:
#+BEGIN_SRC scheme
;; (hist, hist -> action), (hist, hist -> action), (action, action -> action)
;; -> (hist, hist, hist -> action)
(define (make-combined-strategies two-strat0 two-strat1 combiner)
  (lambda (my-history other-history another-history)
    (combiner (two-strat0 my-history other-history)
              (two-strat1 my-hsitory another-history))))
#+END_SRC
We added the type notation of given procedure.

Then test:
#+BEGIN_SRC scheme
(define tough-eye-for-eye1
  (make-combined-strategies
   Eye-for-Eye Eye-for-Eye
   (lambda (r1 r2) (if (or (string=? r1 "d") (string=? r2 "d")) "d" "c"))))

(define randomized-egal-eye
  (make-combined-strategies
   Eye-for-Eye Egalitarian
   (lambda (r1 r2) (if (= (random 2) 0) r1 r2))))

(play-loop tough-eye-for-eye1 spastic-3 tough-eye-for-eye)

Player 1 Score:  2.0833333333333335
Player 2 Score:  .5
Player 3 Score:  2.0833333333333335

(play-loop tough-eye-for-eye1 soft-eye-for-eye tough-eye-for-eye)

Player 1 Score:  4.
Player 2 Score:  4.
Player 3 Score:  4.

(play-loop tough-eye-for-eye1 randomized-egal-eye tough-eye-for-eye)

Player 1 Score:  4.
Player 2 Score:  4.
Player 3 Score:  4.

(play-loop tough-eye-for-eye1 randomized-egal-eye spastic-3)

Player 1 Score:  2.988888888888889
Player 2 Score:  2.188888888888889
Player 3 Score:  2.5555555555555554
#+END_SRC
** Problem 12
A natural idea in creating a prisoner's dilemma strategy is to try and deduce
what kind of strategies the /other/ players might be using. In this problem, we
will implement a simple version of this idea.

The underlying idea is to keep track of how the strategy for one player
correlates with the decisions of the other two players on the previous round (or
course, you can imagine generalizing this to several previous rounds). Thus, we
want to build an intermediary data structure which keeps track of what player-0
did, correlated with what the other two players did, over the course of the
histories for the three players. Imagine creating a procedure that takes three
histories as arguments: call them =hist-0=, =hist-1= and =hist-2=. The idea is
that we wish to characterize the strategy of the player responsible for
=hist-0=. Given this is a three player game, there are three possible situations
we need to keep track of: What did player-0 do on one round when the two other
players both cooperated on the previous round; what did player-0 do on one round
when one of the others cooperated and the other defected on the previous round;
and what did player-0 do on one round when both other players defected on the
previous round. Since these three situations will occur multiple times, we want
to keep track of how often in each case did player-0 cooperate, and how often
did she defect in response to these choices, and how often did each of these
three cases occur (although that could be found by adding the number of times
player-0 cooperated and defected).

Thus, we should design and implement a data structure called a
=history-summary=, which the overall structure shown in Figure 1 (please
reference the relevant project document). The =history-summary= has three
sub-pieces, one for the case where both player-1 and player-2 cooperated, one
for when one of them cooperated and the other defected, and a third for when
both of these players defected. This means that our data abstraction for a
=history-summary= should have three selectors, for these three pieces. For each
piece, there is another data structure that keeps track of the number of times
player-0 cooperated on the next round, the number of times she defected, and the
total number of examples (though as we noted, this is redundant). We may find it
convenient to think of this as a kind of tree structure. Thus, our first task is
to design constructors and selectors to implement this multilevel abstraction.

Once we have designed our data abstraction, build a procedure that takes the
three histories as arguments, and returns a history-summary. If we extract from
this data structure the piece corresponding to =cooperate-cooperate=, this
should give us all the information about what happened when player-1 and player-2
both cooperated. Thus, we should be able to extract from this piece the number
of times player-0 cooperated and the number of times she defected.

REMEMBER: the goal of our data structure is to correlate player-0's behavior on
round n, with player-1 and player-2's behavior on round n-1. For example, the
result of an implementation, call it =make-history-summary=, on an example set
of histories is shown below:
#+BEGIN_SRC scheme
(define summary
  (make-history-summary
   '("c" "c" "d" "d" "c" "d" "c" "c")   ;hist-0
   '("c" "c" "c" "d" "d" "c" "d" "c")   ;hist-1
   '("c" "c" "d" "d" "d" "c" "c" "c"))) ;hist-2

summary
;Value: ((3 0 3) (1 1 2) (0 2 2))
#+END_SRC

We implemented above specification as iterative process:
#+BEGIN_SRC scheme
;; constructor
;; (hist,hist,hist) -> history-summary
(define (make-history-summary hist-0 hist-1 hist-2)
  (define (raise-exception)
    (error "Invalid input histories -- MAKE-HISTORY-SUMMARY"
           (list hist-0 hist-1 hist-2)))
  (define (helper h0 prev-other-hist prev-another-hist sub-branches)
    (let ((current-action (most-recent-play h0)))
      (cond ((and (empty-history? prev-other-hist) ;termination condition
                  (empty-history? prev-another-hist))
             sub-branches)
            ((or (empty-history? prev-other-hist) ;defensive programming
                 (empty-history? prev-another-hist))
             (raise-exception))
            (else                       ;transition step
             (let ((prev-other-action (most-recent-play prev-other-hist))
                   (prev-another-action (most-recent-play prev-another-hist))
                   (cc (car sub-branches)) ;cooperate-cooperate
                   (cd (cadr sub-branches)) ;cooperate-defect
                   (dd (caddr sub-branches))) ;defect-defect
               (helper
                (rest-of-plays h0)
                (rest-of-plays prev-other-hist)
                (rest-of-plays prev-another-hist)
                (cond ((and (string=? prev-other-action "c")
                            (string=? prev-another-action "c")) ;update cc
                       (list (cond ((string=? current-action "c")
                                    (increase-c-action cc)) ;update c
                                   ((string=? current-action "d")
                                    (increase-d-action cc)) ;update d
                                   (else (raise-exception)))
                             cd
                             dd))
                      ((and (string=? prev-other-action "d")
                            (string=? prev-another-action "d")) ;update dd
                       (list cc
                             cd
                             (cond ((string=? current-action "c")
                                    (increase-c-action dd))
                                   ((string=? current-action "d")
                                    (increase-d-action dd))
                                   (else (raise-exception)))))
                      ((or (and (string=? prev-other-action "d") ;update cd
                                (string=? prev-another-action "c"))
                           (and (string=? prev-other-action "c")
                                (string=? prev-another-action "d")))
                       (list cc
                             (cond ((string=? current-action "c")
                                    (increase-c-action cd))
                                   ((string=? current-action "d")
                                    (increase-d-action cd))
                                   (else (raise-exception)))
                             dd))
                      (else
                       (raise-exception))))))))) ;defensive programming
  (let ((cc (make-action-history 0 0 0))
        (cd (make-action-history 0 0 0))
        (dd (make-action-history 0 0 0)))
      (cond ((and (empty-history? hist-0) ;trivial condition
                  (empty-history? hist-1)
                  (empty-history? hist-2))
             (list cc cd dd))
            ((or (empty-history? hist-0) ;defensive programming
                 (empty-history? hist-1)
                 (empty-history? hist-2))
             (raise-exception))
            (else                       ;nontrivial case
             (helper hist-0             ;setup initial condition
                     (rest-of-plays hist-1)
                     (rest-of-plays hist-2)
                     (list cc cd dd)))))
  )

;; selector
(define (cooperate-cooperate history-summary)
  (car history-summary))
(define (cooperate-defect history-summary)
  (cadr history-summary))
(define (defect-defect history-summary)
  (caddr history-summary))

;; test for make-history-summary
;; (define summary
;;   (make-history-summary
;;    '("c" "c" "d" "d" "c" "d" "c" "c")   ;hist-0
;;    '("c" "c" "c" "d" "d" "c" "d" "c")   ;hist-1
;;    '("c" "c" "d" "d" "d" "c" "c" "c"))) ;hist-2

;; summary
;; ;Value: ((3 0 3) (1 1 2) (0 2 2))

;; operate on action-history
;; action-history -> action-history
(define (increase-c-action action-history)
  (make-action-history
   (1+ (c-action action-history))
   (d-action action-history)
   (1+ (t-action action-history))))
(define (increase-d-action action-history)
  (make-action-history
   (c-action action-history)
   (1+ (d-action action-history))
   (1+ (t-action action-history))))

;; lowest ADT for history-summary type
;; integer, integer, integer -> action-history
(define (make-action-history cooperations defections total-actions)
  (list cooperations defections total-actions))
;; (c-action (make-action-history <cs> <ds> <as>)) = <cs>
(define (c-action action-history)
  (car action-history))
;; (d-action (make-action-history <cs> <ds> <as>)) = <ds>
(define (d-action action-history)
  (cadr action-history))
;; (t-action (make-action-history <cs> <ds> <as>)) = <as>
(define (t-action action-history)
  (caddr action-history))
#+END_SRC

Then as usual we test our procedure:
#+BEGIN_SRC scheme
(define summary
  (make-history-summary
   '("c" "c" "d" "d" "c" "d" "c" "c")   ;hist-0
   '("c" "c" "c" "d" "d" "c" "d" "c")   ;hist-1
   '("c" "c" "d" "d" "d" "c" "c" "c")))

;Value: summary

summary

;Value: ((3 0 3) (1 1 2) (0 2 2))

(cooperate-defect summary)

;Value: (1 1 2)

(defect-defect summary)

;Value: (0 2 2)

(cooperate-cooperate summary)

;Value: (3 0 3)
#+END_SRC

The algorithm behind this implementation is straightforward:
1. Check the inputs are trivial case.
2. If it is do the right thing; if not set up the initial condition for the
   iterative process. You may find it helpful to draw table to catch up this process.
3. Depending on the current looks update appropriately then iterate over (transition).
4. If we encountered with termination condition then return the list of action-histories.


In the above description, we omitted the gory details about the defensive programming
and implementation details.
** Problem 13
Finally, using this data structure, we can build a new procedure that will
return a list of three numbers: the probability that the =hist-0= player
cooperates given that the other two players cooperated on the previous round,
the probability that the =hist-0= player cooperates given that only one other
player cooperated on the previous round, and the probability that the =hist-0=
player cooperates given that both others defected on the previous round. To fill
out some details in this picture, let's look at a couple of examples. We will
call our procedure =get-probability-of-c=: here are a couple of sample calls.
#+BEGIN_SRC scheme
(define summary (make-history-summary
                 '("c" "c" "c" "c")     ;hist-0
                 '("d" "d" "d" "c")     ;hist-1
                 '("d" "d" "c" "c")))   ;hist-2
(get-probability-of-c summary)
;; Value: (1 1 1)

(define new-summary (make-history-summary
                     '("c" "c" "c" "d" "c")
                     '("d" "c" "d" "d" "c")
                     '("d" "c" "c" "c" "c")))
(get-probability-of-c new-summary)
;; Value: (0.5 1 ())
#+END_SRC

In the top example, the returned list indicates that the first player cooperates
with probability 1 no matter what the other two players do. In the bottom
example, the first player cooperates with probability 0.5 when the other two
players cooperate; the first player cooperates with probability 1 when one of
the other two players defects; and since we have no data regarding what happens
when both of the other players defect, our procedure returns =()= for that case.

Then here is the result:
#+BEGIN_SRC scheme
;; history-summary -> List<number>
(define (get-probability-of-c history-summary)
  (define (get-prob action-history)
    (if (zero? (t-action action-history))
        '()
        (* 1.0 (/ (c-action action-history)
                  (t-action action-history)))))
  (list (get-prob (cooperate-cooperate history-summary))
        (get-prob (cooperate-defect history-summary))
        (get-prob (defect-defect history-summary))))
#+END_SRC

Test:
#+BEGIN_SRC scheme
(define summary (make-history-summary
                 '("c" "c" "c" "c")     ;hist-0
                 '("d" "d" "d" "c")     ;hist-1
                 '("d" "d" "c" "c")))

;Value: summary

(get-probability-of-c summary)

;Value: (1. 1. 1.)

(define new-summary (make-history-summary
                     '("c" "c" "c" "d" "c")
                     '("d" "c" "d" "d" "c")
                     '("d" "c" "c" "c" "c")))

;Value: new-summary

(get-probability-of-c new-summary)

;Value: (.5 1. ())
#+END_SRC
** Problem 14
Using this procedure, you should be able to write some predicate procedures that
help in deciphering another player's strategy. For instance, we can use
=get-probability-of-c= to record the behavior of an opponent. We could then
compare this against what we would expect for a behavior to see if they match.
Thus, the first procedure tests to see if two lists are the same. Using this we
could check to see if an opponent is a fool by seeing if he always cooperates
(i.e. the observed behavior would be a "c" for cooperate in all cases).

#+BEGIN_SRC scheme
(define (test-entry expected-values actual-values)
  (cond ((null? expected-values) (null? actual-values))
        ((null? actual-values) #f)
        ((or (not (car expected-values))
             (not (car actual-values))
             (= (car expected-values) (car actual-values)))
         (test-entry (cdr expected-values) (cdr actual-values)))
        (else #f)))

(define (is-he-a-fool? hist0 hist1 hist2)
  (test-entry (list 1 1 1)
              (get-probability-of-c
               (make-history-summary hist0 hist1 hist2))))

(define (could-he-be-a-fool? hist0 hist1 hist2)
  (test-entry (list 1 1 1)
              (map (lambda (elt)
                     (cond ((null? elt) 1)
                           ((= elt 1) 1)
                           (else 0)))
                   (get-probability-of-c (make-history-summary hist0
                                                               hist1
                                                               hist2)))))
#+END_SRC

Use the =get-probability-of-c= procedure to write a predicate that tests whether
another player is using the =soft-Eye-for-Eye= strategy from Problem 10. Also,
write a new strategy named =dont-tolerate-fools=. This strategy should cooperate
for the first ten rounds; on subsequent rounds it checks (one each round) to see
whether the other players might both be playing =Patsy=. If our strategy finds
that both other players seem to be cooperating uniformly, it defects; otherwise,
it cooperate.

To make testing our implementation easier, let we amend the =play-loop=
procedure to return played histories:
#+BEGIN_SRC scheme
(define (play-loop strat0 strat1 strat2)
  (define (play-loop-iter strat0 strat1 strat2 count history0 history1 history2 limit)
    (cond ((= count limit)
           (print-out-results history0 history1 history2 limit)
           (list history0 history1 history2)) ;for testing
          (else (let ((result0 (strat0 history0 history1 history2))
                      (result1 (strat1 history1 history0 history2))
                      (result2 (strat2 history2 history0 history1)))
                  (play-loop-iter strat0 strat1 strat2 (+ count 1)
                                  (extend-history result0 history0)
                                  (extend-history result1 history1)
                                  (extend-history result2 history2)
                                  limit)))))
  (play-loop-iter strat0 strat1 strat2 0 the-empty-history the-empty-history the-empty-history
                  (+ 90 (random 21))))
#+END_SRC

Then our first task:
#+BEGIN_SRC scheme
(define (is-he-soft-eye-for-eye? hist0 hist1 hist2)
  (test-entry (list 1 1 0)
              (get-probability-of-c
               (make-history-summary hist0 hist1 hist2))))
#+END_SRC
with the test:
#+BEGIN_SRC scheme
(let ((result-histories (play-loop soft-eye-for-eye spastic-3 tough-eye-for-eye1)))
  (is-he-soft-eye-for-eye? (car result-histories)
                           (cadr result-histories)
                           (caddr result-histories)))

Player 1 Score:  2.2058823529411766
Player 2 Score:  2.823529411764706
Player 3 Score:  3.176470588235294
;Value: #t
#+END_SRC

And our last task:
#+BEGIN_SRC scheme
;; hist, hist, hist -> action
(define (dont-tolerate-fools my-history other-history another-history)
  (cond ((<= (length-history my-history) 10) "c")
        ((and (could-he-be-a-fool? other-history my-history another-history)
              (could-he-be-a-fool? another-history my-history other-history))
         "d")
        (else "c")))
#+END_SRC

Here we used =could-he-be-a-fool?= instead of =is-he-a-fool?= since there is no
assurance that all the argument histories possess ="d"= as action.

The resulting test comes as:
#+BEGIN_SRC scheme
(play-loop dont-tolerate-fools patsy-3 patsy-3)

Player 1 Score:  4.897196261682243
Player 2 Score:  2.205607476635514
Player 3 Score:  2.205607476635514

(play-loop dont-tolerate-fools spastic-3 patsy-3)

Player 1 Score:  3.1868131868131866
Player 2 Score:  4.406593406593407
Player 3 Score:  3.1868131868131866
#+END_SRC

If we inspect the resulting histories from =play-loop=, we can convince ourself
that our implementation is highly likely correct.
* Project 3 -- Crawling and Indexing the World Wide Web
This project explores some issues that arise in constructing a "spider" or a
"web agent" that crawls over documents in the World Wide Web. For purposes of
this project, the Web is an extremely large collection of documents. Each
document contains some text and also links to other documents, in the form of
URLs.

In this project, we'll be working with programs that can start with an initial
document and follow the reference to other documents to do useful things. For
example, we could construct an index of all the words occurring in documents,
and make this available to people looking for information on the web (as do many
of the search engines on the web, such as Google or Yahoo).

Usually, we aren't fluent with the details of HTTP, URLs, URIs, HTML, XML, XSL,
HTTP-NG, DOM, and the rest of the alphabet soup that makes up the technical
details of the Web, here's a simplified version of what goes on behind the
scenes:

1. The Web consists of a very large number of things called documents,
   identified by names called URLs (Uniform Resource Locators). For example, the
   6.001 home page has the URL http://sicp.csail.mit.edu/. The first portion of
   a URL (~http://~) reveals the name of a protocol (in this case hypertext
   transmission protocol, or HTTP) that can be used to fetch the document, and
   the rest of the URL contains information needed by the protocol to specify
   which document is intended. (A protocol is a particular set of rules for how
   to communicate information.)
2. By using the HTTP protocol, a program (most commonly a browser but any
   program can do this -- "web agents" and spiders are examples of such programs
   that aren't browsers)[fn:1] can retrieve a document whose URL starts with
   ~HTTP:~. The document is returned to the program, along with information
   about how it is encoded, for example, ASCII or Unicode text, HTML, images in
   GIF or JPG or MPEG or PNG or some other format, an Excel or Lotus
   spreadsheet, etc.
3. Documents encoded in HTML (HyperText Markup Language) form can contain a
   mixture of text, images, formatting information, and links to other
   documents. Thus, when a browser (or other program) gets an HTML document, it
   can extract the links from it, yielding URLs for other documents in the Web.
   If these are in HTML format, then they too can be retrieved and will yield
   yet more links, and so on.
4. A /spider/ is a program that starts with an initial set of URLs, retrieves
   the corresponding documents, adds the links from these documents to the set
   of URLs and keeps on going. Every time it retrieves a document, it does some
   (hopefully useful) work in addition to just finding the embedded links.
5. One particularly interesting kind of spider constructs an /index/ of the
   documents it has seen. This index is similar to the index at the end of a
   book: it has certain key words and phrases, and for each entry it lists all
   of the URLs that contain that word or phrase. There are many kinds of
   indexes, and the art/science of deciding what words or phrases to index and
   how to extract them is at the cutting edge of research (it's part of the
   discipline called /information retrieval/). We'll talk mostly about /full
   text indexing/, which means that every word in the document (except, perhaps,
   the very common words like "and", "the," "a," and "an") is indexed.


In this project, we'll be interested in three tasks related to searching the
World Wide Web. First, we will develop a way to think about the "web" of links
as a directed graph. Second, we will build procedures to help in traversing or
searching through graphs such as the Web. Third, we will consider ways to build
an index for some set of web pages to support fast retrieval of URLs that
contain a given word.

** Directed Graphs
The essence of the Web, for the purpose of understanding the process of
searching, is captured by a formal abstraction called a /directed graph/. A
graph (like the one in Figure 1), consists of
/nodes/ and /edges/. In this figure, the nodes are labeled U through Z. Nods are
connected to other nodes via /edges/. In a directed graph, each edge has a
direction so that the existence of an /outgoing edgy/ from one node to another
node (e.g. from node Y to node X). Notice that there can be multiple outgoing
edges from a node as well as multiple /incoming/ edges to a node, e.g. there are
edges from both Y and Z to W. The set of nodes reachable via a single outgoing
edge from a given node is referred to as the node's /children/. For example, the
children of node W are nodes U and X. Lastly, a graph is said to contain a cycle
if you start from some node and manage to return to that same node after
traversing one or more edges. So for example, the nodes W, X and Y form a cycle,
as does the node V by itself.

#+BEGIN_SRC dot :file ../image/fig1.png :exports results
digraph {
X -> { V Y };
V -> V;
Y -> { Z W };
W -> X;
Z -> W;
W -> U;
U -> W;
}
#+END_SRC

#+caption: Figure 1: An example of a general graph.
#+RESULTS:
[[file:../image/fig1.png]]

A second example of a directed graph is shown in Figure 2. This particular
directed graph happens to be a tree: each node is pointed to by only one other
node and thus there is no sharing of nodes, and there are no cycles (or loops).

#+BEGIN_SRC dot :file ../image/fig2.png :exports results
digraph {
A -> { B I M };
B -> { C D E H };
E -> { F G };
I -> { J K L };
}
#+END_SRC

#+caption: Figure 2: An example of a tree, viewed as a directed graph.
#+RESULTS:
[[file:../image/fig2.png]]

In order to traverse a directed graph, let's assume that we have two selectors
for getting information from the graph:
- =(find-node-children <graph> <node>)= returns a list of the nodes in =<graph>=
  that can be reached in one step by outbound edges from =<node>=. For example,
  in Figure 2 the children of node B are C, D, E, and H -- things that can be
  reached in one hop by an outgoing edge.
- =(find-node-contents <graph> <node>)= returns the contents of the node. For
  example, when we represent the web as a graph, we will want the node contents
  to be an alphabetized list of all of the words occuring in the document at /node/.


Note, we have not said anything yet about the actual representation of a graph,
a node, or an edge. We are simply stating an abstract definition of a data
structure.

*** The Web as a Graph
The Web itself can be thought as a directed graph in which the nodes are HTML
documents and the edges are hyperlinks to other HTML documents. For example, in
Figure 2 the node labeled B would be a URL, and a directed edge exists between
two nodes B and E if the document represented by node B contains a link to the
document represented by node E (as it does in this case).

As mentioned earlier, a web spider (or web crawler) is a program that traverses
the web. A web spider might support procedures such as:
- =(find-URL-links <web> <URL>)= returns a list of the URLs that are outbound links
  from /URL/.
- =(find-URL-text <web> <URL>)= returns an alphabetized list of all the words
  occurring in the document at /URL/.


Note, we have not said anything yet about the actual representation of the web
as we did in graph: we are simply stating an abstract definition of a data
structure.

In a real web crawler, =find-URL-links= would involve retrieving the document
over the network using its URL, parsing the HTML information returned by the web
server, and extracting the link information from ~<a href=...>~, ~<image
src=...>~ and similar tags. Similarly, in a real web crawler, =<find-URL-text
<web> <URL>= would retrieve the document, discard all of the mark-up commands
(such as =<body>=, =<html>=, =<ul>=, etc.), alphabetize (and remove duplicates
from) the text, and return the resulting list of words.

For this project our programs will not actually go out the retrieve documents
over the web. Instead, we will represent a collection of web documents as a
/graph/ as discussed earlier. When we load the code for this project, we will
have available a global variable, =the-web=, which holds the graph
representation for a set of documents for use in this project.

*Note:* it is important to separate our particular representation of information
on the web from the idea of the web as a loose collection of documents. We are
choosing to use a graph to capture a simple version of the web -- this is simply
to provide us with a concrete representation of the web, so that we can examine
issues related to exploring the web. In practice, we would never build an entire
representation of the web, we would simply take advantage of the abstraction to
conceptualize the structure of the web, especially since it is a dynamic thing
that constantly changes.

Our implementation of =find-URL-links= and =find-URL-text= will simply use the
graph procedures to get web links (children) and web page contents:

#+BEGIN_SRC scheme
(define (find-URL-links web url)
  (find-node-children web url))

(define (find-URL-text web url)
  (find-node-contents web url))
#+END_SRC

In other words, we are converting operations that would normally apply to the
web itself into operations that work on the internal representation of the web
as a graph.
*** Directed Graph Abstraction
We will build a graph abstraction to capture the relationships as shown in
Figure 1 and 2, as well as enable us to have some contents at each node. We
should study the code in =search.scm= provided with the project very closely;
parts of it are described in the following discussion.

We will assume that our graph is represented as a collection of graph-elements.
Each graph-element will itself consist of a node (represented as a symbol -- the
name of the node), a list of children nodes, and some contents stored at the
node (which in general can be of any type). The constructors, type predicate,
and accessors for the =graph-element= abstraction are shown below:
#+BEGIN_SRC scheme
;;; Graph Abstraction
;;;
;;;   Graph                     a collection of Graph-Elements
;;;   Graph-Element               a node, outgoing children from the
;;;                               node, and contents for the node
;;;   Node = symbol             a symbol label or name for the node
;;;   Contents = anytype        the contents for the node

;;---------------
;; Graph-Element

; make-graph-element: Node,list<Node>,Contents -> Element
(define (make-graph-element node children contents)
  (list 'graph-element node children contents))

(define (graph-element? element)            ; anytype -> boolean
  (and (pair? element) (eq? 'graph-element (car element))))

; Get the node (the name) from the Graph-Element
(define (graph-element->node element)       ; Graph-Element -> Node
  (if (not (graph-element? element))
      (error "object not element: " element)
      (first (cdr element))))

; Get the children (a list of outgoing node names)
; from the Graph-Element
(define (graph-element->children element)   ; Graph-Element -> list<Node>
  (if (not (graph-element? element))
      (error "object not element: " element)
      (second (cdr element))))

; Get the contents from the Graph-Element
(define (graph-element->contents element)   ; Graph-Element -> Contents
  (if (not (graph-element? element))
      (error "object not element: " element)
      (third (cdr element))))
#+END_SRC

Given this representation for a graph-element, we can build the graph out of
these elements as follows:
#+BEGIN_SRC scheme
(define (make-graph elements)            ; list<Element> -> Graph
  (cons 'graph elements))

(define (graph? graph)                  ; anytype -> boolean
  (and (pair? graph) (eq? 'graph (car graph))))

(define (graph-elements graph)           ; Graph -> list<Graph-Element>
  (if (not (graph? graph))
      (error "object not a graph: " graph)
      (cdr graph)))

(define (graph-root graph)		; Graph -> Node|null
  (let ((elements (graph-elements graph)))
    (if (null? elements)
        '()
        (graph-element->node (car elements)))))
#+END_SRC

In the above implementation, we will arbitrarily consider the first
graph-element to hold the "root" for the graph. The procedure =graph-root=
returns the root node.

Given these abstractions, we can construct the graph in Figure 2 (with node =a=
as the root) using:
#+BEGIN_SRC scheme
(define test-graph
  (make-graph (list
   (make-graph-element 'a '(b i m) '(some words))
   (make-graph-element 'b '(c d e h) '(more words))
   (make-graph-element 'c '() '(at c node some words))
   (make-graph-element 'd '() '())
   (make-graph-element 'e '(f g) '(and even more words))
   (make-graph-element 'f '() '())
   (make-graph-element 'g '() '())
   (make-graph-element 'h '() '())
   (make-graph-element 'i '(j k l) '(more words yet))
   (make-graph-element 'j '() '())
   (make-graph-element 'k '() '())
   (make-graph-element 'l '() '()))))
#+END_SRC

Note that several of the nodes have no children, and that several have no
contents.

We would like to have some accessors to get connectivity and contents
information out of the graph. We first define a procedure to find a
graph-element in a graph, given the node (i.e. the symbol or name that
identifies the element):

#+BEGIN_SRC scheme
; Find the specified node in the graph
(define (find-graph-element graph node)   ; Graph,Node -> Graph-Element|null
  (define (find elements)
    (cond ((null? elements) '())
          ((eq? (graph-element->node (car elements)) node)
           (car elements))
          (else (find (cdr elements)))))
  (find (graph-elements graph)))
#+END_SRC

We are often more interested in the node children or node contents, rather than
the graph-element. The =find-node-children= and =find-node-contents= accessor
procedure can be implemented as follows:

#+BEGIN_SRC scheme
; Find the children of the specified node in the graph
(define (find-node-children graph node)        ; Graph,Node -> list<Node>|null
  (let ((element (find-graph-element graph node)))
    (if (not (null? element))
        (graph-element->children element)
        '())))

; Find the contents of the specified node in the graph
(define (find-node-contents graph node)         ; Graph,Node -> Contents|null
  (let ((element (find-graph-element graph node)))
    (if (not (null? element))
        (graph-element->contents element)
        '())))
#+END_SRC

In our representation above, we use node names (~Node = symbol~) to reference a
=graph-element= in a =graph=; the children of a node are represented as a list
of other node names. An alternative to this approach would be to make the node
itself a full abstract data type, so that a node /object/ would have identity,
and the children of a node could be, for example, a list of the actual children
node objects. The tradeoff would be more work in building the graph (e.g. to
link together actual node objects as nodes and edges are added to a
graph[fn:2]), but substantial savings when nodes are requested from the graph
(i.e. by avoiding a linear search of the graph-elements for the matching node
name) -- e.g. to extract the node's contents or children. With such an
alternative abstraction, when requesting a child node one can achieve constant
time access (in the size of the graph), as opposed to linear time access as in
the current implementation[fn:3].
** Searching a Graph
How can we search a graph? The basic idea is that we need to start at some node
and traverse the graph in some fashion looking for some goal. The search might
succeed (meaning that some goal is found), or it might fail (meaning that some
goal was not found). This very basic and abstract search behavior can be
captured in the following procedure:

#+BEGIN_SRC scheme
;; search: Node, (Node->Boolean), (Graph, Node -> List<Node>)
;;         (List<Node>, List<Node> -> List<Node>), Graph
;;           --> Boolean

(define (search initial-state goal? successors merge graph)
  ;; initial-state is the start state of the search
  ;;
  ;; goal? is the predicate that determines whether we have
  ;; reached the goal
  ;;
  ;; successors computes from the current state all successor states
  ;;
  ;; merge combines new states with the set of states still to explore
  (define (search-inner still-to-do)
    (if (null? still-to-do)
        #f
        (let ((current (car still-to-do)))
          (if *search-debug*
              (write-line (list 'now-at current)))
          (if (goal? current)
              #t
              (search-inner
               (merge (successors graph current) (cdr still-to-do)))))))
  (search-inner (list initial-state)))
#+END_SRC

Note the use of the =*search-debug*= flag. If we set this global variable to
=#t=, we will see the order in which the procedure is traversing the graph.

*** Looking at search
What does this search procedure do? Well, let's look at it a bit more closely.
=Search= takes several arguments. The first is the initial state of the search.
For our purposes, this will be a =Node= or in other words, the name of some node
in our graph. The second is a =goal?= procedure, which is applied to a node to
determine if we have reached our goal. This procedure will presumably examine
some aspect of the node (for example, maybe it wants to see if a particular word
is contained in the contents of that node) to decide if the search has reached
its termination point. The third is a procedure for finding the =successors= of
the node, which in this case basically means finding the children of a node in
the graph on which we are searching. The fourth is a procedure for combining the
children of a node with any other nodes that we still have to search. And the
final argument is the graph over which we are searching.

Looking at the code, you can see that we start with a list of nodes to search.
If the first one meets our =goal?= criterion, we stop. If not, we get the
children of the current node, and combine them in some fashion with the other
nodes in our collection to search. This then becomes our new list of nodes to
consider, and we continue.
*** Search Strategies
There are two common approaches for searching directed graphs, called
/depth-first search/ and /breath-first search/. In a depth-first search we start
at a node, pick one of the outgoing links from it, explore that link (and all of
that link's outgoing links, and so on) before returning to explore the next link
out of our original node. For the graph in Figure 2, that would mean we would
examine the nodes (if we go left-to-right as well as depth-first) in the order:
/a, b, c, d, e, g, h, i, j, k, l,/ and finally /m/ (unless we found our goal
earlier, of course). The name "depth-first" comes from the fact that we go down
the graph (in the above drawing) before we go across.

In a breadth-first search, we visit a node and then all of its "siblings" first,
before exploring any "children." For Figure 2, we'd visit the nodes in the order
/a, b, i, m, c, d, e, h, j, k, l, f, g/.

We can abstract the notions of depth-first, breadth-first, and other kinds of
searches using the idea of a /search strategy/. A search strategy will basically
come down to what choice we make for how to order the nodes to be explored.
*** A Depth-First Strategy
Here's an initial attempt at a depth-first search strategy. It doesn't quite
work on all cases, but it's a good place to start.

#+BEGIN_SRC scheme
(define (DFS-simple start goal? graph)
  (search start
          goal?
          find-node-children
          (lambda (new old) (append new old))
          graph))
#+END_SRC

And here is an example of using it:

#+BEGIN_SRC scheme
(DFS-simple 'a
            (lambda (node) (eq? node 'l))
            test-graph)
#+END_SRC

In this case, we are searching a particular graph =test-graph=, starting from a
node with name =a=. We are looking for a node named =l= (hence our second
argument). We use our graph abstraction to extract the children of a node (i.e.
=find-node-children=). The key element is how we choose to order the set of
nodes to be explored. Note the fourth argument. We can see that this will
basically take the list of nodes to be explored, and add the new children in
front of the list. This should give us a depth first search (you should think
carefully about why).

This simple method does not work in general, but it does work for the graph in
Figure 2. (See Warm Up Exercise 2 for some thoughts on why this algorithm does
not work on all graphs.[fn:4])
** An Index Abstraction
We will also be interested in constructing an index of web pages. To do this, we
will first construct a general purpose index abstraction, and then use it for
our purpose of web indexing.

An =Index= enables us to associate values with keys, and to retrieve those
values later on given the key. Here we will assume that a key is a Scheme
symbol (i.e. ~Key = symbol~), and that a value is also a symbol (i.e. ~Val =
symbol~). Our index will be a mutable data structure.

A concrete implementation for an =index= is as follows. An =Index= will be a
tagged data object that holds a list of =INdex-Entries=. Each =Index-Entry=
associates a =Key= with a list of values for that =Key=, i.e.
#+BEGIN_SRC scheme
;;   Index = Pair<Index-Tag, list<Index-Entry>>
;;   Index-Entry = list<Key, list<Val>>
#+END_SRC

Thus our index implementation is shown (partially) below. We will be asked in
the exercises to complete the implementation. The index implementation makes use
of the Scheme procedure =assv=; you will find it helpful to consult the [[https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Association-Lists.html][Scheme
manual]] as to what this procedure does.

#+BEGIN_SRC scheme
(define (make-index)            ; void -> Index
  (list 'index))

(define (index? index)          ; antype -> boolean
  (and (pair? index) (eq? 'index (car index))))

                                        ; This is an internal helper procedure not to
                                        ; be used externally.
(define (find-entry-in-index index key)
  (if (not (index? index))
      (error "object not an index: " index)
      (let ((entry (assv key (cdr index))))
        (if entry entry '()))))


                                        ; returns a list of values associated with key
(define (find-in-index index key)       ; Index,Key -> list<Val>
  (let ((index-entry (find-entry-in-index index key)))
    (if (not (null? index-entry))
        (cadr index-entry)
        '())))

;; TO BE IMPLEMENTED
(define (add-to-index! index key value) ; Index,Key,Val -> Index
  (let ((index-entry (find-entry-in-index index key)))
    (if (null? index-entry)
        ;; no entry -- create and insert a new one...
                                        ;... TO BE IMPLEMENTED

        ;; entry exists -- insert value if not already there...
                                        ;... TO BE IMPLEMENTED
        ))
  index)
#+END_SRC

An example use of the index is shown below
#+BEGIN_SRC scheme
(define test-index (make-index))
(add-to-index! test-index 'key1 'value1)
(add-to-index! test-index 'key2 'value2)
(add-to-index! test-index 'key1 'another-value1)

(find-in-index test-index 'key1)
;Value: (another-value1 value1)
(find-in-index test-index 'key2)
;Value: (value2)
#+END_SRC
** Warmup Exercises
These exercises will get we thinking about the project. We suggested to do them
early. Doing these stuffs will help us to understand aspects of the project.

*** Warmup Exercise 1: Index Implementation.
In order to simply /use/ the index abstraction, one should not need to
understand the underlying implementation (both the structure of the data
representation and the implementation of the abstract procedures). In one of the
programming exercises, however, you will be asked to complete the implementation
of =add-to-index!= partially shown above. In order to do this, we /will/ need to
understand the index implementation.

Draw a box and pointer diagram, and show the corresponding printed
representation, to illustrate the implementation of an =Index= as defined in
Section 3. Think about how you want the following expressions to create and then
mutate your data structure:

#+BEGIN_SRC scheme
(define test-index (make-index))
(add-to-index! test-index 'key1 'value1)
(add-to-index! test-index 'key2 'value2)
(add-to-index! test-index 'key1 'another-value1)
#+END_SRC

I've done this using the Digital Paper. You should find yourself comfortable to
draw box and pointer diagram with mutation beforehand.
*** Warmup Exercise 2: The Web as General Graph
Although we've been presenting the concepts and ideas in this problem set in the
context of the Web, for the project you will be ysing data structures that have
been pre-bulit. Thus, we will not be interfacing or touching the Web directly;
instead, we will be dealing with a graph data structure they've created for us
called =the-web=.

The following partial definition of =the-web= mimics a subset of the graph of
web pages at the 6.001 web site. Each node here is the URL of a web page and the
children nodes are the URLs referenced in the links on the page.

#+BEGIN_SRC scheme
(define the-web
  (list
   (make-graph-element
    'http://sicp.csail.mit.edu/
    '(http://sicp.csail.mit.edu/SchemeImplementations/
      http://sicp.csail.mit.edu/projects/)
    '(... words extracted from http://sicp.csail.mit.edu/ ...))
   (make-graph-element
    'http://sicp.csail.mit.edu/projects/
    '(http://sicp.csail.mit.edu/collaborative-work.html
      http://sicp.csail.mit.edu/getting-help.html)
    '(... words extracted from http://sicp.csail.mit.edu/SchemeImplementations/ ...))
   (make-graph-element
    'http://sicp.csail.mit.edu/getting-help.html
    '(http://sicp.csail.mit.edu/
      http://sicp.csail.mit.edu/SchemeImplementations/)
    '(... words extracted from http://sicp.csail.mit.edu/getting-help.html))
   ...))
#+END_SRC

Explain why our depth first strategy (using =DFS-simple=) will fail on this
graph. (If it helps, note that this graph has the same kind of form as Figure
1.) What is the essential difference between the =test-graph= and =the-web=
examples that cause =DFS-simple= to fail here?

We reason though following steps:
1. We can explain this situation by simulating with substitution model on each
   case and capture the common pattern appears all of each; we are allowed to
   use substitution model since =DFS-simple= doesn't involve any mutation in it.
2. The captured one is if given graph has cycle(s) in it, then =DFS-simple=
   fails, i.e. it falls into infinite loop over that cycle, which is the one the
   traverser encountered first.


You should make sure that you understand what I've described above using the
substitution model with some example.
** Programming assignment: A web spider
Begin by loading the code for the project from the web site. This will define
the search and data structure procedures listed above. Just to make sure
everything is working, evaluate

#+BEGIN_SRC scheme
(DFS-simple 'a
            (lambda (node) (eq? node 'l))
            test-graph)
#+END_SRC

This should traverse the =test-graph= graph until the search finds node =l=
(lowercase =L=), and you should see the nodes being visited in depth-first order
like this:
#+BEGIN_SRC scheme
(DFS-simple 'a
            (lambda (node) (eq? node 'l))
            test-graph)
(now-at a)
(now-at b)
(now-at c)
(now-at d)
(now-at e)
(now-at f)
(now-at g)
(now-at h)
(now-at i)
(now-at j)
(now-at k)
(now-at l)
;Value: #t
#+END_SRC

*** Computer Exercise 1: A breadth-first search.
Our previous example used a depth-first strategy. A breadth-first search
strategy can be obtained by modifying /only one line/ of the =DFS-simple=,
leaving the total number of characters in the expression unchanged! Do this to
create a new procedure (call it =DFS-simple=), demonstrate that it works on
=test-graph=, and write a short (but clear) explanation of why it works.

The answer is
#+BEGIN_SRC scheme
(define (BFS-simple start goal? graph)
  (search start
          goal?
          find-node-children
          (lambda (new old) (append old new))
          graph))
#+END_SRC
since it visits new added nodes only after visiting old nodes; i.e. it will
basically take the list of nodes to be explored, and add the new children to the
end of the list. This should give =BFS= as it visits child nodes only after
visiting all the siblings.
*** Marking nodes
In Warmup Exercise 2, we discussed a problem with =DFS-simple=. One way to fix
this problem is to keep track of what nodes we have visited. The basic idea is
that when we move to a "new" node, we can check to see if we have already
examined that node. If we have, we can simply remove it from our list of nodes
to explore, ignore any children (since they will have also already been
visited), and move on to the next node in the list.
*** Computer Exercise 2: Marking visited nodes.
We should be able to use the definition of =search= as a starting point to
create a new procedure (call it =search-with-cycles=) that keeps track of
already visited nodes, and implements the idea described above.

To show that our implementation works, we should use it with a depth first
strategy to create a new procedure (call it =DFS=) that implements full depth
first search. Use it to walk the sample graph =test-cycle= which is defined for
us in =search.scm=. Show it visits nodes at most once. Also create a breadth
first search, and also show that it only visits nodes once (albeit in a
different order).

Once we get sure these procedures are working, give the order in which the nodes
are visited for depth-first search and for breadth first search of =the-web=. We
should provide a =goal?= procedure that always returns false so that the entire
web is traversed, and start the walk at the node labeled
=http://sicp.csail.mit.edu/=.

**** Implementation
We can implement requested procedures using either with assignment or in
functional programming style. Here we consider functional programming style, you
should come up with the imperative style easily as well.

In functional programming, we need additional parameter to keep track of the
state variable named =visited=, which stores all the nodes it visited:
#+BEGIN_SRC scheme
(define (search-with-cycles initial-state goal? successors merge graph)
  ;; initial-state is the start state of the search
  ;;
  ;; goal? is the predicate that determines whether we have
  ;; reached the goal
  ;;
  ;; successors computes from the current state all successor states
  ;;
  ;; merge combines new states with the set of states still to explore
  (define (search-inner still-to-do visited)
    ;; visited stores all the nodes traversed so far.
    (if (null? still-to-do)
        #f
        (let ((current (car still-to-do)))
          (if *search-debug*
              (write-line (list 'now-at current)))
          (cond ((memv current visited)
                 (search-inner (cdr still-to-do) visited))
                ((goal? current) #t)
                (else (search-inner     ;recursive case
                       (merge (successors graph current) (cdr still-to-do))
                       (cons current visited)))))))
  (search-inner (list initial-state) '()))
#+END_SRC

And the =DFS=:
#+BEGIN_SRC scheme
(define (DFS start goal? graph)
  (search-with-cycles start
                      goal?
                      find-node-children
                      (lambda (new old) (append new old))
                      graph))
#+END_SRC

And the test:
#+BEGIN_SRC scheme
test-cycle

;Value: (graph (graph-element a (b c) (words for node a)) (graph-element b (c) (words for node b)) (graph-element c (a) (words for node c)))

(DFS 'a
     (lambda (node) false)
     test-cycle)
(now-at a)
(now-at b)
(now-at c)
(now-at a)
(now-at c)
;Value: #f
#+END_SRC

The structure of =test-cycle= can be structured as following figure:
#+BEGIN_SRC dot :file ../image/fig3.png :exports results
digraph {
A -> { B C };
B -> C;
C -> A;
}
#+END_SRC

#+caption: Figure 3: The abstract structure of test-cycle.
#+RESULTS:
[[file:../image/fig3.png]]

Our procedure works as expected? Yes and no!
- We expected to terminate even with the graph that contains cycle; and it is.
- We also expected to visit each node at most once; but not!


What's wrong with our =DFS= or =search-with-cycles=? The answer is nothing! just
we misused the debug code in the wrong place the canonical place would be the
after the checking whether the current is visited already or not:
#+BEGIN_SRC scheme
(define (search-with-cycles initial-state goal? successors merge graph)
  ;; initial-state is the start state of the search
  ;;
  ;; goal? is the predicate that determines whether we have
  ;; reached the goal
  ;;
  ;; successors computes from the current state all successor states
  ;;
  ;; merge combines new states with the set of states still to explore
  (define (search-inner still-to-do visited)
    ;; visited stores all the nodes traversed so far.
    (if (null? still-to-do)
        #f
        (let ((current (car still-to-do)))
          (cond ((memv current visited) ;if it visied then skip this node (as well as its children)
                 (search-inner (cdr still-to-do) visited))
                (else                   ;else visit!
                 (if *search-debug*
                     (write-line (list 'now-at current)))
                 (if (goal? current) #t
                     (search-inner      ;recursive case
                      (merge (successors graph current) (cdr still-to-do))
                      (cons current visited))))))))
  (search-inner (list initial-state) '()))
#+END_SRC

Then our test works as
#+BEGIN_SRC scheme
(DFS 'a
     (lambda (node) false)
     test-cycle)
(now-at a)
(now-at b)
(now-at c)
;Value: #f
#+END_SRC
as expected.

Then =BFS= is analogous to =DFS=:
#+BEGIN_SRC scheme
(define (BFS start goal? graph)
  (search-with-cycles start
                      goal?
                      find-node-children
                      (lambda (new old) (append old new))
                      graph))
#+END_SRC

As usual we test =BFS=:
#+BEGIN_SRC scheme
(BFS 'a
     (lambda (node) false)
     test-cycle)
(now-at a)
(now-at b)
(now-at c)
;Value: #f
#+END_SRC

=BFS= visits nodes same order as =DFS= coincidently.
**** Application to =the-web=
To make available =the-web= we should first load appropriate Scheme source file
that contains which:
#+BEGIN_SRC scheme
(load "generate.scm")

;Loading "generate.scm"... done
;Value: generate-random-web

the-web

;Value: (graph (graph-element http://sicp.csail.mit.edu/...
#+END_SRC

Then let's do the right things!
#+BEGIN_SRC scheme
(DFS 'http://sicp.csail.mit.edu/
     (lambda (node) false)
     the-web)
(now-at http://sicp.csail.mit.edu/)
(now-at http://sicp.csail.mit.edu/schemeimplementations)
(now-at http://sicp.csail.mit.edu/getting-help.html)
(now-at http://sicp.csail.mit.edu/lab-use.html)
(now-at *the-goal*)
(now-at http://sicp.csail.mit.edu/psets)
;Value: #f

(BFS 'http://sicp.csail.mit.edu/
     (lambda (node) false)
     the-web)
(now-at http://sicp.csail.mit.edu/)
(now-at http://sicp.csail.mit.edu/schemeimplementations)
(now-at http://sicp.csail.mit.edu/psets)
(now-at http://sicp.csail.mit.edu/getting-help.html)
(now-at http://sicp.csail.mit.edu/lab-use.html)
(now-at *the-goal*)
;Value: #f
#+END_SRC

Now the distinct two strategies produce different order of visiting.
** Indexing the web
Now let's turn to the problem of creating a full-text index of documents on the
Web, like the one created by Google or other search engines. We'll assume that
we have a graph that represents the World Wide Web, and this graph uses node
names that correspond to URLs (as in =the-web= sample given earlier). Remember,
we're assuming that we have a procedure =find-URL-text= which, for this web
representation, gets us the alphabetized text at the node. For example,
=(find-URL-text the-web 'http://sicp.csail.mit.edu/)= yields the list:
#+BEGIN_SRC scheme
(18:30:02 2004 6001-WEBMASTER@CSAIL.MIT.EDU 8 ABOUT ALL AM AND ANNOUNCEMENTS
          ANSWERS ARE ASSIGNMENT ASSIGNMENTS BY CALENDAR CAN CHANGE
          COLLABORATIVE COMMENTS COMPUTER COPYRIGHT CURRENT DO DOCUMENTATION EDT
          FALL FIND FOR GENERAL GET GETTING GUIDELINES HELP HOW I IN INDIVIDUAL
          INFORMATION INSTITUTE INTERPRETATION IS LAST LECTURE MASSACHUSETTS ME
          MICROQUIZZES MODIFIED MY NEW NOTES OCT OF ON ON-LINE ORAL OWN PAST
          POLICY POSTED PRESENTATIONS PREVIOUS PROBLEM PROGRAMS RECITATION
          RECITATIONS RECORDS RESERVED RIGHTS SCHEME SECTION SECTIONS SEND SET
          SETS SITE SOFTWARE STAFF STRUCTURE SUBJECT TECHNOLOGY TELL TERMS THE
          THIS THU TO UP USE WEEK WHAT WHERE WHICH WORK WRITING)
#+END_SRC

*** Computer Exercise 3: The Index Abstraction
Our first task is to complete the implementation of the =index= abstraction.
Complete the definition of =add-to-index!= so that have we available the
following procedures:
- =(make-index)= :: Creates a new index.
- =(add-to-index! index key value)= :: Add the value under the given key in the index.
- =(find-in-index index key)= :: Returns a list of all the values that have been
     entered into the index under the specified key.


Verify that our =add-to-index!= works with the other index procedures by showing
the result of evaluating the insertions and finds presented in Warmup Exercise 1.

=Add-to-index!= is already guided by the pseudocode. So if we follow that
instruction, we can fill the blanks:
#+BEGIN_SRC scheme
(define (add-to-index! index key value) ; Index,Key,Val -> Index
  (let ((index-entry (find-entry-in-index index key)))
    (if (null? index-entry)
        ;; no entry -- create and insert a new one...
        (let ((new-entry (list key (list value))))
          (set-cdr! index (cons new-entry (cdr index))))

        ;; entry exists -- insert value if not already there...
        (let ((value-list (cadr index-entry)))
          (if (not (memv value value-list))
              ;; not already there
              (set-car! (cdr index-entry)
                        (cons value value-list))))))
  index)
#+END_SRC

Then test returns expected values:
#+BEGIN_SRC scheme
(define test-index (make-index))

;Value: test-index

(add-to-index! test-index 'key1 'value1)

;Value: (index (key1 (value1)))

(add-to-index! test-index 'key2 'value2)

;Value: (index (key2 (value2)) (key1 (value1)))

(add-to-index! test-index 'key1 'another-value1)

;Value: (index (key2 (value2)) (key1 (another-value1 value1)))

(find-in-index test-index 'key1)

;Value: (another-value1 value1)

(find-in-index test-index 'key2)

;Value: (value2)
#+END_SRC
*** Computer Exercise 4: A Web Index
Given this index data abstraction, we want to write a procedure to use the index
to keep track of all the documents (URLs) that contain a particular word:
- =(add-document-to-index! index web url)= :: Add an entry in the index for each
     word in the contents of the URL (so that the key for that entry is a word,
     and the data in the entry is the URL).


This will enable us later on to get back the list of all documents (URLs) that
appear under that key (and thus contain that word). Here's an example of how it
should work:
#+BEGIN_SRC scheme
(define the-web-index (make-index))

(add-document-to-index! the-web-index
                        the-web
                        'http://sicp.csail.mit.edu/)

(find-in-index the-web-index 'help)
;Value: (http://sicp.csail.mit.edu/)

(find-in-index the-web-index '*magic*)
;Value: #f
#+END_SRC

Write this procedure and show it working on appropriate test cases.

Here is the implementation. The idea behind below code is for each of word from
contents apply =add-to-index!=:
#+BEGIN_SRC dot :file ../image/fig4.png :exports results
digraph {
        subgraph cluster {
        label="Contents of url"
        word;
        }
        word -> "(add-to-index! index word url)"
        }
#+END_SRC

#+caption: Figure 4: The algorithm behind the =add-document-to-index!=.
#+RESULTS:
[[file:../image/fig4.png]]

And the code:
#+BEGIN_SRC scheme
(define (add-document-to-index! index web url)
  (for-each (lambda (word) (add-to-index! index word url))
       (find-url-text web url)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(define the-web-index (make-index))

;Value: the-web-index

(add-document-to-index! the-web-index
                        the-web
                        'http://sicp.csail.mit.edu/)

;Unspecified return value

(find-in-index the-web-index 'help)

;Value: (http://sicp.csail.mit.edu/)

(find-in-index the-web-index '*magic*)

;Value: ()
#+END_SRC

Here we spot the bug in the provided example: by the type contract,
=find-in-index= can not return =#f=.

The appropriate contract of =add-document-to-index!= is
- \[\forall x \in \text{contents of url}.~\text{url} \in
  (\text{find-in-index}~index~x)\]
  #+BEGIN_SRC scheme
(let ((url 'http://sicp.csail.mit.edu/)
      (web the-web)
      (index the-web-index))
    (fold-left (lambda (t word)
                 (and t
                      (not (null? (memv url ; url in find-in-index?
                                        (find-in-index index word))))))
               true
               (find-url-text web url)))

;Value: #t
  #+END_SRC

- \[\neg \exists x \notin \text{contents of url}.~\text{url} \in
  (\text{find-in-index}~index~x)\]
  #+BEGIN_SRC scheme
(find-in-index the-web-index '*magic*)

;Value: ()
  #+END_SRC
*** Computer Exercise 5: Crawling the Web to Build an Index.
Now let's simulate what a typical search engine's spider does: Crawl the entire
=web= (recall: use a goal procedure that always returns false) and produce a
full-text index of everything we find.

To do this, we are first going to need to create one last set of search procedures. The only modification we need to make is to allow for a specific
action to take place at each node that we visit (so we will want to be able to
pass this procedure in as an argument). Create a final =search= procedure that
accomplishes this, and then use that to create a breadth-first strategy using
this idea.

Here is the result:
#+BEGIN_SRC scheme
;; search-final: Node, (Node->Boolean), (Graph, Node -> List<Node>)
;;               (List<Node>, List<Node> -> List<Node>), (Node->anytype),
;;               Graph
;;                 --> Boolean
(define (search-final initial-state goal? successors merge node-proc graph)
  ;; initial-state is the start state of the search
  ;;
  ;; goal? is the predicate that determines whether we have
  ;; reached the goal
  ;;
  ;; successors computes from the current state all successor states
  ;;
  ;; merge combines new states with the set of states still to explore
  ;;
  ;; node-proc applied to each node it visit
  (define (search-inner still-to-do visited)
    ;; visited stores all the nodes traversed so far.
    (if (null? still-to-do)
        #f
        (let ((current (car still-to-do)))
          (cond ((memv current visited) ;if it visied then skip this node (as well as its children)
                 (search-inner (cdr still-to-do) visited))
                (else                   ;else visit!
                 (if *search-debug*     ;debugging code
                     (write-line (list 'now-at current)))
                 (node-proc current)    ;apply node-proc to current
                 (if (goal? current) #t
                     (search-inner      ;recursive case
                      (merge (successors graph current) (cdr still-to-do))
                      (cons current visited))))))))
  (search-inner (list initial-state) '()))
#+END_SRC
with breadth first search:
#+BEGIN_SRC scheme
(define (BFS-final start goal? node-proc graph)
  (search-final start
                goal?
                find-node-children
                (lambda (new old) (append old new))
                node-proc
                graph))
#+END_SRC

Next, write a procedure, =make-web-index=, that creates a new index, finds all
the URLs that can be reached from a given web and initial URL, indexes them, and
returns a procedure that can be used to look up all the URLs of documents
containing a given word. Our procedure should use a breadth first strategy to
actually traverse =the-web= (why? think about that). We will also want to make
use of the index manipulating procedures from above.

We can test our program by trying the following example. Which document(s) do we
find?

#+BEGIN_SRC scheme
(define find-documents (make-web-index the-web 'http://sicp.csail.mit.edu/))

(find-documents 'collaborative)
#+END_SRC

To implement given task, we use the same strategy as =add-document-to-index!=
with the state variable; that is, using state variable =web-index=, to which we
collect all the documents as we traverse. More specifically, for each node (URL)
apply =(add-document-to-index! web-index web URL)= to collect all the documents
into =web-index=. Then return =(lambda (word) (find-in-index web-index word))=
to accomplish what we requested.

We traverse using =BFS-final= and for the counterpart of what we used in
previous example to apply each -- =for-each= procedure we use =node-proc=, which
we extended =search= procedure for this.

Then here is the code of it:
#+BEGIN_SRC scheme
(define (make-web-index web root-url)
  (let ((web-index (make-index)))
    (bfs-final root-url
               (lambda (url) false)
               (lambda (url)
                 (add-document-to-index! web-index web url))
               web)
    (lambda (word) (find-in-index web-index word))))
#+END_SRC

Then we have the answer of the final question of this exercise:
#+BEGIN_SRC scheme
(find-documents 'collaborative)

;Value: (http://sicp.csail.mit.edu/psets http://sicp.csail.mit.edu/)
#+END_SRC
*** Computer Exercise 6: A dynamic web search.
Let's put everything together by comparing the performance of crawling the web
to find a desired document, versus using a full-text index of the web. Note the
difference: a dynamic search would traverse UYRLs in real-time when a user
initiates a search, while the full-text index is the result of some
precomputation stage that has occurred prior to any user initiated search. This
won't be a full or fair comparison, but it should give us some ideas about
tradeoffs in designing real systems that analyze the contents of the actual Web.

To investigate crawling, write two procedures:
1. =(search-any web start-node word)= searches or traverses the indicated web
   (using a breadth first strategy) and returns the /first/ document that it
   finds that contains the given word. It should stop searching as soon as it
   finds such a document.
2. =(search-all web start-node word)= searches the /entire/ web (using a breadth
   first strategy) and returns /all/ documents that contain the given word.


Show that our procedures work by using =search-any= and =search-all= to look for
the word ='collaborative= in =the-web= structure. Make sure this is consistent
with what we found in [[Computer Exercise 5: Crawling the Web to Build an Index.][Computer Exercise 5]].

Let's first think about why we use "breadth first search" at above situations?
It can be answer by the use case of these procedure; specifically we assume that
our discourse is web crawling, user of our procedure normally want to know most
relevant information from what they started. Yet we haven't defined what the
"distance" is from node to node, we can consider the minimum number of edges
that connect given nodes as "distance". Consequently, as minimum distance is
minimum depth in our discourse, we use breadth first search rather than depth
first search since breadth first search guarantee that goal node is found along
with minimum depth of path from start node.

**** =search-any=
Return to our task, now let's do design the first procedure. As it should
terminate as soon as it found goal node, we should make =goal?= parameter
cleverly so that it somehow record found goal node, which contains given word,
then terminate (since =goal?= return only true or false we should use side
effect to do our job). So, to do our job, we need to use state variable
combination with assignment.

And here is the implementation:
#+BEGIN_SRC scheme
;; index, Node, anytype -> Node | false
(define (search-any web start-node word)
  (let* ((found false)
         (found? (bfs
                  start-node
                  (lambda (url)
                    (if (memv word
                              (find-url-text web url))
                        ;; if word in the contents of current url
                        ;; set found current url and terminate
                        (begin (set! found url) true)
                        ;; otherwise keep searching
                        false))
                  web)))
    (if found?
        found
        false)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(search-any the-web 'http://sicp.csail.mit.edu/ 'collaborative)
(now-at http://sicp.csail.mit.edu/)
;Value: http://sicp.csail.mit.edu/
#+END_SRC
**** =search-all=
Contrast to =search-any=, this procedure's =goal?= should not return true
always; instead, we make clever =node-proc= to collect all the found URL that
contains given word.

The code:
#+BEGIN_SRC scheme
(define (search-all web start-node word)
  (let ((found '()))
    (bfs-final
     start-node (lambda (url) false)
     (lambda (url)
       (if (memv word
                 (find-url-text web url))
           (set! found (cons url found))))
     web)
    found))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(search-all the-web 'http://sicp.csail.mit.edu/ 'collaborative)
(now-at http://sicp.csail.mit.edu/)
(now-at http://sicp.csail.mit.edu/schemeimplementations)
(now-at http://sicp.csail.mit.edu/psets)
(now-at http://sicp.csail.mit.edu/getting-help.html)
(now-at http://sicp.csail.mit.edu/lab-use.html)
(now-at *the-goal*)
;Value: (http://sicp.csail.mit.edu/psets http://sicp.csail.mit.edu/)
#+END_SRC
, which agrees with what we found in previous exercise.
*** Computer Exercise 7: Comparison -- Web Index vs. Dynamic Search.
Let's compare the technique of dynamic web searching with web indexing using
=make-web-index= and =find-documents=. We've provided a program,
=(generate-random-web <size>)=, that we can use to create test webs of different
sizes (total number of nodes) with some randomly generated text. Use this to
build several test webs. We don't have to make them too big; the procedure will
in fact not build anything larger than size 200. For each web, measure the
amount of time it takes, starting from the node named =*start*=:
- to use =search-any= to find a document containing the word ='help=;
- to use =search-any= to find a document containing a word that is not in the
  test web: ='Susanhockfield=;
- to use =search-all= to find all documents containing the word ='help=;
- to run =make-web-index= to create an index for the test web;
- to use =find-documents= to find all documents containing the word ='help=, not
  including the time needed to create the index.
- to use =find-documents= to find all documents containing the word
  ='Susanhockfield= (there won't be any), not including the time needed to
  create the index.


Note that although =find-documents= was originally created in Exercise 5 to deal
with =the-web=, we can use the same method (utilizing =make-web-index=) to apply
this idea to any random test web.

To enable we to do timing, we are provided a special function call =timed=. To
use it, place the symbol =timed= at the beginning of a combination that we want
to evaluate, e.g.
#+BEGIN_SRC scheme
(timed factorial 25)
#+END_SRC
will apply the procedure =factorial= to the argument 25, print out the time (in
seconds) it takes to compute this, and return the result.

Write a few short paragraphs explaining the measurements we made and what
conclusions we might want to draw about searching and crawling the real Web. If
we were building a service to help people find information on the Web, what
kinds of factors would we consider in deciding which method to use?

To test given procedures in a systematic way, we first consider to make test
procedure as follows.
#+BEGIN_SRC scheme
(define (test-each)
  (let ((web (generate-random-web 200))
        (start-node '*start*)
        (existing-word 'help)
        (nonexisting-word 'Susanhockfield))
    ;; -------------------------
    ;; search-any test
    (newline)
    (display "search-any -- find existing word")
    (timed search-any web start-node existing-word)
    (newline)
    (newline)
    (display "search-any -- find nonexisting word")
    (timed search-any web start-node nonexisting-word)
    ;; -------------------------
    ;; search-all test
    (newline)
    (newline)
    (display "search-all -- find existing word")
    (timed search-all web start-node existing-word)
    ;; -------------------------
    ;; make-web-index
    (let ((find-documents (make-web-index web start-node)))
      ;; -------------------------
      ;; find-documents test
      (newline)
      (newline)
      (display "find-documents -- find existing word")
      (timed find-documents existing-word)
      (newline)
      (newline)
      (display "find-documents -- find nonexisting word")
      (timed find-documents nonexisting-word)
      ;; -------------------------
      )
    ))
#+END_SRC

Let's run the test!

#+BEGIN_SRC scheme
(test-each)

search-any -- find existing word
time expended: .00999999999999801

search-any -- find nonexisting word
time expended: .09000000000000341

search-all -- find existing word
time expended: .0799999999999983

find-documents -- find existing word
time expended: 0.

find-documents -- find nonexisting word
time expended: 0.
;Value: ()
#+END_SRC

The problem is that the computation is way too fast that we can't estimate well.
To fix this, let we define auxiliary procedure called =repeat=. Using this, we
can change our test procedure as
#+BEGIN_SRC scheme
(define (test-each)
  ;; int, (void -> undefined) -> undefined
  (define (repeat n proc)
    (if (not (zero? n))
        (begin (proc)
               (repeat (-1+ n) proc))))
  (let ((web (generate-random-web 200))
        (start-node '*start*)
        (existing-word 'help)
        (nonexisting-word 'Susanhockfield)
        (n 10)                          ;number of repeatation
        )
    ;; -------------------------
    ;; search-any test
    (newline)
    (display "search-any -- find existing word")
    (timed repeat n (lambda () (search-any web start-node existing-word)))
    (newline)
    (newline)
    (display "search-any -- find nonexisting word")
    (timed repeat n (lambda () (search-any web start-node nonexisting-word)))
    ;; -------------------------
    ;; search-all test
    (newline)
    (newline)
    (display "search-all -- find existing word")
    (timed repeat n (lambda () (search-all web start-node existing-word)))
    ;; -------------------------
    ;; make-web-index
    (let ((find-documents (make-web-index web start-node)))
      ;; -------------------------
      ;; find-documents test
      (newline)
      (newline)
      (display "find-documents -- find existing word")
      (timed repeat n (lambda () (find-documents existing-word)))
      (newline)
      (newline)
      (display "find-documents -- find nonexisting word")
      (timed repeat n (lambda () (find-documents nonexisting-word)))
      ;; -------------------------
      )
    ))
#+END_SRC

Then repeat our test:
#+BEGIN_SRC scheme
(test-each)

search-any -- find existing word
time expended: 0.

search-any -- find nonexisting word
time expended: .8400000000000034

search-all -- find existing word
time expended: .8200000000000003

find-documents -- find existing word
time expended: 0.

find-documents -- find nonexisting word
time expended: 0.
;Unspecified return value
#+END_SRC

Still there are evaluation can not be estimated:
Let we do with setting =n= to 100
#+BEGIN_SRC scheme
(test-each)

search-any -- find existing word
time expended: .0899999999999963

search-any -- find nonexisting word
time expended: 8.219999999999999

search-all -- find existing word
time expended: 8.199999999999996

find-documents -- find existing word
time expended: 0.

find-documents -- find nonexisting word
time expended: 9.999999999990905e-3
;Unspecified return value
#+END_SRC

To estimate the order of growth let our test procedure take additional
parameters:
#+BEGIN_SRC scheme
(define (test-each number-of-repeatation number-of-nodes)
  ;; int, (void -> undefined) -> undefined
  (define (repeat n proc)
    (if (not (zero? n))
        (begin (proc)
               (repeat (-1+ n) proc))))
  (let ((web (generate-random-web number-of-nodes))
        (start-node '*start*)
        (existing-word 'help)
        (nonexisting-word 'Susanhockfield)
        (n number-of-repeatation)
        )
    ;; -------------------------
    ;; search-any test
    (newline)
    (display "search-any -- find existing word")
    (timed repeat n (lambda () (search-any web start-node existing-word)))
    (newline)
    (newline)
    (display "search-any -- find nonexisting word")
    (timed repeat n (lambda () (search-any web start-node nonexisting-word)))
    ;; -------------------------
    ;; search-all test
    (newline)
    (newline)
    (display "search-all -- find existing word")
    (timed repeat n (lambda () (search-all web start-node existing-word)))
    ;; -------------------------
    ;; make-web-index
    (let ((find-documents (make-web-index web start-node)))
      ;; -------------------------
      ;; find-documents test
      (newline)
      (newline)
      (display "find-documents -- find existing word")
      (timed repeat n (lambda () (find-documents existing-word)))
      (newline)
      (newline)
      (display "find-documents -- find nonexisting word")
      (timed repeat n (lambda () (find-documents nonexisting-word)))
      ;; -------------------------
      )
    ))
#+END_SRC

From the series of experiment we can guess the order of growth of =search-any=
and =search-all= as \Theta(n^{2}):
#+BEGIN_SRC scheme
(test-each 100 100)

search-any -- find existing word
time expended: .18999999999999773

search-any -- find nonexisting word
time expended: 2.1599999999999966

search-all -- find existing word
time expended: 2.1599999999999966

find-documents -- find existing word
time expended: 0.

find-documents -- find nonexisting word
time expended: 0.
;Unspecified return value

(test-each 100 50)

search-any -- find existing word
time expended: 2.9999999999986926e-2

search-any -- find nonexisting word
time expended: .5800000000000125

search-all -- find existing word
time expended: .5799999999999983

find-documents -- find existing word
time expended: 0.

find-documents -- find nonexisting word
time expended: 0.
;Unspecified return value
#+END_SRC

We can deduce above observation using asymptotic analysis:
=BFS= traverse through =n= number of URLs; each of node apply =goal?= and
=node-proc=. Either of =search-any= or =search-all= use \Theta(n) step
complexity procedure for it. As consequence it possess \Theta(n^{2}) complexity.

Whereas, in =find-documents= we can deduce the order of growth in step as
\Theta(n) where n is the number of words (keys) in the index.

Words for conclusion: The bigger the size of input we deal with, the more
difference these result in; As the real world web crawler should deal with huge
number of nodes, we would be better to use the preprocessed version rather than
the dynamic one if we really matter of the speed it takes. But, there are
important fact that matters in the real world; since web is nature that grows
dynamically if we choose to use full-text indexed search, our user confront to
lag in the information -- the search discourse is static.

So if we allowed to maintain only the recent information not the real-time
update, we definitely want to use the precomputed one; otherwise we would be
better off to dynamic search. Or we could combine both method by using the
dynamic programming paradigm -- memoization.

For those who interested in the order of growth of =make-web-index=, we estimate
that in approximative fashion since it involves lots of parameters. It
approximately possess \Theta(n^3) if we assume the number of words of each nodes
is approximately equals to the number of nodes (if the words are almost
duplicative in among the nodes).
*** Computer Exercise 8: Using a better indexing scheme.
A professionally written version of our procedures for creating an index would
pay careful attention to the efficiency of the algorithm used, and would
probably involve alphabetical order and more complicated data structures than we
have currently used. In this exercise, we should create a more efficient
indexing scheme.

There are many ways to optimize our indexing scheme. We could optimize the time
to create the index, or the time to query the index after it is built. Many data
structures (red-black trees, hash tables) could be used to optimize these tasks.
Furthermore, the index is a two-level abstraction, so there are two structures
we could optimize: the list of values associated with each entry, and the list
of keys.

Since, in our formulation, we just return /all/ of the values associated with a
key, we're going to focus on optimizing the time to search for a particular key
in the index.

Modify our index abstraction as follows. Create a new abstraction
=Optimized-Index= which contains =key= s and corresponding =Index-Entry= s in
=vector= form. A vector is simple another data structure. It has a fixed length,
it stores its entries in a linear fashion, and it can store and retrieve entries
at any point in its structure in a constant time (compare this to a list). We
can look up more details about a vector in the Scheme manual.

There should be a constructor =(optimize-index ind)= which takes a normal index
=ind= and returns a corresponding =Optimized-Index=. The constructor should sort
the data, in alphabetical order of keys. Then, to query for a particular key, we
will use a /binary search/, as described in the next problem.

We will find the following procedures useful:
- =(symbol<? x y): symbol, symbol -> boolean=
  determines if the symbol =x= comes before the symbol =y= in alphabetical order.
- =(make-vector k init): int, X -> vector<X>=
  creates a new vector of length =k= with all entries initialized to =init=.
- =(vector-set! vec k obj): vector<X>, int, X -> unspecifed=
  set the =k= th entry of =vec= to =obj=.
- =(vector-ref vec k): vector<X>, int -> X=
  returns the =k= th entry of =vec=.
- =(vector-length vec): vector<X> -> int=
  returns the length of =vec=.
- =(sort! vec proc): vector<X>, (X, X -> boolean) -> vector<X>=
  sorts the elements of =vec=, using the =proc= to compare values (i.e., if
  =(proc a b)= is =true= then =a= will appear before =b= in the vector. The
  original vector is mutated into this sorted order, and returned.)


We may also use the conversion procedure =list->vector=. Here is a demonstration
usage of =sort!= and =list->vector=:
#+BEGIN_SRC scheme
(sort! (list->vector (list 8 6 4 3 9 2 5 1 7)) <)

;Value: #(1 2 3 4 5 6 7 8 9)
#+END_SRC

Note: Make sure that our sorting procedure maintains the correct associations
between keys and index entries. If we just sort keys without somehow rearranging
the values in the corresponding way, our optimized index will give the wrong
answer. In testing, we should verify that this problem doesn't occur.

The idea to code it is change the representation of the index from ='index x
List<k x List<v> x nil>= to sorted vector as ='index x vector<k x List<v> x nil>=

And here is the implementation:
#+BEGIN_SRC scheme
(define (optimize-index ind)
  ;; change the representaion of index from Alist to
  ;; sorted vector with repect to key in alphabetical order.
  (cons (car ind)                       ;type-tag
        (sort! (list->vector (cdr ind))
               (lambda (x y)
                 (symbol<? (car x) (car y))) ;compare key of bindings
               ))
  )
#+END_SRC
We return newly produced =Optimized-Index= not mutating given =ind= as our
procedure doesn't end with bang(!).

Then test:
#+BEGIN_SRC scheme
(bfs-final 'http://sicp.csail.mit.edu/
               (lambda (url) false)
               (lambda (url)
                 (add-document-to-index! the-web-index the-web url))
               the-web)
(now-at http://sicp.csail.mit.edu/)
(now-at http://sicp.csail.mit.edu/schemeimplementations)
(now-at http://sicp.csail.mit.edu/psets)
(now-at http://sicp.csail.mit.edu/getting-help.html)
(now-at http://sicp.csail.mit.edu/lab-use.html)
(now-at *the-goal*)
;Value: #f

(define opt-ind (optimize-index the-web-index))

;Value: opt-ind

the-web-index

;Value: (index (yourself (http://sicp.csail.mit.edu/lab-use.html)) (working ...

opt-ind

;Value: (index . #((|0| (http://sicp.csail.mit.edu/psets)) (|09:38:18| (http:/...
#+END_SRC

Works well.
*** Problem 9.
The idea behind a binary search is that if we know a vector has sorted elements,
we can search for a particular key without examining every member of the vector.
Initially, our "search domain" is 1,...,$n$ where $n$ is the length of the
vector. Then, we check the middle ($n/2$ th) element of the vector, and see if
it holds the key we are seeking. If it is not a match, we compare that element
against our key. If we see that our key is greater than the middle element, we
can recursively call a binary search on the right half of the vector (i.e., make
the search domain $n/2 + 1,\ldots,n$). Conversely, if the key is smaller than
the middle index, we continue the search in the left half. This continues until
our search domain only has 1 item in it; either it is the item we are seeking,
or we conclude that the item we are seeking is not in our vector.

We need to complete the following definition:
#+BEGIN_SRC scheme
(define (find-entry-in-optimized-index optind k)
  ;; type: Optimized-Index, Key -> List<Val>
  ;; k is a symbol representing the key we are looking for
  ;; this procedure does a binary search, so it takes O(log n)
  ;; time where n is the number of entries in optind
  ;; ...
  )
#+END_SRC

Use the procedure =timed= to test our optimized index and see if searches really
do run faster (and correctly). We may need to create a helper procedure that
makes many (say, 1000) queries, since a single search in either index will
probably be too fact to accurately time (like we did before with =repeat=).

To implement the binary search we should manipulate the index of vector as a
pointer; make =high= and =low= as state variable and implement each condition --
termination condition, transition, initial condition. Our code evolve iteratively.

Here is the result:
#+BEGIN_SRC scheme
(define (find-entry-in-optimized-index optind k)
  ;; type: Optimized-Index, Key -> List<Val>
  ;; k is a symbol representing the key we are looking for
  ;; this procedure does a binary search, so it takes O(log n)
  ;; time where n is the number of entries in optind
  (define (binary-search high low)
    ;; int, int -> false | List<Val>
    (let* ((middle (quotient (+ high low) 2))
           (current-entry (vector-ref (cdr optind) middle))
           (current-key (car current-entry)))
      (cond ((= high low)               ;termination condition
             (if (eq? k current-key)
                 (cadr current-entry)   ;corresponding value list
                 false))
            ((symbol<? k current-key)
             (binary-search (-1+ middle) low)) ;search left half
            ((symbol>? k current-key)
             (binary-search high (1+ middle))) ;search right half
            ((symbol=? k current-key)
             (cadr current-entry))      ;return found values
            (else error "Invalid inputs" (list optind k))))) ;defensive programming
  (binary-search (-1+ (vector-length (cdr optind))) 0) ;initial condition
  )
#+END_SRC

And the test:
#+BEGIN_SRC scheme
(find-entry-in-optimized-index opt-ind 'work)

;Value: (http://sicp.csail.mit.edu/psets http://sicp.csail.mit.edu/schemeimplementations http://sicp.csail.mit.edu/)

(find-entry-in-index the-web-index 'work)

;Value: (work (http://sicp.csail.mit.edu/psets http://sicp.csail.mit.edu/schemeimplementations http://sicp.csail.mit.edu/))

(find-entry-in-optimized-index opt-ind '*goal*)

;Quit!
#+END_SRC

It falls in infinite loop; it is due to ill-defined algorithm we should fix
specified informal algorithm as to
#+BEGIN_SRC scheme
(define (find-entry-in-optimized-index optind k)
  ;; type: Optimized-Index, Key -> List<Val>
  ;; k is a symbol representing the key we are looking for
  ;; this procedure does a binary search, so it takes O(log n)
  ;; time where n is the number of entries in optind
  (define (binary-search high low)
    ;; int, int -> false | List<Val>
    (let* ((middle (quotient (+ high low) 2))
           (current-entry (vector-ref (cdr optind) middle))
           (current-key (car current-entry)))
      (cond ((< high low)               ;termination condition
             false)
            ((symbol<? k current-key)
             (binary-search (-1+ middle) low)) ;search left half
            ((symbol>? k current-key)
             (binary-search high (1+ middle))) ;search right half
            ((symbol=? k current-key)
             (cadr current-entry))      ;return found values
            (else error "Invalid inputs" (list optind k))))) ;defensive programming
  (binary-search (-1+ (vector-length (cdr optind))) 0) ;initial condition
  )
#+END_SRC
i.e. the search domain can be empty.

It fixes our bug:
#+BEGIN_SRC scheme
(find-entry-in-optimized-index opt-ind '*goal*)

;Value: #f

(find-entry-in-optimized-index opt-ind 'working)

;Value: (http://sicp.csail.mit.edu/lab-use.html)
#+END_SRC

I found it is suspicious that the signatures of =find-entry-in-optimized-index=
does not agree with its counter part -- =find-entry-in-index=; as its name
suggest, we should return found entry not the values:
#+BEGIN_SRC scheme
(define (find-entry-in-optimized-index optind k)
  ;; type: Optimized-Index, Key -> Index-Entry
  ;; k is a symbol representing the key we are looking for
  ;; this procedure does a binary search, so it takes O(log n)
  ;; time where n is the number of entries in optind
  (define (binary-search high low)
    ;; int, int -> nil | Index-Entry
    (let* ((middle (quotient (+ high low) 2))
           (current-entry (vector-ref (cdr optind) middle))
           (current-key (car current-entry)))
      (cond ((< high low)               ;termination condition
             '())
            ((symbol<? k current-key)
             (binary-search (-1+ middle) low)) ;search left half
            ((symbol>? k current-key)
             (binary-search high (1+ middle))) ;search right half
            ((symbol=? k current-key)
             current-entry)      ;return found values
            (else error "Invalid inputs" (list optind k))))) ;defensive programming
  (binary-search (-1+ (vector-length (cdr optind))) 0) ;initial condition
  )
#+END_SRC

Then test procedure:
#+BEGIN_SRC scheme
(define (test-find-index number-of-repeatation number-of-nodes)
  (let ((web (generate-random-web number-of-nodes))
        (start-node '*start*)
        (existing-word 'help)
        (nonexisting-word 'Susanhockfield)
        (n number-of-repeatation)
        )
    ;; -------------------------
    ;; construct web-index
    (let ((web-index (make-index)))
      (bfs-final start-node
                 (lambda (url) false)
                 (lambda (url)
                   (add-document-to-index! web-index web url))
                 web)
      ;; -------------------------
      ;; find-entry-in-index
      (newline)
      (newline)
      (display "find-entry-in-index -- find existing word")
      (timed repeat n (lambda () (find-entry-in-index web-index existing-word)))
      (newline)
      (newline)
      (display "find-entry-in-index -- find nonexisting word")
      (timed repeat n (lambda () (find-entry-in-index web-index nonexisting-word)))
      (let ((optind (optimize-index web-index)))
        ;; -------------------------
        ;; find-entry-in-optimized-index
        (newline)
        (newline)
        (display "find-entry-in-optimized-index -- find existing word")
        (timed repeat n (lambda () (find-entry-in-optimized-index optind existing-word)))
        (newline)
        (newline)
        (display "find-entry-in-optimized-index -- find nonexisting word")
        (timed repeat n (lambda () (find-entry-in-optimized-index optind nonexisting-word)))))
      ;; -------------------------
    ))
#+END_SRC

Then here is series of experiment:
#+BEGIN_SRC scheme
(test-find-index 20000 200)


find-entry-in-index -- find existing word
time expended: .10999999999999943

find-entry-in-index -- find nonexisting word
time expended: .13000000000000256

find-entry-in-optimized-index -- find existing word
time expended: .6199999999999974

find-entry-in-optimized-index -- find nonexisting word
time expended: .7000000000000028
;Unspecified return value

(test-find-index 20000 2)


find-entry-in-index -- find existing word
time expended: .09000000000000341

find-entry-in-index -- find nonexisting word
time expended: .0799999999999983

find-entry-in-optimized-index -- find existing word
time expended: .6200000000000045

find-entry-in-optimized-index -- find nonexisting word
time expended: .7199999999999989
;Unspecified return value
#+END_SRC

Seems like our procedures doesn't depend on the size of input. Is it right? No!
Along with the our asymptotic complexity, =find-entry-in-index= should have
\Theta(n) where n is the input size; =find-entry-in-optimized-index= should have
\Theta(\log n)! What's wrong? The answer is that what we referred as input size
-- n -- is different in each context of above dialog. In the latter, =n= is the
number of keys in the index; whereas the former is the number of nodes in the
graph. Let we inspect the /actual/ words in it.
#+BEGIN_SRC scheme
(test-find-index 20000 2)


find-entry-in-index -- find existing word
time expended: .05999999999999517

find-entry-in-index -- find nonexisting word
time expended: .10000000000000142

number of words (keys) in optind (web-index)	322

find-entry-in-optimized-index -- find existing word
time expended: .6200000000000045

find-entry-in-optimized-index -- find nonexisting word
time expended: .6599999999999966
;Unspecified return value

(test-find-index 20000 200)


find-entry-in-index -- find existing word
time expended: .10999999999999943

find-entry-in-index -- find nonexisting word
time expended: .12999999999999545

number of words (keys) in optind (web-index)	447

find-entry-in-optimized-index -- find existing word
time expended: .6200000000000045

find-entry-in-optimized-index -- find nonexisting word
time expended: .7100000000000009
;Unspecified return value
#+END_SRC

So the actual n doesn't changed as many nodes changed.

It concludes our linear search method has less computation factor than optimized
one if we do not consider the scale effect (asymptotic analysis). So with
current dispose, we can not tell it actually run faster than the previous one.
* Project 4 -- The Object-Oriented Adventure Game
We should begin working on the assignment once we finished previous projects and
learned relevant materials in the text. It is to our advantage to get work done
early, rather than waiting until the night before it is due (in this case our
own due not the one made by someone like professor). We should also read over
and think through each part of the assignment (as well as nay project code)
before we sit down at the computer. It is generally much more efficient to test,
debug, and run a program that we have though about beforehand, rather than doing
the planning "online." Diving into program development without a clear idea of
what we plan to do generally causes assignments to take much longer than necessary.

*Word to the wise:* This project is difficult. The trick lies in knowing which
 code to write, and for that we must understand the project code, which is
 considerable. We'll need to understand the general ideas of object-oriented
 programming and the implementation provided of an object-oriented programming
 system (in =objsys.scm=). Then we'll need to understand the particular classes
 (in =objtypes.scm=) and the world (in =setup.scm=) that they've constructed for
 us. In truth, this assignment in much more an exercise in reading and
 understanding a software system than in writing programs, because reading
 significant amounts of code is an important skill that we must master. The
 warmup exercises will require us to do considerable digesting of code before we
 can start on them. And we are *strongly urged* to study the code before we try
 the programming exercises themselves. Starting to program without understanding
 the code is a good way to get lost, and will virtually guarantee that we will
 spend more time on this assignment than necessary.

 In this project we will develop a powerful strategy for building simulations of
 possible worlds. The strategy will enable us to make modular simulations with
 enough flexibility to allow us to expand and elaborate the simulation as our
 conception of the world expands and becomes more detailed.

 One way to organize our thoughts about a possible world is to divide it up into
 discrete objects, where each object will have a behavior by itself, and it will
 interact with other objects in some lawful way. If it is useful to decompose a
 problem in this way then we can construct a computational world, analogous to
 the "real" world, with a computational object for each real object.

 Each of our computational objects has some independent local state, and some
 rules (or code), that determine its behavior. One computational object may
 influence another by sending it messages and invoking methods in the other. The
 program associated with an object describes how the object reacts to messages
 and how its state changes as a consequence.

 You may have heard of this idea in the guise of "Object-Oriented Programming
 systems" (OOPs!). Languages such as C++ and Java are organized around OOP.
 While OOP has received a lot of attention in recent years, it is only one of
 several powerful programming styles. What we will try to understand here is the
 essence of the idea, rather than the incidental details of their expression in
 particular languages.

** An Object System
Consider the problem of simulating the activity of a few interacting agents
wandering around different places in a simple world. Real people are very
complicated; we do not know enough to simulate their behavior in any detail. But
for some purposes (for example, to make an adventure game) we may simplify and
abstract this behavior. In particular, we can use objects to capture common
state parameters and behaviors of things, and can then use the message-passing
paradigm to control interaction between objects in a simulation.

Let's start with the fundamental stuff first. We can think of our object
oriented paradigm as consisting of classes and instances. A class can be thought
of as the "template" for how we want a particular kind of object to behave. The
way we define the class of an object is with a basic "make handler" procedure;
this procedure is used with a "create instance" procedure which builds for us a
particular instance. As we will see, when we examine the code, each class is
defined by a procedure that when invoked will create some internal state
(including instances of other class objects) and a message passing procedure
(created by a "make handler") that returns methods in response to messages.

Our object instances are thus procedures which accept messages. An object will
give us a method if we send it a message; we can then invoke that method
(possibly with some arguments) to cause some action, state update, or other
computation to occur.

The main pieces we will use in our code to capture these ideas are detailed as
follows:
- Instance of an object :: each individual object has its own identity. The
     instance knows its type, and has a message handler associated with it. One
     can "ask" an object to do something, which will cause the object to use the
     message handler to look for a method to handle the request and then invoke
     the method on the arguments.
- "Making" an object message handler :: each instance needs a new message
     handler to inherit the state information and methods of the specified
     class. The message handler is not a full "object instance" in our system;
     the message handler needs to be part of an instance object (or part of
     another message handler that is part of an instance object). All procedures
     that define classes should take a self pointer (a pointer to the enclosing
     instance) as the first argument.
- "Creating" an object :: the act of creation does three things: it makes a new
     instance of the object; it makes and sets the message handler for that
     instance; and finally it INSTALLS that new object into the world.
- "Installing" and object :: this is a method in the object, by which the object
     can initialize itself and insert itself into the world, by connecting
     itself up with other related objects in the world.


Let's look at these different elements in a bit more detail.

*** Classes and Instances
Here is the template for a class definition in our object system. This is quite
similar to the one introduced in the lecture (which was not available to us but
2004's version), but its interface have been cleaned up a little bit to make
things easier to read:

#+BEGIN_SRC scheme
(define (<type> self arg1 arg2 ... argn)
  (let ((<super1>-part (<super1> self args))
        (<super2>-part (<super1> self args))
        <other superclasses>
        <other local state>)
    (make-handler
     <type>
     (make-methods
      <message-name-1> <method-1>
      <message-name-2> <method-2>
      <other messages and methods>
      )
     <super1>-part <super2>-part ...)))
#+END_SRC

That form is a little mystifying (we have put some terms delimited by =<angle
bracket>= to indicate that these would be replaced by specific instances), so
let's look at an example. In our simulation, almost everything is going to have
a name, thus let's create a =named-object= class:

#+BEGIN_SRC scheme
(define (named-object self name)
  (let ((root-part (root-object self)))
    (make-handler
     'named-object                      ;name of the class
     (make-methods
      'NAME (lambda () name)
      'INSTALL (lambda () 'INSTALLED)
      'DESTROY (lambda () 'DESTROYED))
     root-part)))
#+END_SRC

So we can see that this class procedure defines a template for a class. It
include some state variables (both parameters required as part of the procedure
application, as well as any internal state variables we want to create); and it
creates a message handler for controlling instances of the objects. That is
performed by invoking =make-handler=, which takes as input the type of the
object, a set of message-method pairs, and any inherited superclasses. Note that
the message-method pairs are a combination of a symbol and a procedure that
will do something. Each such class procedure will be used to create instances
(see below).

We have designed some conventions, which will be useful in following the code.
We use the type of the object as the name of the procedure that defines a class
(e.g. =named-object= in the above example). Note that this is also the first
argument passed to the =make-handler= procedure.

The actual code for creating the handler is given by:
#+BEGIN_SRC scheme
(define (make-handler typename methods . super-parts)
  (cond ((not (symbol? typename))    ;check for possible programmer errors
         (error "bad typename" typename))
        ((not (method-list? methods))
         (error "bad method list" methods))
        ((and (not (null? super-parts))
              (null? (filter handler? super-parts)))
         (error "bad part list" super-parts))
        (else
         (named-lambda (handler message)
           (case message
             ((TYPE)
              (lambda () (type-extend typename super-parts)))
             ((METHODS)
              (lambda ()
                (append (method-names methods)
                        (append-map (lambda (x) (ask x 'METHODS))
                                    super-parts))))
             (else
              (let ((entry (method-lookup message methods)))
                (if entry
                    (cadr entry)
                    (find-method-from-handler-list
                     message
                     super-parts)))))))))
#+END_SRC

If we look through this code (we don't need to understand all of it!) we can see
that this procedure first checks for some error cases, and then in the general
case creates a procedure that takes as argument a =message= and then checks that
symbol against a set of cases (we may want to look up =named-lambda= in the
Scheme manual to see what it does). If it is the special case of =TYPE=, then it
returns a list of the types of objects inherited by this class. If it is special
case of =METHODS=, it returns a list of method names of this class, followed by
the method names inherited from associated superclasses. Otherwise it tries to
look up the =message= in the set inherited from the superclasses.

Note that =make-methods= will build a list of (name, procedure) pairs suitable
as input to =make-handler=.

#+BEGIN_SRC scheme
(define (make-methods . args)
  (define (helper lst result)
    (cond ((null? lst) result)

          ;; error catching
          ((null? (cdr lst))
           (error "unmatched method (name,proc) pair"))
          ((not (symbol? (car lst)))
           (if (procedure? (car lst))
               (pp (car lst)))
           (error "invalid method name" (car lst)))
          ((not (procedure? (cadr lst)))
           (error "invalid method procedure" (cadr lst)))

          (else
           (helper (cddr lst) (cons (list (car lst) (cadr lst)) result)))))
  (cons 'methods (reverse (helper args '()))))
#+END_SRC

This set of code is a slightly modified version of what was presented in lecture
(again it is not available to us), but with the same overall behavior. Every
/foo/ procedure defining a class of type /foo/ takes =self= as the first
argument. This indicates of which instance the class handler is a part.

Returning to our definition of =named-object= we see that the second argument to
=named-object= is =name=, which is part of the state of the =named-object=.

The =let= statement which binds =root-part= to the result of making a
=root-object=, together with the =type-extend= usage inside the =type= method of
=make-handler=, and the use of the =super-parts= at the end of the definition,
all together tell us that =named-object= s are a /subclass/ of =root-object=.

#+BEGIN_SRC scheme
(define (root-object self)
  (make-handler
   'root
   (make-methods
    'IS-A
    (lambda (type)
      (if (memq type (ask self 'TYPE)))))))
#+END_SRC

The root object provides a basis for providing common behaviors to all classes.
Specifically, it provides a convenient method (=IS-A=) to see if a type
descriptor is in the =TYPE= list. We will by convention use this class as the
root for all other classes.

Named-objects have no other local state than the =name= variable. They do have
four methods: =TYPE=, =NAME=, =INSTALL=, and =DESTROY=. The =TYPE= method comes
from the =make-handler= procedure and it indicates that =named-object= s have the
type =named-object= in addition to any type descriptors that the =root-part=
has. The =INSTALL= method is not required, but if it exists, it is called when
an instance is created. In the case of =named-object=, there is nothing to do at
creation time, but we'll later see examples where this method is non-trivial.
The =NAME= is a /selector/ in that is returns the name with which the object was
created.

However, the =named-object= procedure only builds a /handler/ for an object of
type =named-object=. In order to get an /instance/, we need a
=create-named-object= procedure:
#+BEGIN_SRC scheme
(define (create-named-object name)      ; symbol -> named-object
  (create-instance named-object name))
#+END_SRC

Here, an instance is created using the =named-object= procedure. The
=create-instance= procedure builds a handler procedure that serves as a
container for the real handler for the instance. It also attaches a tag or label
to the handler, so that we know we are working with an instance. We need this
extra complexity because each /foo/ procedure expects =self= as an argument, so
we build an instance object, then create the handler, passing the instance
object in for =self=. We'll explore more of this system in the questions below.
*** Using Instances
Once we have an instance, we can call the /methods/ on it using the =ask=
procedure:
#+BEGIN_SRC scheme
(define book (create-named-object 'sicp))

(ask book 'NAME)
;Value: sicp
                                        ;
(ask book 'TYPE)
;Value: (named-object root)
#+END_SRC

The =ask= procedure retrieves the method of the given name from the instance,
and then calls it. Retrieving a method from a handler is done with =get-method=,
which ends up calling the handler procedure with the method name as the
=message=. The specifics of the =ask= procedure and related procedures can be
found in =objsys.scm=.
*** Inheritance and Subclasses
We've already built a class, =named-object=, that /inherited/ from its parent
class, =root-object=. If the handler for a =named-object= is sent a message that
it doesn't recognize, it attempts to get a method from its parent (last line of
=make-handler= procedure). Each handler creates a private handler for its parent
to pass these messages to (the =let= statement in =named-object=). Because this
parent handler is part of the same instance as the overall handler, the =self=
value is the same in both.

However, let's move on to a subclass of =named-object= called a =thing=. A
=thing= is an object that will have a location in addition to a name. Thus, we
may think of a thing as a kind of named object except that it also handles the
messages that are special to things. This arrangement is described in various
ways in object-oriented jargon, e.g., "the =thing= class /inherits/ from the
=named-object= class," or "=thing= is a /subclass/ of =named-object=," or
"=named-object= is a /superclass/ of =thing=."

#+BEGIN_SRC scheme
(define (create-thing name location)    ; symbol, location -> thing
  (create-instance thing name location))

(define (thing self name location)
  (let ((named-part (named-object self name)))
    (make-handler
     'thing
     (make-methods
      'INSTALL  (lambda ()
                  (ask named-part 'INSTALL)
                  (ask (ask self 'LOCATION) 'ADD-THING self))
      'LOCATION (lambda () location)
      'DESTROY  (lambda ()
                  (ask (ask self 'LOCATION) 'DEL-THING self))
      'EMIT     (lambda (text)
                  (ask screen 'TELL-ROOM (ask self 'LOCATION)
                       (append (list "At" (ask (ask self 'LOCATION) 'NAME))
                               text))))
     named-part)))
#+END_SRC

A very interesting (and confusing!) property of object-oriented systems is that
subclasses can /specialize/ or /override/ methods of their superclasses. In
lecture, we saw this with professors =SAY= ing things differently than students.
A subclass /overrides/ a method on the /superclass/ by supplying a method of the
same name. For example, =thing= /overrides/ the =INSTALL= method of
=named-object=. When the user of the object tries to get the method named
=INSTALL=, it will be found in =thing= and =thing= 's version of the method will
be returned (because it never reaches the =else= clause in =make-handler= which
checks the parent =named-part=). The =thing= class /overrides/ two methods on
=named-object= explicitly (as well as two implicitly); =INSTALL= and =DESTROY=
would be the former case and =TYPE= and =METHODS= methods be the latter as we
will describe below.

One of the methods which =thing= overrides in an implicit manner is the =TYPE=
method. This is one of the methods that every class is supposed to override, as
it allows the class to include its /type descriptor/ in the list of types that
the object has. This allows the class of an instance to be discovered at run
time:

#+BEGIN_SRC scheme
(define building (create-thing 'stata-center MIT))

(ask building 'TYPE)
;Value: (thing named-object root)
#+END_SRC

There is a handy method on the =root-object= called =IS-A= that uses the =TYPE=
method to determine if an object has a certain type:

#+BEGIN_SRC scheme
(ask building 'IS-A 'thing)

;Value: #t

(ask building 'IS-A 'named-object)

;Value: #t

(ask book 'IS-A 'thing)

;Value: #f

(ask book 'IS-A 'named-object)

;Value: #t
#+END_SRC

You'll note that =building= is considered to be both a =thing= and a
=named-object=, because even though it was built as a =thing=, =thing= s inherit
from =named-object=.

*** Using superclass methods
In the =thing= code, the =DESTROY= method uses =(ask self 'LOCATION)= in order
to figure out where to remove itself from. However, it could have just
referenced the =location= variable. It doesn't because one of the tenets of
object-oriented programming is *"if there's a method that does what you need,
use it."* The idea is to re-use code as much as is reasonable. (It turns out
just using =location= would be a bug in this case; we'll be able to see why
after doing the warm-up exercises! -- more specifically we will encounter specified
situation in warmup exercise 6)

Some of the time, when we specialize a method, we want the subclass' method to
do something completely different than the superclass. For example, the way
massive-stars DIE (supernova!) is very different than the way stars DIE (burn
out). However, the rest of the time, we may want to specify some /additional/
behavior to the original. This presents a problem: how to call our superclass'
method from within the overriding method. Following the usual pattern of =(ask
self 'METHOD)= will give rise to an infinite loop! Thus, instead of =ask= ing
our =self=, we =ask= our superclass-=part=. Note that we do this with the
=INSTALL= method of a thing, where we explicitly ask the super-part to also
install, as well as doing some specific actions. /*This is the only situation in
which we should be asking our superclass-part!*/
** Classes for a Simulated World
When we read the code in =objtypes.scm=, we will see definitions of several
different classes of objects that define a host of interesting behaviors and
capabilities using the OOP style discussed in the previous section. Here we give
a brief "tour" of some of the important classes in our simulated world.

*** Container class
Once we have =thing= s, it is easy to imagine that we might want containers for
things. We can define a utility =container= class as shown below:
#+BEGIN_SRC scheme
(define (container self)
  (let ((root-part (root-object self))
        (things '()))
    (make-handler
     'container
     (make-methods
      'THINGS      (lambda () things)
      'HAVE-THING? (lambda (thing)
                     (if (memq thing things) #t #f))
      'ADD-THING (lambda (thing)
                   (if (not (ask self 'HAVE-THING? thing))
                       (set! things (cons thing things)))
                   'DONE)
      'DEL-THING (lambda (thing)
                   (set! things (delq thing things))
                   'DONE))
     root-part)))
#+END_SRC

Note that a container does not inherit from =named-object=, so it does not
support messages such as =NAME= or =INSTALL=. Containers are not meant to be
stand-alone objects (there's no =create-container= procedure); rather, they are
only meant to be used internally by other objects to gain the capability of
adding things, deleting things, and checking if one has something.
*** Place class
Our simulated world needs places (e.g. rooms or spaces) where interesting things
will occur. The definition of the =place= class is shown below.
#+BEGIN_SRC scheme
(define (create-place name)     ; symbol -> place
  (create-instance place name))

(define (place self name)
  (let ((named-part (named-object self name))
        (container-part (container self))
        (exits '()))
    (make-handler
     'place
     (make-methods
      'EXITS (lambda () exits)
      'EXIT-TOWARDS
      (lambda (direction)
        (find-exit-in-direction exits direction))
      'ADD-EXIT
      (lambda (exit)
        (let ((direction (ask exit 'DIRECTION)))
          (if (ask self 'EXIT-TOWARDS direction)
              (error (list name "already has exit" direction))
              (set! exits (cons exit exits)))
          'DONE)))
     container-part named-part)))
#+END_SRC

If we look at the first and last lines of =place=, we notice that =place=
inherits from two different classes: it has both an internal =named-part= and an
internal =container-part=. If the place receives a message that doesn't match
any of its methods, the get-method procedure will first check the
=container-part= for the method, then use the =named-part=. This is generally
called "multiple inheritance," which comes with a host of issues as discussed
briefly in lecture. We'll note that =named-object= and =container= only share
one method of the same name, =TYPE=, and =place= overrides it (by the definition
of =make-handler=). The =TYPE= method calls the =type-extend= procedure with
/both/ parent-parts. Retrieving the type of a place:
#+BEGIN_SRC scheme
(define stata (create-place 'stata-center))

;Value: stata

(ask stata 'TYPE)

;Value: (place container root named-object)
#+END_SRC

We aren't guaranteed anything about the order of the type-descriptors except
that the first descriptor in the list is the class that you instantiated to
create the instance. We can also see that our place instances will each have
their own internal variable =exits=, which will be a list of =exit= instances
which lead from one place to another place; if we focus this relationship
between place and exits we can think of theses as node and edges respectively,
which we learned in the previous project -- web as graph. In our object-oriented
terminology, we can say the place class establishes a "has-a" relationship with
the exit class (as opposed to the "is-a" relationship denoting inheritance). We
should examine the =objtypes.scm= file to understand the definition for exits.
*** Mobile-thing class
Now that we have things that can be contained in some place, we might also want
=mobile-thing= s that can =CHANGE-LOCATION=.

#+BEGIN_SRC scheme
(define (create-mobile-thing name location)
  ; symbol, location -> mobile-thing
  (create-instance mobile-thing name location))

(define (mobile-thing self name location)
  (let ((thing-part (thing self name location)))
    (make-handler
     'mobile-thing
     (make-methods
      'LOCATION  (lambda () location) ; This shadows message to thing-part!
      'CHANGE-LOCATION
      (lambda (new-location)
        (ask location 'DEL-THING self)
        (ask new-location 'ADD-THING self)
        (set! location new-location))
      'ENTER-ROOM    (lambda () #t)
      'LEAVE-ROOM    (lambda () #t)
      'CREATION-SITE (lambda () (ask thing-part 'location)))
     thing-part)))
#+END_SRC

When a mobile thing moves from one location to another it has to tell the old
location to =DEL-THING= from its memory, and tell the new location to =ADD-THING=.
You'll note that the =CHANGE-LOCATION= method adds and removes the =self= from
locations, thus the location contains a reference to the /instance/ not the
/handler/[fn:5]!
*** Person class
A person is a kind of mobile thing that is also a container. The objective of
the multiple inheritance is that people can "contain things" which they carry
around with them when they move.

A person can =SAY= a list of phrases. A person can =TAKE= and =DROP= things.
People also have a =health= meter which is reduced by =SUFFER= ing. If a
person's =health= reaches zero, they =DIE=. Some of the other messages a person
can handle are briefly shown below; we should consult the full definition of the
=person= class in =objtypes.scm= to understand the full set of capabilities a
person instance has.

#+BEGIN_SRC scheme
(define (create-person name birthplace) ; symbol, place -> person
  (create-instance person name birthplace))

(define (person self name birthplace)
  (let ((mobile-thing-part (mobile-thing self name birthplace))
        (container-part    (container self))
        (health            3)
        (strength          1))
    (make-handler
     'person
     (make-methods
      'STRENGTH (lambda () strength)
      'HEALTH (lambda () health)
      'SAY
      (lambda (list-of-stuff)
        (ask screen 'TELL-ROOM (ask self 'location)
             (append (list "At" (ask (ask self 'LOCATION) 'NAME)
                           (ask self 'NAME) "says --")
                     list-of-stuff))
        'SAID-AND-HEARD)
      'HAVE-FIT
      (lambda ()
        (ask self 'SAY '("Yaaaah! I am upset!"))
        'I-feel-better-now)

      ...

      'TAKE
      (lambda (thing)
        ...
        )

      'LOSE
      (lambda (thing lose-to)
        (ask self 'SAY (list "I lose" (ask thing 'NAME)))
        (ask self 'HAVE-FIT)
        (ask thing 'CHANGE-LOCATION lose-to))

      'DROP
      (lambda (thing)
        (ask self 'SAY (list "I drop" (ask thing 'NAME)
                             "at" (ask (ask self 'LOCATION) 'NAME)))
        (ask thing 'CHANGE-LOCATION (ask self 'LOCATION)))
      ...)
     mobile-thing-part container-part)))
#+END_SRC
*** Avatar class
One kind of character we will use in this project is an =avatar=. The avatar is
a kind of person who must be able to do the sorts of things a person can do,
such as =TAKE= things or =GO= in some direction. However, the avatar must be
able to intercept the =GO= message, to do things that are special to the avatar,
as well as do what a person does when it receives a =GO= message. This is again
accomplished by =ask= ing the superclass-=part=.

#+BEGIN_SRC scheme
(define (create-avatar name birthplace)
  ; symbol, place -> avatar
  (create-instance avatar name birthplace))

(define (avatar self name birthplace)
  (let ((person-part (person self name birthplace)))
    (make-handler
     'avatar
     (make-methods
      'LOOK-AROUND          ; report on world around you
      (lambda ()
        ...)

      'GO
      (lambda (direction)  ; Shadows person's GO
        (let ((success? (ask person-part 'GO direction)))
          (if success? (ask clock 'TICK))
          success?))

      'DIE
      (lambda (perp)
        (ask self 'SAY (list "I am slain!"))
        (ask person-part 'DIE perp)))

     person-part)))
#+END_SRC

The avatar also implements an additional message, =LOOK-AROUND=, which we will
find very useful when running simulations to get a picture of what the world
looks like around the avatar.
*** Clocks and Callbacks
In order to provide for the passage of time in our system, we have a global
clock object, whose implementation may be found in =objsys.scm=. This class has
exactly one instance which is created when =objys.scm= is loaded and bound to
the globally accessible variable =clock=. Unlike the real world, time passes
only when we want it to, by asking the clock to =TICK=. The rest of the system
finds out that time has passed because the clock informs them by sending them a
message. However, not every object cares about time, so the clock only informs
objects that have indicated to the clock that they care.

In order to hear about the passage of time, an object registers a /callback/
with the clock. A /callback/ is a promise to send a particular message to a
particular object when the callback is activated. As with everything else in our
system, a callback is an instance, in this case of the class =clock-callback=.
=Clock-callback= is =ACTIVATE= d, it sends the object the message (e.g. it does
=(ask object message)=).

To register a callback with the clock, use =ADD-CALLBACK= to add our callback to
the clock's list of callbacks. When the clock =TICK= s, it =ACTIVATE= s every
callback on its list. An example of the process, which registers a callback
named =do-thingy= to invoke the =THINGY= method on the current object:
#+BEGIN_SRC scheme
(ask clock 'ADD-CALLBACK
     (create-clock-callback 'do-thingy self 'THINGY))
#+END_SRC

Remember to remove callbacks (with =REMOVE-CALLBACK=) when the object should no
longer be responding to time.
*** Autonomous-person class
Our world would be a rather lifeless place unless we had objects that could
somehow "act" on their own. We achieve this by further specializing the person
class. An =autonomous-person= is a person who can move or take actions at
regular intervals, as governed by the clock through a callback. As described
above, the instance indicates that it wants to know when the clock ticks by
registering a callback with the clock. It does this upon creation by placing the
code to add the callback in the =INSTALL= method. Once again, the =INSTALL=
method wants to specify additional behavior, so it calls the superclass' method
by =ask= ing the =person-part=. Also note how, when an autonomous person dies,
we sent a "remove-callback" message to the clock, so that we stop asking this
character to act.

#+BEGIN_SRC scheme
(define (create-autonomous-person name birthplace activity miserly)
  (create-instance autonomous-person name birthplace activity miserly))

(define (autonomous-person self name birthplace activity miserly)
  (let ((person-part (person self name birthplace)))
    (make-handler
     'autonomous-person
     (make-methods
      'INSTALL
      (lambda ()
        (ask person-part 'INSTALL)
        (ask clock 'ADD-CALLBACK
             (create-clock-callback 'move-and-take-stuff self
                                    'MOVE-AND-TAKE-STUFF)))
      'MOVE-AND-TAKE-STUFF
      (lambda ()
        ;; first move
        (let loop ((moves (random-number activity)))
          (if (= moves 0)
              'done-moving
              (begin
                (ask self 'MOVE-SOMEWHERE)
                (loop (- moves 1)))))
        ;; then take stuff
        (if (= (random miserly) 0)
            (ask self 'TAKE-SOMETHING))
        'done-for-this-tick)
      'DIE
      (lambda (perp)
        (ask clock 'REMOVE-CALLBACK self 'move-and-take-stuff)
        (ask self 'SAY '("SHREEEEK!  I, uh, suddenly feel very faint..."))
        (ask person-part 'DIE perp))
      'MOVE-SOMEWHERE
      (lambda ()
        (let ((exit (random-exit (ask self 'LOCATION))))
          (if (not (null? exit)) (ask self 'GO-EXIT exit))))
      'TAKE-SOMETHING
      (lambda ()
        (let* ((stuff-in-room (ask self 'STUFF-AROUND))
               (other-peoples-stuff (ask self 'PEEK-AROUND))
               (pick-from (append stuff-in-room other-peoples-stuff)))
          (if (not (null? pick-from))
              (ask self 'TAKE (pick-random pick-from))
              #F))))
     person-part)))

#+END_SRC
** Configuring and Running the Game
Our world is built by the =setup= procedure that we will find in the file
=setup.scm=. We are the deity of this world. When we call =setup= with our name,
we create the world. It has rooms, objects, and people based on a minor
technical college on the banks of the Mighty Chunk River; and it has an avatar
(a manifestation of we, the deity, as a person in the world). The avatar is
under our control. It goes under our name and is also the value of the
globally-accessible variable =me=. Each time the avatar moves, simulated time
passes in the world, and the various other creatures in the world age by a time
step, possibly with a change in state (where they are, how healthy they are,
etc.). This works by using a clock that sends an activate message to all
callbacks that have been created. This causes certain objects to perform
specific actions. In addition, we can cause time to pass by explicitly calling
the clock, e.g. using =(run-clock 20)=.

If we want to see everything that is happening in the world, which is default
value, do
#+BEGIN_SRC scheme
(ask screen 'DEITY-MODE #t)
#+END_SRC
which causes the system to let we act as an all-seeing god. To turn this mode
off, do
#+BEGIN_SRC scheme
(ask screen 'DEITY-MODE #f)
#+END_SRC
in which case we will only see or hear those things that take place in the same
place as our avatar is. To check the status of this mode, do
#+BEGIN_SRC scheme
(ask screen 'DEITY-MODE?)
#+END_SRC

To make it easier to use the simulation, a convenient procedure is included,
=thing-named= for referring to an object /at the location of the avatar/. This
procedure is defined in the file =objsys.scm=

When we start the simulation, we will find ourself (the avatar) in one of the
locations of the world. There are various other characters present somewhere in
the world. We can explore this world, but the real goal is to survive the
onslaught of the denizens of darkness.

Here is a sample run of a variant of the system (a few new objects have been
added to this version but it gives we an idea of what will happen). Rather than
describing what's happening, it is leaved to us to examine the code that defines
the behavior of this world and interpret what is going on.

#+BEGIN_SRC scheme
(setup 'vandimort)

;Value: ready

(ask (ask me 'location) 'name)

;Value: great-court

(ask me 'look-around)

You are in great-court
You are not holding anything.
You see stuff in the room: boil-spell flag-pole lovely-trees
There are no other people around you.
The exits are in directions: up west north
;Value: ok

(ask me 'take (thing-named 'boil-spell))

At great-court vandimort says -- I take boil-spell from great-court
;Value: (instance #[compound-procedure 46 handler])

(ask me 'go 'north)

vandimort moves from great-court to lobby-10
--- the-clock Tick 0 ---
ben-bitdiddle moves from eecs-ug-office to eecs-hq
ben-bitdiddle moves from eecs-hq to |34-301|
At |34-301| ben-bitdiddle says -- I take boil-spell from |34-301|
alyssa-hacker moves from stata-center to stata-center
At stata-center alyssa-hacker says -- Hi dr-evil
course-6-frosh moves from bexley to baker
At baker course-6-frosh says -- I take slug-spell from baker
lambda-man moves from graduation-stage to great-court
dr-evil moves from stata-center to stata-center
At stata-center dr-evil says -- Hi alyssa-hacker
At stata-center dr-evil says -- What are you doing still up? Everyone back to their rooms!
At stata-center alyssa-hacker goes home to stata-center
mr-bigglesworth moves from lobby-7 to lobby-10
At lobby-10 mr-bigglesworth says -- Hi vandimort
mr-bigglesworth moves from lobby-10 to grendels-den
At grendels-den mr-bigglesworth says -- I'll let you off this once...
grendel moves from barker-library to |10-250|
grendel moves from |10-250| to lobby-10
At lobby-10 grendel says -- Hi vandimort
grendel moves from lobby-10 to grendels-den
At grendels-den grendel says -- Hi mr-bigglesworth
At grendels-den grendel takes a bite out of mr-bigglesworth
At grendels-den mr-bigglesworth says -- Ouch! 1 hits is more than I want!
registrar moves from legal-seafood to great-court
At great-court registrar says -- Hi lambda-man
;Value: #t

(run-clock 2)

--- the-clock Tick 1 ---
ben-bitdiddle moves from |34-301| to stata-center
At stata-center ben-bitdiddle says -- Hi alyssa-hacker dr-evil
ben-bitdiddle moves from stata-center to |34-301|
alyssa-hacker moves from stata-center to stata-center
At stata-center alyssa-hacker says -- Hi dr-evil
course-6-frosh moves from baker to bexley
course-6-frosh moves from bexley to student-center
At student-center course-6-frosh says -- I take slug-spell from student-center
lambda-man moves from great-court to lobby-10
At lobby-10 lambda-man says -- Hi vandimort
At lobby-10 lambda-man says -- I take boil-spell from lobby-10
dr-evil moves from stata-center to |34-301|
At |34-301| dr-evil says -- Hi ben-bitdiddle
dr-evil moves from |34-301| to eecs-hq
dr-evil moves from eecs-hq to |34-301|
At |34-301| dr-evil says -- Hi ben-bitdiddle
At |34-301| dr-evil says -- What are you doing still up? Everyone back to their rooms!
At |34-301| ben-bitdiddle goes home to eecs-ug-office
mr-bigglesworth moves from grendels-den to lobby-10
At lobby-10 mr-bigglesworth says -- Hi lambda-man vandimort
mr-bigglesworth moves from lobby-10 to building-13
At building-13 mr-bigglesworth says -- I'll let you off this once...
grendel moves from grendels-den to lobby-10
At lobby-10 grendel says -- Hi lambda-man vandimort
At lobby-10 grendel takes a bite out of lambda-man
At lobby-10 lambda-man says -- Ouch! 2 hits is more than I want!
registrar moves from great-court to graduation-stage
At graduation-stage registrar 's belly rumbles
--- the-clock Tick 2 ---
ben-bitdiddle moves from eecs-ug-office to eecs-hq
At eecs-hq ben-bitdiddle says -- I take slug-spell from eecs-hq
alyssa-hacker moves from stata-center to stata-center
course-6-frosh moves from student-center to bexley
At bexley course-6-frosh says -- I take slug-spell from bexley
lambda-man moves from lobby-10 to building-13
At building-13 lambda-man says -- Hi mr-bigglesworth
dr-evil moves from |34-301| to edgerton-hall
At edgerton-hall dr-evil says -- What are you doing still up? Everyone back to their rooms!
mr-bigglesworth moves from building-13 to edgerton-hall
At edgerton-hall mr-bigglesworth says -- Hi dr-evil
mr-bigglesworth moves from edgerton-hall to legal-seafood
At legal-seafood mr-bigglesworth says -- What are you doing still up? Everyone back to their rooms!
grendel moves from lobby-10 to grendels-den
grendel moves from grendels-den to lobby-10
At lobby-10 grendel says -- Hi vandimort
grendel moves from lobby-10 to great-court
At great-court grendel 's belly rumbles
registrar moves from graduation-stage to great-court
At great-court registrar says -- Hi grendel
At great-court registrar takes a bite out of grendel
At great-court grendel says -- Ouch! 1 hits is more than I want!
;Value: done

(ask screen 'deity-mode #f)

;Value: #t

(run-clock 3)

--- the-clock Tick 3 ---
At lobby-10 lambda-man says -- Hi vandimort
At lobby-10 registrar says -- Hi lambda-man vandimort
--- the-clock Tick 4 ---
lambda-man moves from lobby-10 to grendels-den
At lobby-10 dr-evil says -- Hi registrar vandimort
At lobby-10 dr-evil says -- What are you doing still up? Everyone back to their rooms!
At lobby-10 registrar goes home to legal-seafood
At lobby-10 vandimort goes home to great-court
At great-court grendel says -- Hi vandimort
grendel moves from great-court to legal-seafood
At great-court registrar says -- Hi vandimort
--- the-clock Tick 5 ---
At great-court dr-evil says -- Hi registrar vandimort
dr-evil moves from great-court to lobby-10
At great-court grendel says -- Hi registrar vandimort
grendel moves from great-court to legal-seafood
registrar moves from great-court to graduation-stage
An earth-shattering, soul-piercing scream is heard...
;Value: done

(ask me 'look-around)

You are in great-court
You are holding: boil-spell
You see stuff in the room: flag-pole lovely-trees
There are no other people around you.
The exits are in directions: up west north
;Value: ok
#+END_SRC

In parts of this project, we will be asked to elaborate or enhance the world
(e.g. add things ins =setup.scm=), as well as add to the behaviors or kinds of
objects in the system (e.g. modify =objtypes.scm=). If we do make such changes,
we must remember to re-evaluate all definitions and re-run =(setup 'our-name)=
if we change anything, just to make sure that all our definitions are up to
date. An easy way to do this is to reload all the files (be sure to save our
files to disk before reloading), and then re-evaluate =(setup 'our-name)=.
** Warmup Exercises
These exercises are intended to help us get a head start on understanding our
object-oriented world before we start writing code. Note that for the first two
exercises, the result is a diagram, which we can draw by hand.

*** Warmup Exercise 1
In the transcript above there is a line: =(ask (ask me 'location) 'name)=. What
kind of value does =(ask me 'location)= return here? What other messages,
besides name, can we send to this value?

**** Answer
It returns the instance of =place= class stored in =me= as part of state
variable; more specifically, included in =mobile-thing=-part indirectly. We can
call whatever method defined in =place= class (and the superclass' of it --
=named-object=, =container=, =root-object=).
*** Warmup Exercise 2
Look through the code in =objtypes.scm= to discover which classes are defined in
this system and how the classes are related. For example, =place= is a subclass
of =named-object=. Also look thorough the code in =setup.scm= to see what the
world looks like. Draw a class diagram like the ones presented in lecture. We
will find such a diagram helpful (maybe indispensable) in doing the programming assignment.

**** Answer
I've done this manually; here we attempt to do the task by using the program
called plantUML.

#+BEGIN_SRC plantuml :file ../image/classdiagram.png
class root-object {
    self
    {method} IS-A
}

class named-object {
    name
    __
    NAME
    INSTALL
    DESTROY
}

class container {
    things
    __
    THINGS
    HAVE-THING?
    ADD-THING
    DEL-THING
}

class thing {
    name
    location
    __
    INSTALL
    LOCATION
    DESTROY
    EMIT
}

class exit {
    from
    direction
    to
    __
    INSTALL
    FROM
    TO
    DIRECTION
    USE
}

class place {
    name
    exits
    __
    EXITS
    EXIT-TOWARDS
    ADD-EXIT
}

class mobile-thing {
    name
    location
    __
    LOCATION
    CHANGE-LOCATION
    ENTER-ROOM
    LEAVE-ROOM
    CREATION-SITE
}

class spell {
    name
    location
    incant
    action
    __
    INCANT
    ACTION
    USE
}

class person {
    name
    birthplace
    health
    strength
    __
    STRENTH
    HEALTH
    SAY
    HAVE-FIT
    PEOPLE-AROUND
    STUFF-AROUND
    PEEK-AROUND
    TAKE
    LOSE
    DROP
    GO-EXIT
    GO
    SUFFER
    DIE
    ENTER-ROOM
}

class autonomous-person {
    name
    birthplace
    activity
    miserly
    __
    INSTALL
    MOVE-AND-TAKE-STUFF
    DIE
    MOVE-SOMEWHERE
    TAKE-SOMETHING
}

class avatar {
    name
    birthplace
    __
    LOOK-AROUND
    GO
    DIE
}

class hall-monitor {
    name
    birthplace
    speed
    irritability
    __
    INSTALL
    IRRITATE-STUDENT
    DIE
}

class troll {
    name
    birthplace
    speed
    hunger
    __
    INSTALL
    EAT-PEOPLE
    DIE
}

"root-object" <|-- "named-object"
"root-object" <|-- "container"
"named-object" <|-- "thing"
"named-object" <|-- "exit"
"named-object" <|-- "place"
"container" <|-- "place"
"container" <|-- "person"
"thing" <|-- "mobile-thing"
"mobile-thing" <|-- "spell"
"mobile-thing" <|-- "person"
"person" <|-- "autonomous-person"
"person" <|-- "avatar"
"autonomous-person" <|-- "hall-monitor"
"autonomous-person" <|-- "troll"

thing ..* place : "has-a"
exit *..* place : "has-a"
#+END_SRC

#+caption: Class diagram
#+RESULTS:
[[file:../image/classdiagram.png]]
*** Warmup Exercise 3
Look at the contents of the file =setup.scm=. What places are defined? How are
they interconnected? Draw a map. We must be able to show the places and the
exits that allow one to go from one place to a neighboring place.

I've done this task using my personal digital paper; since couldn't find some program
that is easy enough to use and appropriate for this task, let myself satisfy
with the handwritten result.
*** Warmup Exercise 4
Aside from we, the avatar, what other characters roams this world? What sorts of
things are around? How is it determined which room each person and thing starts
out in?

**** Answer
We can answer by inspecting the contents of =setup= procedure in =setup.scm=:
- Other characters:
  - Students (=autonomous-person=), distributed randomly by =populate-players=
    over =rooms=:
    - Ben Bitdiddle, Alyssa Hacker, Course 6 frosh, Lambda Man
  - Monitors (=hall-monitor=):
    - Dr. Evil, Mr. Bigglesworth
  - Trolls (=troll=):
    - Grendel, Registrar
- Static things (=thing=):
  - blackboard at 10-250
  - lovely trees at great-court
  - tons of code at baker
  - problem set at 10-250
  - recitation problem at 10-250
  - sicp at stata center
  - engineering book at barker-library
  - diploma at graduation stage
- Spells (=spell=), each room assigned one of the following spells randomly by
  =populate-spells= over =rooms=:
  - boil spell
  - slug spell
*** Warmup Exercise 5
Create an environment diagram corresponding the evaluation of =(define my-foo
(create-thing 'foo some-location))=. *Warning:* this environment diagram can get
out of hand, and we required to use this exercise to get a sense of how the
system works. So, we supposed to do not worry about the value bound to
=some-location=, just draw it as a blob. Similarly, don't worry about showing
the object bound to =maker=. For the bindings associated with =methods=, just
leave the actual value blank. Once we have drawn our environment model, draw
boxes around the structures that correspond to each of the super-parts of the
object created.

I've done this with my digital paper.
*** Warmup Exercise 6
To warm up, load the three files =objsys.scm=, =objtypes.scm= and =setup.scm=
and start the simulation by typing =(set up '<our name>)= (where we replace
=<our name>= with an actual name, of course!). Walk the avatar to a room that
has an unowned object. Have the avatar =take= this object, only to =drop= it
somewhere else. Show a transcript of this session.

#+BEGIN_SRC scheme
(setup 'jang)

;Value: ready

(ask me 'look-around)

You are in building-13
You are not holding anything.
You see stuff in the room: slug-spell
There are no other people around you.
The exits are in directions: north south
;Value: ok

(ask screen 'deity-mode #f)

;Value: #t

(ask me 'take (thing-named 'slug-spell))

At building-13 jang says -- I take slug-spell from building-13
;Value: (instance #[compound-procedure 38 handler])

(ask me 'go 'south)

jang moves from building-13 to lobby-10
--- the-clock Tick 0 ---
At lobby-10 course-6-frosh says -- Hi jang
At lobby-10 lambda-man says -- Hi course-6-frosh jang
At lobby-10 grendel says -- Hi lambda-man course-6-frosh jang
;Value: #t

(ask me 'look-around)

You are in lobby-10
You are holding: slug-spell
You see stuff in the room: boil-spell
You see other people: grendel lambda-man course-6-frosh
The exits are in directions: south north west down up
;Value: ok

(ask me 'drop (thing-named 'slug-spell))

At lobby-10 jang says -- I drop slug-spell at lobby-10
;Value: (instance #[compound-procedure 39 handler])

(ask me 'look-around)

You are in lobby-10
You are not holding anything.
You see stuff in the room: slug-spell boil-spell
You see other people: grendel lambda-man course-6-frosh
The exits are in directions: south north west down up
;Value: ok
#+END_SRC
** Computer Exercises
*** Some general hints for success:
- When you need to test a new object that you have created, you can just
  "create" it in front of you after you run setup. For example. to test a wand
  (see below), you can use
  #+BEGIN_SRC scheme
(begin (setup 'my-name)
       (create-wand 'my-wand (ask me 'location))
       (ask me 'take (thing-named 'my-wand))
       (ask (thing-named 'my-wand) 'wave))
  #+END_SRC
  You should not need to change the setup code to do simple tests.
- Don't forget to re-run setup after you change the code for one of the classes!
  That is, re-evaluating the class' procedure definition does not change the
  instances of the class that already exist in the world.
- Never use =thing-named= in object code, only for testing; this is a corollary
  to never using "me" except in testing.
- Outside of the code for create-world, variables such as =lobby-10= are not
  bound to a value. This means you can't teleport there, or create objects
  there, or ask it questions without filtering over the variable =all-rooms=.
*** Hairy Cdr and the Chamber of Stata
Recently, the Wizard's Institute of Technocracy (WIT) revealed itself as an
additional department at MIT. It came full-fledged with a large mysterious
building topped by twin towers. Preliminary exploration of this building
revealed a very confusing interior (kind of maze-like) and an utter lack of
square corners. Deep within the center of the building is the reputed Chamber of
Stata; the source for magic on the eastern seaboard. To the non-muggles, the
building is chock-full of mystical energy, and students have flocked to the new
department. We follow the adventures of Hairy Cdr, a young student at WIT who
narrowly escaped destruction at the hands of a notoriously evil wizard Lord
Vandimort.
*** Computer Exercise 1: An adventure of =self=-discovery
We are provided a powerful tool for exploring the structure of the object system
in the form of the procedure =show=. For example, after doing a =(setup
'yourname)=, we can examine the avatar instance with:

#+BEGIN_SRC scheme
(show me)
INSTANCE (instance #[compound-procedure 74 handler])
 TYPE: (avatar person mobile-thing thing named-object root container)
 HANDLER: #[compound-procedure 74 handler]
 TYPE: avatar
(methods (look-around #[compound-procedure 77])
         (go #[compound-procedure 76])
         (die #[compound-procedure 75]))
  Parent frame: #[environment 78]
  person-part:  #[compound-procedure 79 handler]
    Parent frame: global-environment
    self:         (instance #[compound-procedure 74 handler])
    name:         your-name
    birthplace:   (instance #[compound-procedure 80 handler])
;Value: instance
#+END_SRC

Your numbers may differ, as they are assigned based on when the procedures are
created, but the form should be the same. The printout includes the type and
state of the object, including the handlers for the parents of the object. From
here, we can continue to explore the world by looking at any of the procedures
displayed. For example, to look at the birthplace (which was =(instance
#[compound-procedure 80 handler])=):

#+BEGIN_SRC scheme
(show #[compound-procedure 80 handler])
 HANDLER: #[compound-procedure 80 handler]
 TYPE: place
(methods (exits #[compound-procedure 83])
         (exit-towards #[compound-procedure 82])
         (add-exit #[compound-procedure 81]))
  Parent frame:   #[environment 84]
  named-part:     #[compound-procedure 85 handler]
  container-part: #[compound-procedure 86 handler]
  exits:          ((instance #[compound-procedure 88 handler])
                 (instance #[compound-procedure 87 handler]))
    Parent frame: global-environment
    self:         (instance #[compound-procedure 80 handler])
    name:         legal-seafood
;Value: handler
#+END_SRC

In this manner, we can explore the any object in the system. We can use =#@80=
as a shortcut for =#[compound-procedure 80 handler]=.

**** Questions
- Turn in a copy of the show procedure output corresponding to the thing-part of
  the avatar object. You'll need to go up the inheritance tree a little ways to
  find it.

  We trace the inheritance tree using the previous figure we drew in [[Warmup Exercise 2][Warmup
  Exercise 2]]:
  - =person-part= (=#@79=) \to =mobile-part= (=#@95=) \to =thing-part= (=#@103=)
    #+BEGIN_SRC scheme
  (show #@79)
   HANDLER: #[compound-procedure 79 handler]
   TYPE: person
  (methods (strength #[compound-procedure 93])
           (health #[compound-procedure 92])
           (say #[compound-procedure 91])
           (have-fit #[compound-procedure 90])
           (people-around #[compound-procedure 89])
           ...)
    Parent frame:      #[environment 94]
    mobile-thing-part: #[compound-procedure 95 handler]
    container-part:    #[compound-procedure 96 handler]
    health:            3
    strength:          1
      Parent frame: global-environment
      self:         (instance #[compound-procedure 74 handler])
      name:         your-name
      birthplace:   (instance #[compound-procedure 80 handler])
  ;Value: handler

  (show #@95)
   HANDLER: #[compound-procedure 95 handler]
   TYPE: mobile-thing
  (methods (location #[compound-procedure 101])
           (change-location #[compound-procedure 100])
           (enter-room #[compound-procedure 99])
           (leave-room #[compound-procedure 98])
           (creation-site #[compound-procedure 97]))
    Parent frame: #[environment 102]
    thing-part:   #[compound-procedure 103 handler]
      Parent frame: global-environment
      self:         (instance #[compound-procedure 74 handler])
      name:         your-name
      location:     (instance #[compound-procedure 80 handler])
  ;Value: handler

  (show #@103)
   HANDLER: #[compound-procedure 103 handler]
   TYPE: thing
  (methods (install #[compound-procedure 107])
           (location #[compound-procedure 106])
           (destroy #[compound-procedure 105])
           (emit #[compound-procedure 104]))
    Parent frame: #[environment 108]
    named-part:   #[compound-procedure 109 handler]
      Parent frame: global-environment
      self:         (instance #[compound-procedure 74 handler])
      name:         your-name
      location:     (instance #[compound-procedure 80 handler])
  ;Value: handler
    #+END_SRC
- Turn in a copy of the show procedure output corresponding to the
  container-part of the place in which the avatar resides.

  To do this, we
  1. find out the location where our avatar resides;
     #+BEGIN_SRC scheme
(show (ask me 'location))
INSTANCE (instance #[compound-procedure 80 handler])
 TYPE: (place container root named-object)
 HANDLER: #[compound-procedure 80 handler]
 TYPE: place
(methods (exits #[compound-procedure 83])
         (exit-towards #[compound-procedure 82])
         (add-exit #[compound-procedure 81]))
  Parent frame:   #[environment 84]
  named-part:     #[compound-procedure 85 handler]
  container-part: #[compound-procedure 86 handler]
  exits:          ((instance #[compound-procedure 88 handler])
                 (instance #[compound-procedure 87 handler]))
    Parent frame: global-environment
    self:         (instance #[compound-procedure 80 handler])
    name:         legal-seafood
;Value: instance
     #+END_SRC

  2. using =show= procedure trace along the =container-part=.
     #+BEGIN_SRC scheme
(show #@86)
 HANDLER: #[compound-procedure 86 handler]
 TYPE: container
(methods (things #[compound-procedure 113])
         (have-thing? #[compound-procedure 112])
         (add-thing #[compound-procedure 111])
         (del-thing #[compound-procedure 110]))
  Parent frame: #[environment 114]
  root-part:    #[compound-procedure 115 handler]
  things:       ((instance #[compound-procedure 74 handler])
               (instance #[compound-procedure 117 handler])
               (instance #[compound-procedure 116 handler]))
    Parent frame: global-environment
    self:         (instance #[compound-procedure 80 handler])
;Value: handler
     #+END_SRC
- After your avatar has moved from its birthplace, use the show procedures to
  demonstrate what you discovered in warmup exercise 6 about the values of the
  location variables in =thing= and =mobile-thing=.
  #+BEGIN_SRC scheme
(ask me 'look-around)

You are in legal-seafood
You are not holding anything.
You see stuff in the room: slug-spell
You see other people: alyssa-hacker
The exits are in directions: east south
;Value: ok

(ask me 'go 'east)

your-name moves from legal-seafood to great-court
--- the-clock Tick 0 ---
At great-court course-6-frosh says -- Hi your-name
;Value: #t

(ask me 'location)

;Value: (instance #[compound-procedure 118 handler])

(ask (ask me 'location) 'name)

;Value: great-court

(ask (ask #@95 'location) 'name)

;Value: great-court

(ask (ask #@103 'location) 'name)

;Value: legal-seafood
  #+END_SRC

  From these experiment, we can deduce that the location registered in
  =thing-part= doesn't change once it created with; whereas =mobile-part='s
  change whenever the instance move around.

  Let we apply what we discovered to warmup exercise 6: The taken thing --
  =slug-spell= in our case -- is instance of =mobile-part= (we can substitute
  instance of subclass of one as instance of one; it is one of the contract
  inheritance relationship in OOP) changes its location from its creation site
  =building-13= to the avatar and finally to =lobby-10= where =me= drop that
  stuff. More specifically, as =mobile-part='s =loaction= method overrides
  =thing-part='s, if we ask the instance its location, if the class of instance
  does not override the =location= method further, it return the method of
  =mobile-part= -- in other words, it shadows super-part's method.
- Finally, investigate all the superclass handlers in the avatar object. Does
  the value of the =self= variable ever change? If it does change, what other
  thing(s) does it point to? If it doesn't, what does it always point to?

  We can simply answer to this question from what we've learned from lecture (or
  =objsys.scm=) that all the parts of instance point to that instance using
  =self= parameter; it was the contract to the structure of OOP. But we can
  inspect this fact not depending on the contract but by observing the results
  of experiments. Here, we use the latter approach as the question want that.

  With help of the hierarchical structure of our classes, we can deduce the
  superclasses of the avatar as follows: person, mobile-thing, thing,
  named-object, root, container.

  Or by using the =type= method of =avatar=,
  #+BEGIN_SRC scheme
(ask me 'type)

;Value: (avatar person mobile-thing thing named-object root container)
  #+END_SRC

  Let we inspect all of the value of =self= in above instance part of classes:
  #+BEGIN_SRC scheme
;; avatar
(show me)
INSTANCE (instance #[compound-procedure 74 handler])
 TYPE: (avatar person mobile-thing thing named-object root container)
 HANDLER: #[compound-procedure 74 handler]
 TYPE: avatar
(methods (look-around #[compound-procedure 77])
         (go #[compound-procedure 76])
         (die #[compound-procedure 75]))
  Parent frame: #[environment 78]
  person-part:  #[compound-procedure 79 handler]
    Parent frame: global-environment
    self:         (instance #[compound-procedure 74 handler])
    name:         your-name
    birthplace:   (instance #[compound-procedure 80 handler])
;Value: instance

;; person
(show #@79)
 HANDLER: #[compound-procedure 79 handler]
 TYPE: person
(methods (strength #[compound-procedure 93])
         (health #[compound-procedure 92])
         (say #[compound-procedure 91])
         (have-fit #[compound-procedure 90])
         (people-around #[compound-procedure 89])
         ...)
  Parent frame:      #[environment 94]
  mobile-thing-part: #[compound-procedure 95 handler]
  container-part:    #[compound-procedure 96 handler]
  health:            3
  strength:          1
    Parent frame: global-environment
    self:         (instance #[compound-procedure 74 handler])
    name:         your-name
    birthplace:   (instance #[compound-procedure 80 handler])
;Value: handler

;; mobile-thing
(show #@95)
 HANDLER: #[compound-procedure 95 handler]
 TYPE: mobile-thing
(methods (location #[compound-procedure 101])
         (change-location #[compound-procedure 100])
         (enter-room #[compound-procedure 99])
         (leave-room #[compound-procedure 98])
         (creation-site #[compound-procedure 97]))
  Parent frame: #[environment 102]
  thing-part:   #[compound-procedure 103 handler]
    Parent frame: global-environment
    self:         (instance #[compound-procedure 74 handler])
    name:         your-name
    location:     (instance #[compound-procedure 118 handler])
;Value: handler

;; thing
(show #@103)
 HANDLER: #[compound-procedure 103 handler]
 TYPE: thing
(methods (install #[compound-procedure 107])
         (location #[compound-procedure 106])
         (destroy #[compound-procedure 105])
         (emit #[compound-procedure 104]))
  Parent frame: #[environment 108]
  named-part:   #[compound-procedure 109 handler]
    Parent frame: global-environment
    self:         (instance #[compound-procedure 74 handler])
    name:         your-name
    location:     (instance #[compound-procedure 80 handler])
;Value: handler

;; named-object
(show #@109)
 HANDLER: #[compound-procedure 109 handler]
 TYPE: named-object
(methods (name #[compound-procedure 127])
         (install #[compound-procedure 126])
         (destroy #[compound-procedure 125]))
  Parent frame: #[environment 128]
  root-part:    #[compound-procedure 129 handler]
    Parent frame: global-environment
    self:         (instance #[compound-procedure 74 handler])
    name:         your-name
;Value: handler

;; root
(show #@129)
 HANDLER: #[compound-procedure 129 handler]
 TYPE: root
(methods (is-a #[compound-procedure 130]))
  Parent frame: global-environment
  self:         (instance #[compound-procedure 74 handler])
;Value: handler

;; container
(show #@96)
 HANDLER: #[compound-procedure 96 handler]
 TYPE: container
(methods (things #[compound-procedure 122])
         (have-thing? #[compound-procedure 121])
         (add-thing #[compound-procedure 120])
         (del-thing #[compound-procedure 119]))
  Parent frame: #[environment 123]
  root-part:    #[compound-procedure 124 handler]
  things:       ()
    Parent frame: global-environment
    self:         (instance #[compound-procedure 74 handler])
;Value: handler

;; root
(show #@124)
 HANDLER: #[compound-procedure 124 handler]
 TYPE: root
(methods (is-a #[compound-procedure 131]))
  Parent frame: global-environment
  self:         (instance #[compound-procedure 74 handler])
;Value: handler
  #+END_SRC

  As expected all the super-parts of =me= point =me= as the value of =self= variable.
*** Computer Exercise 2: I know I had one of those things somewhere...
For many of the things that follow, it is going to be handy to be able to tell
if a person has in his/her possession either a specific type of thing, or a
specific instance of a thing. For example, we might want to know if a person has
any objects of type =spell=:
#+BEGIN_SRC scheme
(ask me 'HAS-A 'spell)

;Value: ((instance #[compound-procedure 134 handler]))
#+END_SRC

That is, we can ask if some person (me in this case) has any objects of a
particular type. This should look through the set of =THINGS= held by the person
and return a list of those objects, or the empty list if the person does not
possess any objects of this type.

We can code above specification directly by
#+BEGIN_SRC dot :file ../image/proj4_1.png :exports results
digraph {
        subgraph cluster {
        label="self's things"
        thing;
        }
        thing -> "(eq? type (ask _ 'type))";
        "(eq? type (ask _ 'type))" -> result;
        }
#+END_SRC

#+caption: Visualizing the specification
#+RESULTS:
[[file:../image/proj4_1.png]]

#+BEGIN_SRC scheme
,*** in person class
      'HAS-A
      (lambda (type)
        (filter (lambda (thing) (eq? type (car (ask thing 'TYPE)))) (ask self 'THINGS)))
#+END_SRC

Or using the =find-all= procedure:
#+BEGIN_SRC scheme
,*** in person class
      'HAS-A
      (lambda (type)
        (find-all self type))
#+END_SRC

The second behavior we want is similar, but now we are looking for an instance
of an object with a particular name:

#+BEGIN_SRC scheme
(ask me 'HAS-A-THING-NAMED 'slug-spell)

;Value: ((instance #[compound-procedure 134 handler]))
#+END_SRC

Modify your definition of =person= to add these two new methods. Demonstrate
them working on some test cases.

Analogous to previous method, we can implement given specification as
#+BEGIN_SRC scheme
,*** in person class
      'HAS-A-THING-NAMED
      (lambda (name)
        (filter (lambda (thing) (eq? name (ask thing 'NAME))) (ask self 'THINGS)))
#+END_SRC

Here is the sequence of tests:
#+BEGIN_SRC scheme
(ask me 'look-around)

You are in edgerton-hall
You are not holding anything.
You see stuff in the room: slug-spell
There are no other people around you.
The exits are in directions: north up south
;Value: ok

(ask me 'take (thing-named 'slug-spell))

At edgerton-hall jang says -- I take slug-spell from edgerton-hall
;Value: (instance #[compound-procedure 134 handler])

(ask me 'HAS-A-THING-NAMED 'slug-spell)

;Value: ((instance #[compound-procedure 134 handler]))

(ask me 'HAS-A 'spell)

;Value: ((instance #[compound-procedure 134 handler]))
#+END_SRC
*** Computer Exercise 3: Scoping the Joint
Hairy is a big fan of Star Wars -- he has seen it a zillion times (Hey -- George
Lucas was a Hogwarts' graduate). As a consequence, a key element in his tool of
tricks is an ability to sense the locations of people in the world, by "feeling
the force".

Add a method =FEEL-THE-FORCE= to the =avatar= which displays the name and
location of everybody. We will find the procedure =all-people= (see the file
=objsys.scm=) useful. And we may find the procedure =for-each= useful. The
behavior we want is shown below (note that is sees "me" -- vandimort in this
case):

#+BEGIN_SRC scheme
(ask me 'FEEL-THE-FORCE)

mr-bigglesworth is at barker-library
alyssa-hacker is at barker-library
grendel is at eecs-ug-office
vandimort is at |34-301|
registrar is at great-court
course-6-frosh is at stata-center
dr-evil is at bexley
lambda-man is at bexley
ben-bitdiddle is at baker
;Unspecified return value
#+END_SRC

The code:
#+BEGIN_SRC scheme
,*** in the avatar class
      'FEEL-THE-FORCE
      (lambda ()
        (for-each (lambda (p)
                    (newline)
                    (display (ask p 'name))
                    (display " is at ")
                    (display (ask (ask p 'location) 'name)))
                  (all-people)))
#+END_SRC

Actually the example shown above was the test of above procedure.
*** Computer Exercise 4: Sometimes Being Vague is in Vogue
Another key component of Hairy Cdr's success is his Ring of Obfuscation. This
brass ring engraved with the shape of beaver prevents the person carrying it
from being seen! Implement a new type of mobile-thing, a ring-of-obfuscation. A
ring-of-obfuscation is an instance of an object that does not accept any new
types of messages, being the simplest extension of a mobile-object. Then change
=person= so that when they look for the =PEOPLE-AROUND=, people who are carrying
rings-of-obfuscation are not returned. Note that the "feel the force" ability
should be fooled by such rings, so you may want to alter your solution to
Exercise 3 to reflect this.

**** Answer
The ring-of-obfuscation is just mobile-thing but with different type if we
summary above specification:
#+BEGIN_SRC scheme
(define (ring-of-obfuscation self location)
  (let ((mobile-part (mobile-thing self 'ring-of-obfuscation location)))
    (make-handler
     'ring-of-obfuscation
     (make-methods)
     mobile-part)))
#+END_SRC

Then for the first part of the requirement -- =PEOPLE-AROUND= method:
#+BEGIN_SRC dot :file ../image/proj4_2.png :exports results
digraph {
        subgraph cluster {
        label="People around in the room"
        person;
        }
        person -> "except self";
        "except self"-> "(null? (ask _ 'HAS-A 'ring-of-obfuscation))";
        }
#+END_SRC

#+RESULTS:
[[file:../image/proj4_2.png]]

Then the code, which implement above specification:
#+BEGIN_SRC scheme
,*** in person class
      'PEOPLE-AROUND                    ; other people in room...
      (lambda ()
        ;; Exercise 4
        (filter (lambda (p)
                  (null? (ask p 'HAS-A 'ring-of-obfuscation)))

                (delq self (find-all (ask self 'LOCATION) 'PERSON))))
#+END_SRC

And for the avatar:
#+BEGIN_SRC scheme
,*** in avatar class
      'FEEL-THE-FORCE
      (lambda ()
        (for-each (lambda (p)
                    (newline)
                    (display (ask p 'name))
                    (display " is at ")
                    (display (ask (ask p 'location) 'name)))
                  (filter (lambda (p) (null? (ask p 'HAS-A 'ring-of-obfuscation)))
                          (all-people))))
#+END_SRC

For the population of this ring, we decided to make this ring to be unique one:
#+BEGIN_SRC scheme
(define (populate-ring-of-obfuscation rooms)
  (create-ring-of-obfuscation (pick-random rooms)))
#+END_SRC

Then add appropriate code to the =setup=:
#+BEGIN_SRC scheme
,*** in setup
    (populate-spells rooms)

    (populate-players rooms)

    (populate-ring-of-obfuscation rooms)
#+END_SRC

And then test:
#+BEGIN_SRC scheme
(setup 'vandimort)

;Value: ready

(create-ring-of-obfuscation me)

;Value: (instance #[compound-procedure 146 handler])

(ask me 'look-around)

You are in |10-250|
You are holding: ring-of-obfuscation
You see stuff in the room: boil-spell recitation-problem problem-set blackboard
There are no other people around you.
The exits are in directions: up down
;Value: ok

(ask me 'FEEL-THE-FORCE)

registrar is at barker-library
course-6-frosh is at barker-library
dr-evil is at |6001-lab|
ben-bitdiddle is at building-13
grendel is at stata-center
lambda-man is at baker
alyssa-hacker is at legal-seafood
mr-bigglesworth is at graduation-stage
;Unspecified return value

(ask me 'go 'down)

vandimort moves from |10-250| to lobby-10
--- the-clock Tick 0 ---
At lobby-10 ben-bitdiddle says -- I take boil-spell from lobby-10
At lobby-10 course-6-frosh says -- Hi ben-bitdiddle
;Value: #t

(ask me 'look-around)

You are in lobby-10
You are holding: ring-of-obfuscation
You see stuff in the room: ring-of-obfuscation
You see other people: course-6-frosh ben-bitdiddle
The exits are in directions: south north west down up
;Value: ok
#+END_SRC
*** Computer Exercise 5: Wand to cause some trouble?
A spell is a type of mobile-thing which can be =USE= d to effect some magical
work. However, the only way to use a spell is to wave a wand around. Implement a
new type of object, a wand. Since a wand should be something that can be
transported from place to place, we should think about the class of objects from
which it should inherit. Wands have no interesting properties of their own,
other than a name and a location. A wand should automatically figure out its
caster by looking at its location, and not work unless a person is carrying it.
A wand needs to support two methods:
- =ZAP= :: takes a target to be zapped as its argument. It should pick a random
     spell from the caster's =THINGS=, print out a message (using the caster's
     =EMIT= method) about how the caster is waving the wand and saying the
     spell's =INCANT=, then ask the spell to =USE= with the caster and the
     target. If the caster isn't carrying any spells, it should print out a
     message about how the caster is waving the wand, but nothing is happening.

     Here is the flowchart of above description:
     #+BEGIN_SRC plantuml :file ../image/proj4_3.png :exports results
(*) --> "Take argument: target"
if "'HAS-A 'spell" then
    -->[not null] "pick-random"
    --> "(ask self 'EMIT ...)"
    --> "(ask _ 'USE self target)"
else
    -->[null] "(ask self 'EMIT ...)"
endif
     #+END_SRC

     #+RESULTS:
     [[file:../image/proj4_3.png]]

     And the code that implements given task:
     #+BEGIN_SRC scheme
,*** in wand class
      'ZAP
      (lambda (target)
        (let ((caster (ask self 'location)))
          (if (ask caster 'is-a 'person) ;works only if the caster is person
              (let ((spells (ask self 'HAS-A 'spell))
                    (wave (list (ask caster 'name)
                                "waves"
                                (ask self 'name)
                                "towards"
                                (ask target 'name))))
                (if (not (null? spells))
                    (let* ((spell (pick-random spells))
                           (incant (list "incanting"
                                         (ask spell 'INCANT))))
                      (ask caster 'EMIT
                           (append wave
                                   incant))
                      (ask spell 'USE caster target))
                    (ask caster 'EMIT
                         (append wave
                                 (list "but nothing happend"))))))))
     #+END_SRC
- =WAVE= :: takes no arguments. It picks a random target from the set of things
     at the caster's location, picks a random spell from the caster's =THINGS=,
     prints out a message (using the caster's =EMIT=) about how the caster is
     waving the wand and saying the spell's =INCANT=, then asks the spell to
     =USE= with the caster and the target. We should do this by employing the
     =ZAP= method. We should decide whether we want this to apply only to
     people, or to any type of thing. We should probably also ensure that we
     don't accidentally cast a spell on ourself.

     For the first decision, we choose to the latter one -- any type of thing
     (actually which is required by the following exercise); for the second, we
     can exploit the strategy of =PEOPLE-AROUND= method of =person= -- =delq= self.

     Here is the code that do the right things:
     #+BEGIN_SRC scheme
,*** in wand class
      'WAVE
      (lambda ()
        (let* ((caster (ask self 'location))
               (target (pick-random
                        (delq caster
                              (ask (ask caster 'location)
                                   'things)))))
          (if target
              (ask self 'ZAP target)
              (ask caster 'EMIT
                   (list (ask caster 'name)
                         "waved but there is nothing in the room")))))
     #+END_SRC


Here is the complete code:
#+BEGIN_SRC scheme
(define (wand self name location)
  (let ((mobile-part (mobile-thing self name location)))
    (make-handler
     'wand
     (make-methods
      'ZAP
      (lambda (target)
        (let ((caster (ask self 'location)))
          (if (ask caster 'is-a 'person) ;works only if the caster is person
              (let ((spells (ask caster 'HAS-A 'spell))
                    (wave (list (ask caster 'name)
                                "waves"
                                (ask self 'name)
                                "towards"
                                (ask target 'name))))
                (if (not (null? spells))
                    (let* ((spell (pick-random spells))
                           (incant (list "incanting"
                                         (ask spell 'INCANT))))
                      (ask caster 'EMIT
                           (append wave
                                   incant))
                      (ask spell 'USE caster target))
                    (ask caster 'EMIT
                         (append wave
                                 (list "but nothing happend"))))))))
      'WAVE
      (lambda ()
        (let ((caster (ask self 'location)))
          (if (ask caster 'is-a 'person)
              (let  ((target (pick-random
                              (delq caster
                                    (ask (ask caster 'location)
                                         'things)))))
                (if target
                    (ask self 'ZAP target)
                    (ask caster 'EMIT
                         (list (ask caster 'name)
                               "waved"
                               (ask self 'name)
                               "but there is nothing in the room")))))))
      )
     mobile-part)))
(define (create-wand name location)
  (create-instance wand name location))
#+END_SRC

Here is the test:
#+BEGIN_SRC scheme
;; first path
(ask (thing-named 'absolute-wand) 'wave)

At |34-301| vandimort waves absolute-wand towards lambda-man incanting habooic katarnum
At |34-301| lambda-man grows boils on their nose

(ask me 'look-around)

You are in eecs-ug-office
You are holding: boil-spell absolute-wand
There is no stuff in the room.
There are no other people around you.
The exits are in directions: east
;Value: ok

;; third path
(ask me 'look-around)

You are in eecs-hq
You are holding: slug-spell absolute-wand boil-spell
There is no stuff in the room.
There are no other people around you.
The exits are in directions: up west down
;Value: ok

(ask (car (ask me 'HAS-A 'wand)) 'wave)

At eecs-hq vandimort waved absolute-wand but there is nothing in the room
;Value: message-displayed

;; second path
(ask me 'look-around)

You are in stata-center
You are not holding anything.
There is no stuff in the room.
There are no other people around you.
The exits are in directions: down up south north west
;Value: ok

(create-wand 'my-wand me)

;Value: (instance #[compound-procedure 182 handler])

(ask (thing-named 'my-wand) 'wave)

At stata-center vandimort waves my-wand towards lambda-man but nothing happend
;Value: message-displayed

(create-wand 'test-wand (ask me 'location))

;Value: (instance #[compound-procedure 183 handler])

;; caster is not a person.
(ask (thing-named 'test-wand) 'wave)

;Unspecified return value
#+END_SRC

Our test is path-complete.
*** Computer Exercise 6: Spell out the options
Examine the =(instantiate-spells)= code in =setup.scm=. This should help we
understand the kinds of properties that spells possess.

Note that the two spells provided to us seem to implicitly assume that the
target is a person (unless other things have noses and mouths!) yet the code we
wrote in the previous exercise could easily have a =WAVE= action apply to a
non-person object or thing.
**** Modify the code in =setup.scm= so that the two spells provided only work on
targets that are people.

Here is the change:
#+BEGIN_SRC scheme
,*** in instantiate-spells
    (create-spell
     'boil-spell
     chamber
     "habooic katarnum"
     (lambda (caster target)
       (if (ask target 'is-a 'person)
           (ask target 'EMIT (list (ask target 'NAME) "grows boils on their nose")))))
    (create-spell
     'slug-spell
     chamber
     "dagnabbit ekaterin"
     (lambda (caster target)
       (cond ((ask target 'is-a 'person)
              (ask target 'EMIT (list "A slug comes out of" (ask target 'NAME) "'s mouth."))
              (create-mobile-thing 'slug (ask target 'LOCATION))))))
#+END_SRC

Here is the test:
#+BEGIN_SRC scheme
(ask me 'look-around)

You are in building-13
You are holding: boil-spell vandi-wand
You see stuff in the room: boil-spell
There are no other people around you.
The exits are in directions: north south
;Value: ok

(ask #@38 'wave)

At building-13 vandimort waves vandi-wand towards boil-spell incanting habooic katarnum
;Unspecified return value
...

(ask me 'look-around)

You are in eecs-hq
You are holding: boil-spell vandi-wand
There is no stuff in the room.
You see other people: lambda-man
The exits are in directions: up west down
;Value: ok

(ask #@38 'wave)

At eecs-hq vandimort waves vandi-wand towards lambda-man incanting habooic katarnum
At eecs-hq lambda-man grows boils on their nose
;Value: message-displayed
#+END_SRC

**** Now, create a new spell, called =WIND-OF-DOOM=. This spell if applied to a
person should cause, at random, up to 2 units of suffering. If applied to any
other object, it should destroy the target.

That is, the question statement want we to dispatch on type in OOP!

Here is the code:
#+BEGIN_SRC scheme
,*** in the instantiate-spells
    (create-spell
     'WIND-OF-DOOM
     chamber
     "atstrock do da wanda"
     (lambda (caster target)
       (cond ((ask target 'is-a 'person)
              (ask target 'EMIT (list "Wind of doom swoon" (ask target 'NAME)))
              (ask target 'SUFFER (random-number 2) caster))
             (else
              (ask target 'EMIT (list "Wind of doom swoon" (ask target 'NAME)))
              (ask target 'DESTROY)))))
#+END_SRC

And test:
#+BEGIN_SRC scheme
(clone-spell (car (ask chamber-of-stata 'things)) me)

;Value: (instance #[compound-procedure 46 handler])

(ask (car (ask me 'has-a 'wand)) 'wave)

At |6001-lab| jang waves jangs-wand towards lambda-man incanting atstrock do da wanda
At |6001-lab| Wind of doom swoon lambda-man
At |6001-lab| lambda-man says -- Ouch! 2 hits is more than I want!
;Value: 1
#+END_SRC

**** Finally, create some completely new spell of your design and add it to the world.
Here, we attempt to make two kind of spells that possess completely opposite
characters.

- Patronus spell :: kills (destroys) the given target. It is going to be used to
     implementing Dementor class, which we are going to use in Exercise 11.
     #+BEGIN_SRC scheme
,*** in instantiate-spell
    (create-spell
     'PATRONUS
     "Expecto Patronum"
     (lambda (caster target)
       (cond ((ask target 'is-a 'person)
              (ask target 'EMIT (list "patronus got" (ask target 'NAME)))
              (ask target 'DIE caster))
             (else
              (ask target 'EMIT (list "patronus got" (ask target 'NAME)))
              (ask target 'DESTROY)))))
     #+END_SRC
- Episkey spell :: heals minor injuries. To implement this spell, we need to
     modify =person= class to support healing action as follows:
     #+BEGIN_SRC scheme
,*** in person class
      'RECOVER
      (lambda (healing benefactor)
        (ask self 'SAY (list "Wao!" healing "is what I exactly wanted! Thanks"
                             (ask benefactor 'name)))
        (set! health (+ health healing))
        health)
     #+END_SRC

     Then the spell:
     #+BEGIN_SRC scheme
,*** in instantiate-spell
    (create-spell
     'EPISKEY
     "Episkey"
     (lambda (caster target)
       (cond ((ask target 'is-a 'person)
              (ask target 'EMIT (list "episkey covered" (ask target 'NAME)))
              (ask target 'RECOVER (random-number 2) caster))
             )))
     #+END_SRC


Let's test those spells:
#+BEGIN_SRC scheme
(ask (car (ask me 'has-a 'wand)) 'wave)

At great-court jang waves jangs-wand towards ben-bitdiddle incanting Expecto Patronum
At great-court patronus got ben-bitdiddle
At great-court ben-bitdiddle says -- SHREEEEK!  I, uh, suddenly feel very faint...
An earth-shattering, soul-piercing scream is heard...
;Value: done

(ask (car (ask me 'has-a 'wand)) 'wave)

At building-13 jang waves jangs-wand towards lambda-man incanting Episkey
At building-13 episkey covered lambda-man
At building-13 lambda-man says -- Wao! 1 is what I exactly wanted! Thanks jang

(ask me 'look-around)

You are in building-13
You are holding: ring-of-obfuscation patronus episkey jangs-wand
You see stuff in the room: slug-spell
You see other people: lambda-man
The exits are in directions: north south
;Value: ok
#+END_SRC
*** Computer Exercise 7: ZAPpity do dah!
The halls of Stata are filled with enterprising WIT students who try out their
spells on anybody and everybody. Implement a new type of class, a wit-student,
which acts like an autonomous-person, but also attempts to ZAP people each tick
of the clock. Every tick, the student should try to find a wand in its things,
then find another person in the room, and if both are found, =ZAP= the wand at
the person. If the student has a wand, but there are no people present, then the
student should =WAVE= the wand at a random target. You may wish to look at the
=INSTALL= code for autonomous-person to see how to add clock callbacks. Remember
that the students should stop zapping or waving their wands when they're dead.

In order to assist in the wand-zapping, each student should begin their life
carrying a wand. This wand should end up in the usual =THINGS= list so that it
can be stolen, dropped, etc.

Alter =setup.scm= to populate the world with students instead of
autonomous-persons. Turn in your code for =wit-student= and show examples of the
working.
**** Answer
Let we visualize what the above describe:
#+BEGIN_SRC plantuml :exports results :file ../image/proj4_4.png
(*) --> "wit-student's callback method"
if "(ask self 'has-a 'wand)" then
    -->[not null] "(pick-random _)"

    if "(ask self 'people-around)" then
        -->[not null] "(pick-random __)"
        --> "(ask wand 'zap person)"
    else
        -->[null] "(ask wand 'wave)"
    endif
endif
#+END_SRC

#+RESULTS:
[[file:../image/proj4_4.png]]

Then the resulting class:
#+BEGIN_SRC scheme
(define (create-wit-student name birthplace speed miserly)
  (create-instance wit-student name birthplace speed miserly))

(define (wit-student self name birthplace speed miserly)
  (let ((auto-part (autonomous-person self name birthplace speed miserly)))
    (make-handler
     'wit-student
     (make-methods
      'INSTALL
      (lambda ()
        (ask auto-part 'INSTALL)
        ;; register callback method
        (ask clock 'ADD-CALLBACK
             (create-clock-callback 'zappity-do-dah self
                                    'ZAPPITY-DO-DAH))
        ;; born with one's own wand
        (create-wand (symbol-append name '-wand) self)
        'done)
      'ZAPPITY-DO-DAH
      (lambda ()
        (let ((wands (ask self 'has-a 'wand)))
          (if (not (null? wands))       ;has wand?
              (let ((people (ask self 'PEOPLE-AROUND))
                    (wand (pick-random wands))) ;pick wand randomly
                (if (not (null? people))
                    (let ((person (pick-random people)))
                      (ask wand 'ZAP person))
                    (ask wand 'WAVE)))
              )))                       ;do not have wand -- ignore the method call
      'DIE
      (lambda (perp)
        (ask clock 'REMOVE-CALLBACK self 'zappity-do-dah)
        (ask auto-part 'DIE perp)))
     auto-part)))
#+END_SRC

And change the =setup.scm=:
#+BEGIN_SRC scheme
,*** in populate-players
...
  (let* students map lambda (name)
                          create-wit-student name
...
                          )
...
#+END_SRC

Let's test this:
#+BEGIN_SRC scheme
(run-clock 3)

--- the-clock Tick 0 ---
ben-bitdiddle moves from bexley to student-center
At student-center ben-bitdiddle says -- I take episkey from student-center
At student-center ben-bitdiddle waved ben-bitdiddle-wand but there is nothing in the room
alyssa-hacker moves from bexley to baker
At baker alyssa-hacker says -- Hi grendel
At baker alyssa-hacker says -- I take patronus from baker
At baker alyssa-hacker waves alyssa-hacker-wand towards grendel incanting Expecto Patronum
At baker patronus got grendel
At baker grendel says -- SHREEEEK!  I, uh, suddenly feel very faint...
An earth-shattering, soul-piercing scream is heard...
course-6-frosh moves from great-court to legal-seafood
course-6-frosh moves from legal-seafood to edgerton-hall
At edgerton-hall course-6-frosh says -- I take ring-of-obfuscation from edgerton-hall
At edgerton-hall course-6-frosh waves course-6-frosh-wand towards boil-spell but nothing happend
lambda-man moves from barker-library to |10-250|
lambda-man moves from |10-250| to barker-library
At barker-library lambda-man waves lambda-man-wand towards engineering-book but nothing happend
...
#+END_SRC


#  LocalWords:  dah
*** Computer Exercise 8: I profess, these students are incorrigible!
In addition to students, WIT employs a number of professors whose job is to
teach students spells! Implement a wit-professor that acts like a wit-student,
except each tick of the clock it also looks around for a student to whom he or
she can teach a spell. Teaching a spell to a student involves cloning a spell
out of the Chamber of Stata and into the student's inventory.

**** Answer
To implement given task, we need to decide whether we teach a spell from
wit-professor to wit-professer not only to wit-student. In real world, we don't
"teach" professor at all; so let that apply to our world also. To do such a
thing, first, we need to modify the wit-student class and other as follows
#+BEGIN_SRC plantuml :exports results :file ../image/proj4_5.png
class wit-person {
    name
    birthplace
    speed
    miserly
    __
    INSTALL
    ZAPPITY-DO-DAH
    DIE
}

class wit-student {
    name
    birthplace
    speed
    miserly
}

class wit-professor {
    name
    birthplace
    speed
    miserly
    __
    INSTALL
    TEACH
    DIE
}

"wit-person" <|-- "wit-student"
"wit-person" <|-- "wit-professor"
#+END_SRC

#+RESULTS:
[[file:../image/proj4_5.png]]

Then the code:
#+BEGIN_SRC scheme
(define (create-wit-professor name birthplace speed miserly)
  (create-instance wit-professor name birthplace speed miserly))
(define (wit-professor name birthplace speed miserly)
  (let ((wit-part (wit-person name birthplace speed miserly)))
    (make-handler
     'wit-professor
     (make-methods
      'INSTALL
      (lambda ()
        (ask wit-part 'INSTALL)
        ;; register callback method
        (ask clock 'ADD-CALLBACK
             (create-clock-callback 'teach self
                                    'TEACH)))
      'TEACH
      (lambda ()
        (let ((students (find-all (ask self 'location) 'wit-student)))
          (if (not (null? students))
              (let ((student (pick-random students))
                    (spell (pick-random (ask chamber-of-stata 'THINGS))))
                (ask self 'say
                     (list "Hey,"
                           (ask student 'name)
                           "come here,"
                           "you are so lucky."
                           "I'll teach you"
                           (ask spell 'name)))
                (ask student 'EMIT
                     (list (ask student 'name)
                           "learned"
                           (ask spell 'name)
                           "from"
                           "prof."
                           (ask self 'name)))
                (clone-spell spell student)))))

      'DIE
      (lambda (perp)
        (ask clock 'REMOVE-CALLBACK self 'teach)
        (ask auto-part 'DIE perp))
      ))))
#+END_SRC

Test:
#+BEGIN_SRC scheme
(run-clock 1)

--- the-clock Tick 0 ---
...
At |6001-lab| susan-hockfield says -- Hey, alyssa-hacker come here, you are so lucky. I'll teach you slug-spell
At |6001-lab| alyssa-hacker learned slug-spell from prof. susan-hockfield
...
;Value: done
#+END_SRC
*** Computer Exercise 9: Oh yeah, well take that!
To make things a fair fight, we want to add something that can counteract
spells. So create a new type of object, called a counterspell. A counterspell
should have the property that if a character attempts to cast a specific spell
on a target, and the target possesses the appropriate counterspell, then the
spell itself does not take effect. Thus, in addition to creating counter spells,
you will want to modify your spells to obey this new behavior.

**** Answer
To do this, let we decide to make all the spells have its counterspell; =spell=
class should support this general scheme making counterspell as its state
variable; or we could implement such effect using the analogy with
=ring-of-obfuscation=:

- =counterspell= class:
  #+BEGIN_SRC scheme
(define (create-counterspell name location)
  (create-instance counterspell name location))
(define (counterspell self name location)
  (let ((mobile-part (mobile-thing self name location)))
    (make-handler
     'counterspell
     (make-methods)
     mobile-part)))
  #+END_SRC
- change to support such feature within =spell=:
  #+BEGIN_SRC scheme
,*** in the spell class
      'USE
      (lambda (caster target)
        (if (not (null? (filter (lambda (c) (eq? (ask self 'name)
                                                 (ask c 'name)))
                                (ask target 'has-a 'counterspell))))
            ;; target has a counterspell of this spell
            (let ((counterincant
                   (list (ask target 'name)
                         "incants"
                         (list->string (reverse (string->list (ask self 'incant)))))))
              (ask target 'emit counterincant))
            ;; target does not have counterspell to this
            (action caster target)))
  #+END_SRC
  Here we chose the user of counterspell to incant "counter-incant", which is
  the reverse of =incant= of targeting spell.
- populate counterspell within =populate-spells=:
  #+BEGIN_SRC scheme
(define (populate-spells rooms)
  (for-each (lambda (room)
              (let ((spell
                     (pick-random (ask chamber-of-stata 'THINGS))))
                (clone-spell spell room)
                ;; instantiate counterspells of each
                (create-counterspell (ask spell 'name) room)))
            rooms))
  #+END_SRC


And the test:
#+BEGIN_SRC scheme
(run-clock 1)

--- the-clock Tick 0 ---
ben-bitdiddle moves from |34-301| to stata-center
...
course-6-frosh moves from lobby-10 to grendels-den
At grendels-den course-6-frosh says -- I take episkey from grendels-den
At grendels-den course-6-frosh waves course-6-frosh-wand towards episkey incanting Episkey
;No method for has-a in episkey
;To continue, call RESTART with an option number:
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC

Failed! It is due to the fact that we haven't checked the =target= has a =HAS-A=
method; we can fix the bug as follows:
#+BEGIN_SRC scheme
,*** in spell class
      'USE
      (lambda (caster target)
        if and (ask target 'is-a 'person)
                 not null? filter (lambda (c) (eq? (ask self 'name)
                                                      (ask c 'name)))
...
                 )
#+END_SRC

Then re-test:
#+BEGIN_SRC scheme
(run-clock 1)
...
At |34-301| lambda-man waves lambda-man-wand towards alyssa-hacker incanting habooic katarnum
At |34-301| alyssa-hacker incants munratak cioobah
...
#+END_SRC
*** Computer Exercise 10: See this scar in the shape of a Lambda?
Lastly, it's time to implement Hairy Cdr himself. Hairy is a WIT student, but
more importantly, he's the "chosen one". Thus he cannot die until the series is
finished, which at the current rate will be long after you graduate (but at the
current time, it ended!). Any time Hairy is about to die, his scar flares
brightly and the person attempting to kill him dies instead (like Lord
Vandimort). More specifically, when a =chosen-one= is asked to =SUFFER= enough
to kill them, it should print out an appropriate message and then kill the
perpetrator, leaving the =chosen-one= unharmed.

Note that we are asking you to have a chosen one override the =SUFFER= method,
rather than the =DIE= method. Why? What could go wrong if a chosen one were to
implement this behavior using the =DIE= method instead?

If we chose the latter way, Hairy's health could be less or equals to zero and
at the same time he doesn't die, which is apparently contradict in real world!

**** Answer
So the class diagram should look like
#+BEGIN_SRC plantuml :exports results :file ../image/proj4_6.png
class wit-student {
    name
    birthplace
    speed
    miserly
    __
}

class chosen-one {
    name
    birthplace
    speed
    miserly
    __
    SUFFER
    DIE
}
"wit-student" <|-- "chosen-one"
#+END_SRC

#+RESULTS:
[[file:../image/proj4_6.png]]

We should override =SUFFER= method of =person= to
1. check the resulting health of self;
2. if it is less than or equals to zero, kill the perpetrator.
3. else call the super-part's =SUFFER= and =DIE=.


Here is the result:
#+BEGIN_SRC scheme
(define (create-chosen-one name birthplace speed miserly)
  (create-instance chosen-one name birthplace speed miserly))
(define (chosen-one self name birthplace speed miserly)
  (define (scar-of-lambda perp)
    (ask self 'EMIT
         (list "The scar of the shape of a Lambda at the forehead of"
               (ask self 'name)
               "flares brightly"))
    (ask perp 'DIE self))
  (let ((student-part (wit-student self name birthplace speed miserly)))
    (make-handler
     'chosen-one
     (make-methods
      'SUFFER
      (lambda (hits perp)
        (let ((after-health (- (ask self 'health) hits)))
          (if (<= after-health 0)
              (scar-of-lambda perp)
              (ask student-part 'SUFFER hits perp))))
      'DIE
      (lambda (perp)
        (if (> (ask self 'health) 0)
            (scar-of-lambda perp)
            (ask student-part 'DIE perp)))
      )
     student-part)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
(setup 'jang)

;Value: ready

(create-chosen-one 'Hairy-Cdr (ask me 'location) 3 3)

;Value: (instance #[compound-procedure 61 handler])

(ask #@61 'SUFFER 5 me)

At eecs-ug-office The scar of the shape of a Lambda at the forehead of hairy-cdr flares brightly
At eecs-ug-office jang says -- I am slain!
An earth-shattering, soul-piercing scream is heard...
;Value: done

(ask #@61 'SUFFER 2 me)

At eecs-ug-office hairy-cdr says -- Ouch! 2 hits is more than I want!
;Value: 1
#+END_SRC
*** Computer Exercise 11: Our turn

Now that we have had an opportunity to play with their "world" of characters,
places, and things, they want us to extend this world in some substantial way.
The last part of this project gives us an opportunity to do this. As we haven't
had much freedom to design our own code up until now, this exercise gives us the
opportunity to demonstrate our knowledge of design principles.
*NOTE: this exercise is worth significantly more points than the others; give it
the time it deserves!*

This is our opportunity to have fun with the game! There's only one hard
requirement: we must add at least one new class to the system. Other than that,
we are free to take the simulation in any direction that interests and excites
us. We don't have to stick with the Hairy Cdr theme if we don't want to. Here
are a few ideas that they've come up with for extensions, but we certainly
aren't limited to these:

- Dementors :: They're like trolls, but immune to suffering. They can only be
     killed with the patronus spell.
- Moving Exits :: Exits that change their destination over time.
- Brooms :: If the person is carrying a broom they can use "flying" exits to
     move around campus quickly.
- House Points :: Each student belongs to a house. Doing certain activities adds
     points, doing others subtracts points.
- Spell Points :: Every person has an amount of spell points. Casting spells
     uses up spell points, which return slowly over time Every person has an
     amount of spell points. Casting spells uses up spell points, which return
     slowly over time.


Remember to select an extension that we have an expectation of finishing. If
we're going to attempt something ambitious, remember to have a fallback plan
that meets the objectives for the exercise!

**** Stage One: Plan

Here, we want to plan out the design for some extensions to our world. We
required to write a brief description of our plan.

We want to design some new elements to our world. The first thing we want to do
is design a new class of objects to incorporate into the world. To do this, we
should plan each of the following elements:

- Object class :: First, define the new class we are going to build. What kind
     of object is it? What are the general behaviors that we want the class to
     capture?
- Class hierarchy :: How does our new class relate to the class hierarchy of the
     existing world? Is it a subclass of an existing class? Is it a superclass
     of one or more existing classes?
- Class state information :: What internal state information does each instance
     of the class need to know?
- Class methods :: What are the methods of the new class? What methods will it
     inherit from other classes? What methods will shadow methods of other classes?
- Demonstration plan :: How will we demonstrate the behavior of instances of our
     new class within the existing simulation world?


Let we demonstrate above elements implementing =Dementor= class.
- Object class:
  As described above, it is troll-like object; that is, it eat people at every
  tick but it is immune to suffer.
- Class hierarchy:
  As it is troll-like object, it is reasonable to let this be the subclass of
  troll overriding =SUFFER= method.
- Class state information:
  It only override the =SUFFER= method of =troll=, it should have same state
  information as =troll=: name, birthplace, speed, hunger.
- Class method:
  As we noted above, the only method we are going to implement is =SUFFER=
  method (actually we override that method of =person=).

  By the dialogue so far, we can visualize our class diagram:
  #+BEGIN_SRC plantuml :exports results :file ../image/proj4_7.png
class troll {
    name
    birthplace
    speed
    hunger
    __
    INSTALL
    EAT-PEOPLE
    DIE
}

class dementor {
    name
    birthplace
    speed
    hunger
    __
    SUFFER
}

troll <|-- dementor
  #+END_SRC

  #+RESULTS:
  [[file:../image/proj4_7.png]]
- Demonstration plan:
  We going to populate dementors, which is analogous to trolls; but only way to
  kill dementors is using the method that make the target die directly --
  without using suffering. The only method that can do this is using patronus
  spell for now as we required.

  The above description is somewhat abstract; we are going to simulate what we
  want by using test cases:
  #+BEGIN_SRC scheme
(define dementor (create-dementor 'dementor (ask me 'location) 3 3))

(ask dementor 'suffer 5 me)

At eecs-ug-office dementor says -- ?

(create-wand 'wand me)
(clone-spell (car (filter (lambda (spell) (eq? (ask spell 'name) 'patronus))
                          (ask chamber-of-stata 'things)))
             me)
(ask (car (ask me 'has-a 'wand)) 'zap dementor)
...
An earth-shattering, soul-piercing scream is heard...
  #+END_SRC

**** Stage Two: Implementation
Attempt to follow our plan. Remember to test our code in a number of ways to
ensure that it does what we intended it to do.

- Class of dementor:
  #+BEGIN_SRC scheme
(define (create-dementor name birthplace speed hunger)
  (create-instance dementor name birthplace speed hunger))

(define (dementor self name birthplace speed hunger)
  (let ((troll-part (troll self name birthplace speed hunger)))
    (make-handler
     'dementor
     (make-methods
      'SUFFER                           ;override method!
      (lambda (hits perp)
        (ask self 'say (list "?")))
      )
     troll-part)))
  #+END_SRC
- Support to the world:
  #+BEGIN_SRC scheme
,*** within populate-players
(dementors (map (lambda (name)
                        (create-dementor name
                                      (pick-random rooms)
                                      (random-number 3)
                                      (random-number 3)))
                      '(dementor1 dementor2)))
  #+END_SRC
- Then test:
  #+BEGIN_SRC scheme
(setup 'jang)

;Value: ready

(run-clock 3)

--- the-clock Tick 0 ---
...
--- the-clock Tick 1 ---
...
--- the-clock Tick 2 ---
...
At lobby-10 susan-hockfield waves susan-hockfield-wand towards dementor2 incanting atstrock do da wanda
At lobby-10 Wind of doom swoon dementor2
At lobby-10 dementor2 says -- ?
...
;Value: done

(create-wand 'my-wand me)

;Value: (instance #[compound-procedure 39 handler])

(clone-spell (car (filter (lambda (spell) (eq? (ask spell 'name) 'patronus))
                          (ask chamber-of-stata 'things)))
             me)

;Value: (instance #[compound-procedure 41 handler])

(define dementor (car (filter (lambda (p) (ask p 'is-a 'dementor)) (all-people))))

;Value: dementor

(ask (car (ask me 'has-a 'wand)) 'zap dementor)

At eecs-hq jang waves my-wand towards dementor2 incanting Expecto Patronum
At lobby-10 patronus got dementor2
At lobby-10 dementor2 says -- SHREEEEK!  I, uh, suddenly feel very faint...
An earth-shattering, soul-piercing scream is heard...
;Value: done
  #+END_SRC


Done!
* Footnotes

[fn:5] We can ask only the objects -- instances -- to request the method;
for the handler we should use specialized method called
=find-method-from-handler-list=, which should not be called by user -- it only
used internally.

[fn:4] It is due to the existence of the cycle within the graph.

[fn:3] To implement such ADT, we need to use the message passing style which we
supposed to have not learned yet; also we supposed to not know exactly what is
/object/, which referenced in the discourse, that is core entity composing the
message passing programming.


[fn:2] Conceptually graph become a procedure that takes nodes with the edges,
which describe the connectivity between nodes, then connect the nodes according
to given edges; And it would return root node. Its purpose is side-effect --
connecting the nodes.


[fn:1] In fact, when I worked in software company, where develop program using
machine learning, I've implemented server side application that has the features
of cloud server; in there, I've dealt with HTTP (REST API) to do the task for
the purpose of training.
