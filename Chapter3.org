#+TITLE: Chapter 3 Modularity, Objects, and State
* Assignment and Local State
We now introduce "state" in our programming language at length. By introduction
this concept, we get to model real world system more naturally and modularly
combining with message passing programming.
** Local State Variables
To introduce the local state variable, we need to special expression that can
change the state of variable. More specifically, that expression has to update
value of the state variable. For this, scheme has special syntax called =(set!
<name> <new-value>)=.
*** Exercise 3.1
Using the general scheme that combines local variable with =set!= expression, we
can easily implement what we asked:
#+BEGIN_SRC scheme
(define (make-accumulator sum)
  (lambda (num)
    (set! sum (+ sum num))
    sum))
#+END_SRC
*** Exercise 3.2
Let we first specify what the =make-monitored= should satisfy:
- It should use the message passing programming to dispatch on input to
  implement the special symbol input.
- It should have local variable, say count, to count the number of calls of its
  procedure argument =f=; it should use =set!= to change the value of its
  internal state variable.


Then we can encode that specification directly:
#+BEGIN_SRC scheme
(define (make-monitored f)
  (let ((count 0))
    (define (dispatch m)
      (cond ((eq? m 'how-many-calls?) count)
            ((eq? m 'reset-count) (set! count 0))
            (else
             (set! count (1+ count))
             (f m))))))
#+END_SRC
*** Exercise 3.3
We can do what we should do by slightly amending the procedure defined in text:
#+BEGIN_SRC scheme
(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pd m)
    (if (eq? pd password)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else (error "Unknown request -- MAKE-ACCOUNT"
                           m)))
        "Incorrect password")))
#+END_SRC

Unfortunately this code doesn't pass the test case =((acc 'some-other-password
'deposit) 50)=, which returns
#+BEGIN_SRC scheme
;The object "Incorrect password" is not applicable.
;To continue, call RESTART with an option number:
; (RESTART 2) => Specify a procedure to use in its place.
; (RESTART 1) => Return to read-eval-print level 1.
#+END_SRC
not what expected:
#+BEGIN_SRC scheme
"Incorrect password"
#+END_SRC

We can fix this by using type analysis: we should return procedure not the
primitive data:
#+BEGIN_SRC scheme
(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pd m)
    (if (eq? pd password)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              (else (error "Unknown request -- MAKE-ACCOUNT"
                           m)))
        (lambda (x) "Incorrect password")))
  dispatch)
#+END_SRC

Then it pass all the test specified in text book.
*** Exercise 3.4
This problem can be solved conjunction with the two previous exercises: 3.2 with 3.3.

To implement what we requested, first let we code the test cases, which encodes
all the specifications it should satisfy:
#+BEGIN_SRC scheme
;; Test code
;;; consequetive call case
(define acc (make-account 100 'secret-password))
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"call-the-cops"
;;; reset count
((acc 'secret-password 'withdraw) 40)
60
;;; interposed case
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'secret-password 'withdraw) 40)
20
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"Incorrect password"
((acc 'some-other-password 'deposit) 50)
"call-the-cops"
#+END_SRC

Then modify the code of exercise 3.3:
#+BEGIN_SRC scheme
(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((n-incorrect 0))
    (define (dispatch pd m)
      (if (eq? pd password)
          (begin
            (set! n-incorrect 0)        ;reset the counter
            (cond ((eq? m 'withdraw) withdraw)
                  ((eq? m 'deposit) deposit)
                  (else (error "Unknown request -- MAKE-ACCOUNT"
                               m))))
          (lambda (x)
            (set! n-incorrect (1+ n-incorrect))
            (if (>= n-incorrect 7)
                "call-the-cops"
                "Incorrect password"))))
    dispatch))
#+END_SRC

It passes all the test case.
** The Benefits of Introducing Assignment
In the text book, it explane the benefits of introducing assignment expression
in our language taking Monte Carlo test as example. Without using assignment, we
should handle explicitly the state of each experiment that use random number;
it results into leaking the guts of state over the most higher level of
language: Monte Carlo test. No more general Monte Carlo test, only the specific
instance of that kind.
*** Exercise 3.5
We can implement this exercise directly or we can do using what we learned so
far, data abstraction:
#+BEGIN_SRC scheme
;; top level
(define (estimate-integral P rect trials)
  (* (rect 'area)
     (monte-carlo trials
                  (lambda () (P (random-in-rect rect))))))
;; dependency
(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))
#+END_SRC
Here we captured the upper and lower bounds as rectangle; also we exploit that
structure in generating random point in that rectangle. In this way, our program
start to self-document what we are trying to do. With this, we can test this
unit by
#+BEGIN_SRC scheme
;;; test estimate-integral
(define p1 (make-point -1 -1))
(define p2 (make-point 1 1))
(define r (make-rect p1 p2))
(define (P pt) (<= (+ (square (x-coor pt))
                      (square (y-coor pt)))
                   1))
(estimate-integral P r 100)
;; it should converge to 3.141592...
#+END_SRC
It's true that we can not test this code until implement the lower level
language but it is important to note that we can write the unit test.

Then we can implement the other levels of language:
#+BEGIN_SRC scheme
;; middle level
(define (random-in-rect rect)
  (let ((points (list (bottom-left rect) (top-right rect))))
    (make-point (random-in-range
                 (map exact->inexact (map x-coor points)))
                (random-in-range
                 (map exact->inexact (map y-coor points))))))
;; dependency
(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (random range))))

;;; test random-in-rect
(define p1 (make-point 3 4))
(define p2 (make-point 8 7))
(define r (make-rect p1 p2))
(random-in-rect r)
;; some float point in rect
#+END_SRC

... and so on
#+BEGIN_SRC scheme
;; low-middle level
(define (make-rect bl tr)
  (define area
    (* (- (x-coor (tr) (bl)))
       (- (y-coor (tr) (bl)))))
  (define (dispatch m)
    (cond ((eq? m 'top-right) tr)
          ((eq? m 'bottom-left) bl)
          ((eq? m 'area) area)
          (else (error "Undefined request -- MAKE-RECT" m))))
  dispatch)

(define (top-right rect) (rect 'top-right))
(define (bottom-left rect) (rect 'bottom-left))

;;; test rect
(define p1 (make-point 3 4))
(define p2 (make-point 8 7))
(define r (make-rect p1 p2))
(r 'area)
;; 15
(top-right rect)
;; (8 . 7)
(bottom-left rect)
;; (3 . 4)
(rect 'unknown-message)
;; Undefined request -- MAKE-RECT unknown-message

;; lowest level
(define (make-point x y)
  (cons x y))
(define (x-coor pt) (car pt))
(define (y-coor pt) (cdr pt))

;;; test point
(define a (make-point 5 3))
(x-coor a)
;; 5
(y-coor a)
;; 3
#+END_SRC

Then we start the unit tests from the bottom. We failed in the =rect= level:
#+BEGIN_SRC scheme
(define r (make-rect p1 p2))
;The object (3 . 4) is not applicable.
#+END_SRC

As soon as we inspect the code of =make-rect=, we realize what the problem was.
We can fix this easily:
#+BEGIN_SRC scheme
,*** in make-rect
  (define area
    (* (- (x-coor tr) (x-coor bl))
       (- (y-coor tr) (y-coor bl))))
#+END_SRC

Run our test again: this time, we got by
#+BEGIN_SRC scheme
(top-right rect)
;Unbound variable: rect
#+END_SRC

It was due to the test code itself: we defined =r= to be rectangle but we called
=rect=. Fix and run. Then again we caught by =random-in-rect=:
#+BEGIN_SRC scheme
1 (user) => (random-in-rect r)
;The procedure #[compound-procedure 38 random-in-range] has been called with 1 argument; it requires exactly 2 arguments.
#+END_SRC

We should have used =apply= in the =random-in-rect= procedure to apply
=random-in-range= to argument list; after amending, it produce:
#+BEGIN_SRC scheme
1 (user) => (random-in-rect r)
;Value: (5.225704578484133 . 5.665006074331469)
#+END_SRC

Looks fine.

Then we move up the top level. It produce:
#+BEGIN_SRC scheme
1 (user) => (estimate-integral P r 100)
;Value: 76/25
#+END_SRC
If we convert that value to inexact number:
#+BEGIN_SRC scheme
1 (user) => (exact->inexact 76/25)
;Value: 3.04
#+END_SRC

To produce the floating-point number at first, we need to give the x and y
coordinates with floating-point number. Let's do more trials:
#+BEGIN_SRC scheme
1 (user) => (estimate-integral P r 1000)
;Value: 2.98
1 (user) => (estimate-integral P r 10000)
;Value: 3.158
1 (user) => (estimate-integral P r 100000)
;Value: 3.14068
#+END_SRC

It really slowly converge to 3.141592..., \pi.
*** Exercise 3.6
We can design what we requested using the message-passing programming strategy
as we did in =make-rect=. First let we code the test:
#+BEGIN_SRC scheme
;;; test rend
(rand 'generate)
<some-random-number>
((rand 'reset) 5)
(rand 'generate)
<specific-random-number>
(rand 'generate)
<some-other-random-number>
((rand 'reset) 5)
(rand 'generate)
<specific-random-number>
#+END_SRC

Then implement:
#+BEGIN_SRC scheme
(define rand
  (let ((x random-init))
    (define (dispatch m)
      (cond ((eq? m 'generate)
             (set! x (rand-update x))
             x)
            ((eq? m 'reset)
             (lambda (new-x)
               (set! x new-x)))
            (else
             error "Unknown request -- RAND" m)))))
#+END_SRC

As soon as I run the test:
#+BEGIN_SRC scheme
1 (user) => (rand 'generate)
;Unassigned variable: rand
#+END_SRC

I should have to return =dispatch= as its return value.

Let we run test again:
#+BEGIN_SRC scheme
1 (user) => (rand 'generate)
;Value: 88
1 (user) => ((rand 'reset) 5)
;Value: 88
1 (user) => (rand 'generate)
;Value: 34
1 (user) => (rand 'generate)
;Value: 55
1 (user) => ((rand 'reset) 5)
;Value: 55
1 (user) => (rand 'generate)
;Value: 34
#+END_SRC

It works as expected.
** The Costs of Introducing Assignment
Allowing assignment expression in our language, introduce more profound
complication namely, what is the object and what is the sameness. It is more
alike philosophical concept. As noted in the text, to identify the sameness we
experiment by changing one object and observe the other; however in turns, to
define the "change" of one object we should first define "sameness." As
consequence, we need /a priori/ notion of sameness to identify whether the
objects that we are compare with is same.
*** Exercise 3.7
Let we first code the test:
#+BEGIN_SRC scheme
;;; test make-joint
(define peter-acc (make-account 100 'open-sesame))
(define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))
((paul-acc 'rosebud 'withdraw) 50)
;; 50
((peter-acc 'open-sesame 'deposit) 30)
;; 80
(define opaque (make-joint paul-acc 'open-sesame 'this-should-not-work?))
#+END_SRC
The last line is undefined because our specification does not regulate this
ambiguity. This looseness leads us to choose the implementation detail from
several possibilities:
- Let the last line of the test be valid :: This would imply to joint account,
     all we need to do is add new password to password list and then make change
     in =make-account= to check whether the password is correct use password
     list instead single password.
- Let the last line of the test be invalid :: This means that only the balance
     variable should be shared between the joint accounts, which also indicates
     that
     #+BEGIN_SRC scheme
((peter-acc 'rosebug 'deposit) 30)
     #+END_SRC
     should not work.


Let we explore the two possibilities by implementing both version.

- First version:
  #+BEGIN_SRC scheme
(define (make-account1 balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((n-incorrect 0)
        (pw-list (list password)))
    (define (dispatch pd m)
      (if (mem? pd pw-list)
          (begin
            (set! n-incorrect 0)        ;reset the counter
            (cond ((eq? m 'withdraw) withdraw)
                  ((eq? m 'deposit) deposit)
                  ((eq? m 'joint) (lambda (new-pw)
                                    (set! pw-list (cons new-pw pw-list))
                                    dispatch))
                  (else (error "Unknown request -- MAKE-ACCOUNT1"
                               m))))
          (lambda (x)
            (set! n-incorrect (1+ n-incorrect))
            (if (>= n-incorrect 7)
                "call-the-cops"
                "Incorrect password"))))
    dispatch))

(define (make-joint acc old-pw new-pw)
  ((acc old-pw 'joint) new-pw))

;; general helper function
(define (mem? el S)
  (if (null? S) false
      (or (eq? el (car S))
          (mem? el (cdr S)))))
  #+END_SRC

  Then let's test:
  #+BEGIN_SRC scheme
1 (user) => (define peter-acc (make-account1 100 'open-sesame))

;Value: peter-acc

1 (user) => (define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))

;Value: paul-acc

1 (user) => ((paul-acc 'rosebud 'withdraw) 50)

;Value: 50

1 (user) => ((peter-acc 'open-sesame 'deposit) 30)

;Value: 80

1 (user) => (define opaque (make-joint paul-acc 'open-sesame 'this-should-not-work?))

;Value: opaque

1 (user) => ((opaque 'this-should-not-work? 'withdraw) 80)

;Value: 0
  #+END_SRC
- For the second version, as it is more tricky than the first one, first we
  should specify what we want. We want that the return account from =make-joint=
  should not share the password state variable with the account, with which
  =make-joint= called; yet want to share balance state variable among the
  two account. To accomplish this, we should have =make-account= with the
  following properties:
  1. We make object with unprotected account.
  2. Given that instance, we can convert that account to protected account with
     password.

  By restructuring =make-account= like this, we can easily implement the
  =make-joint=:
  #+BEGIN_SRC scheme
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (make-protected password)
    (let ((n-incorrect 0))
      (define (protected-dispatch pd m)
        (if (eq? pd password)
            (begin
              (set! n-incorrect 0)      ;reset the counter
              (cond ((eq? m 'withdraw) withdraw)
                    ((eq? m 'deposit) deposit)
                    ((eq? m 'joint) (lambda (new-pw)
                                      ((dispatch 'make-protected) new-pw)))
                    (else (error "Unknown request -- MAKE-PROTECTED"
                                 m))))
            (lambda (x)
              (set! n-incorrect (1+ n-incorrect))
              (if (>= n-incorrect 7)
                  "call-the-cops"
                  "Incorrect password"))))
      protected-dispatch))
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          ((eq? m 'make-protected) make-protected)
          (else (error "Unknown request -- MAKE-ACCOUNT"
                       m))))
  dispatch)

(define (make-account2 balance password)
  (((make-account balance) 'make-protected) password))
  #+END_SRC

  And here is the test:
  #+BEGIN_SRC scheme
1 (user) => (define peter-acc (make-account2 100 'open-sesame))

;Value: peter-acc

1 (user) => (define paul-acc (make-joint peter-acc 'open-sesame 'rosebud))

;Value: paul-acc

1 (user) => ((paul-acc 'rosebud 'withdraw) 50)

;Value: 50

1 (user) => ((peter-acc 'open-sesame 'deposit) 30)

;Value: 80

1 (user) => (define opaque (make-joint paul-acc 'open-sesame 'this-should-not-work?))

;Value: opaque

1 (user) => opaque

;Value: "Incorrect password"
  #+END_SRC


From this exercise, we can think procedure as an object in that notion of modern
programming language. Note that in second version of =make-account=, we used
procedure =dispatch= to call the parent object or the =self= in the modern
programming scheme.
*** Exercise 3.8
Note that to implement such =f=
- We should use assignment expression otherwise it doesn't depend on the
  evaluation order.
- As the arguments of =+= should be number and the procedure =+= is referential
  transparent, the specification can be divided as pure imperative part and pure
  functional part; that is, we can think the evaluation order left to right as
  imperative part:
  #+BEGIN_SRC scheme
evaluate (f 0) => a
evaluate (f 1) => b
  #+END_SRC
  with functional part:
  #+BEGIN_SRC scheme
(+ a b) = 0
  #+END_SRC


Here is the sample implementation such =f=:
#+BEGIN_SRC scheme
(define f
  (let ((x 0))
    (lambda (n)
      (if (= n 0)
          x
          (begin (set! x n) 0)))))
#+END_SRC

Or more imperative-oriented version:
#+BEGIN_SRC scheme
(define f
  (let ((x 0))
    (lambda (n)
      (let ((temp x))
        (begin (set! x n)
               temp)))))
#+END_SRC

Then we can test the interpreter:
#+BEGIN_SRC scheme
1 (user) => (+ (f 0) (f 1))

;Value: 1

,*** reevaluate f

1 (user) => (+ (f 1) (f 0))

;Value: 0
#+END_SRC

So, our interpreter evaluate augend first.
* Modeling with Mutable Data
** Mutable List Structure
*** Exercise 3.16
#+BEGIN_SRC scheme
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x)))))

(define list1 (list 1 2 3))
(define list2
  (let ((tList (list 1 2 3)))
    (let ((tPointer (cdr tList)))
      (set-car! tPointer (cdr tPointer))
      tList)))
(define list3
  (let ((tList (list 1 2 3)))
    (let ((tPointer (cdr tList)))
      (set-car! tPointer (cdr tPointer))
      (set-car! tList (cdr tList))
      tList)))
(define list4
  (let ((tList (list 1 2 3)))
    (set-car! tList tList)))
#+END_SRC
These list are all made up of exactly three pairs; but =count-pairs= returns
differently:
#+BEGIN_SRC scheme
1 (user) => (count-pairs list1)

;Value: 3

1 (user) => (count-pairs list2)

;Value: 4

1 (user) => (count-pairs list3)

;Value: 7

1 (user) => (count-pairs list4)

;Aborting!: maximum recursion depth exceeded
#+END_SRC
*** Exercise 3.17
Then our version should solve the problem Ben Bitdiddle encountered.
We can implement either of the paradigm, functional or imperative.
Functional:
#+BEGIN_SRC scheme
(define (count-pairs x)
  (define (without-loop x visited)
    (if (or (mem? x visited) (not (pair? x)))
        0
        (let ((new-visited (cons x visited)))
          (+ (without-loop (car x) new-visited)
             (without-loop (cdr x) new-visited)
             1))))
  (without-loop x '()))
#+END_SRC

Unfortunately, this won't work:
#+BEGIN_SRC scheme
1 (user) => (count-pairs1 list1)

;Value: 3

1 (user) => (count-pairs1 list2)

;Value: 4

1 (user) => (count-pairs1 list3)

;Value: 7

1 (user) => (count-pairs1 list4)

;Value: 3
#+END_SRC

The problem is that in the recursive branch, each of it doesn't share the
=visited= argument. We can fix it by using local variable with assignment:
#+BEGIN_SRC scheme
(define (count-pairs2 x)
  (define recorded
    (let ((visited '()))
      (lambda (x)
        (if (or (mem? x visited)
                (not (pair? x)))
            0
            (begin (set! visited (cons x visited))
                   (+ (recorded (car x))
                      (recorded (cdr x))
                      1))))))
  (recorded x))
#+END_SRC
As expected, it solved the problem:
#+BEGIN_SRC scheme
1 (user) => (count-pairs2 list1)

;Value: 3

1 (user) => (count-pairs2 list2)

;Value: 3

1 (user) => (count-pairs2 list3)

;Value: 3

1 (user) => (count-pairs2 list4)

;Value: 3
#+END_SRC

Let we revise our functional version. To fix that, we should traverse the tree
structure like depth first search; we one of the branch should wait until the
other branch terminate its search. We should access the =visited= argument from
returned value of one branch to propagate that argument to other branch. By
returning tuple that contains =visited= with the counter, we can do the right thing:
#+BEGIN_SRC scheme
(define (count-pairs1 x)
  (define (without-loop x visited)
    (if (or (mem? x visited) (not (pair? x)))
        (list 0 visited)
        (let ((result-of-one
               (without-loop (cdr x) (cons x visited))))
          (let ((result-of-the-other
                 (without-loop (car x) (cadr result-of-one))))
            (list (+ (car result-of-one)
                     (car result-of-the-other)
                     1)
                  (cadr result-of-the-other))))))
  (car (without-loop x '())))
#+END_SRC
#+BEGIN_SRC scheme
1 (user) => (count-pairs1 list1)

;Value: 3

1 (user) => (count-pairs1 list2)

;Value: 3

1 (user) => (count-pairs1 list3)

;Value: 3

1 (user) => (count-pairs1 list4)

;Value: 3
#+END_SRC

Implicitly, we used the induction on depth of =x= to construct this algorithm.
*** Exercise 3.18
This algorithm should look like that of previous exercise. Let we first code the
test:
#+BEGIN_SRC scheme
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

(define list5 (make-cycle (list 1 2 3 4)))
(define list6 (append '(a b c d) list5))

(cycle? list1)
#f
(cycle? list2)
#f
(cycle? list3)
#f
(cycle? list4)
#f
(cycle? list5)
#t
(cycle? list6)
#t
(cycle? list7)
#t
#+END_SRC

Here is the code that exploits local state variable:
#+BEGIN_SRC scheme
(define (cycle? x)
  (define iter
    (let ((visited '()))
      (lambda (x)
        (cond ((null? x) false)
              ((mem? x visited) true)
              (else
               (set! visited (cons x visited))
               (iter (cdr x)))))))
  (iter x))
#+END_SRC
... And test:
#+BEGIN_SRC scheme
1 (user) => (cycle? list1)

;Value: #f

1 (user) => (cycle? list2)

;Value: #f

1 (user) => (cycle? list3)

;Value: #f

1 (user) => (cycle? list4)

;Value: #f

1 (user) => (cycle? list5)

;Value: #t

1 (user) => (cycle? list6)

;Value: #t

1 (user) => (cycle? list7)

;Value: #t
#+END_SRC

As we wrote our test to be as exhaustive as possible, we can be quite confidence
about our program: We tested the extremum case such as =list7= with normal case
=list6= and =list5=.
*** Exercise 3.19
The keyword is *constant amount of space*; it implies we should code our code
iterative. And also since we operate on list, we need to fully understand what
the properties list structure possesses. If we focus on the convention that we
traverse list structure one way only-- =cdr= ing down, we could come up with the
"very clever" idea as noted in text book:
1. Send one person to stride one step further by =cdr= in each iteration where
2. Send the other one until the place where the first person stand checking
   whether the each pointer is same as of first person.
3. If it is, and if the two pointer located differently in examining list, then
   it is cycled list.
4. otherwise second person stride one step further.
5. If the second one reach the first one without trouble then first one stride
   one step further.
6. Loop from 2 to 5 until the first one reach nil pointer. If it reaches nil
   pointer then return false.


As this algorithm inherently evolve as iterative process, we got the algorithm
that we wanted. To implement the check algorithm that whether two pointer is
same but in different place, we could assign each pointer to number, namely the
step needed to get reached to that place. However, although it is subtle, this
strategy doesn't assure this assigned number doesn't grow in space: It would be
consume more space when the step get huge number. To cope with this situation we
can exploit the observation that, as our program return as soon as it found the
first cycle point, the different place but same pointer should have different
previous place where visited just before the current place.

Here is the code:
#+BEGIN_SRC scheme
(define (cycle1? x)
  (define first-man
    (let ((prev '()))
      (lambda (current)
        (define second-man
          (let ((prev2 '()))
            (lambda (current2)
              (if (eq? current current2)
                  (eq? prev prev2)
                  (begin (set! prev2 current2)
                         (second-man (cdr current2)))))))
        (cond ((null? current) false)
              ((not (second-man x)) true)
              (else
               (set! prev current)
               (first-man (cdr current)))))))
  (first-man x))
#+END_SRC

And the test:
#+BEGIN_SRC scheme
1 (user) => (cycle1? list1)

;Value: #f

1 (user) => (cycle1? list2)

;Value: #f

1 (user) => (cycle1? list3)

;Value: #f

1 (user) => (cycle1? list4)

;Value: #f

1 (user) => (cycle1? list5)

;Value: #t

1 (user) => (cycle1? list6)

;Value: #t

1 (user) => (cycle1? list7)

;Value: #t
#+END_SRC

Or functional version:
#+BEGIN_SRC scheme
(define (cycle2? x)
  (define (first-man prev current)
    (define (second-man prev2 current2)
      (if (eq? current current2)
          (eq? prev prev2)
          (second-man current2 (cdr current2))))
    (cond ((null? current) false)
          ((not (second-man '() x)) true)
          (else
           (first-man current (cdr current)))))
  (first-man '() x))
#+END_SRC

We could use less =define= notation:
#+BEGIN_SRC scheme
(define (cycle3? x)
  (let ((first-man
         (lambda (prev current)
           (let ((second-man
                  (lambda (prev2 current2)
                    (if (eq? current current2)
                        (eq? prev prev2)
                        (second-man current2 (cdr current2))))))
             (cond ((null? current) false)
                   ((not (second-man '() x)) true)
                   (else
                    (first-man current (cdr current))))))))
    (first-man '() x)))
#+END_SRC

Unfortunately, this won't work:
#+BEGIN_SRC scheme
1 (user) => (cycle3? list7)

;Unbound variable: first-man
#+END_SRC

To understand why, we can desugar =(let ((<var> <val>)) body)= expression as
=((lambda (<var>) body) <val>)=: The =lambda= expression in the first =let=
notation, there is no way to reference =first-man= in the body of =lambda=
expression of right-hand side; we need define to abstract this.
*** Lecture 5A: Assignment, State, and Side-effects
I've got quite intrigued by that if we can replace all the =set!= expression
with =define= ? (well, we supposed to not to do)

Let's experiment:
#+BEGIN_SRC scheme
1 (user) => (define t 1)

;Value: t

1 (user) => (define t (+ t 1))

;Value: t

1 (user) => t

;Value: 2
#+END_SRC

Seems like we could replace the use of =set!=; but:
#+BEGIN_SRC scheme
(define test
  (let ((t 1))
    (define t (+ t 1))
    t))
#+END_SRC

This definition won't work:
#+BEGIN_SRC scheme
1 (user) => (define test
  (let ((t 1))
    (define t (+ t 1))
    t))

;Unassigned variable: t
#+END_SRC

Do more experiment to grasp what's going on here:
#+BEGIN_SRC scheme
1 (user) => (define test
  (let ((t 1))
    (define t1 (+ t 1))
    (define t1 (+ t1 1))
    t))

;duplicate internal definitions for (#[uninterned-symbol 38 t1]) in |#[let-procedure]|
#+END_SRC

From these sequence of experiments, we can deduce that the effect of =define=,
which is similar with =set!=, is only allowed to REPL; in other words, only in
global environment. Within the evaluation model we learned so far, we can not
understand fully the behavior of =define=.

In lecture, professor start to define what means by the word "bound":
#+BEGIN_QUOTE
We say that a variable, V, is "bound in an expression", E, if the meaning of E
is unchanged by the uniform replacement of a variable, W, not occurring in E,
for every occurrence of V in E.
#+END_QUOTE

And also "free variable":
#+BEGIN_QUOTE
We say that a variable, V, is "free in and expression", E, if the meaning of E
is changed by the uniform replacement of a variable, W, not occurring in E, for
every occurrence of V in E.
#+END_QUOTE

By consequence of this, we have concept named "scope":
#+BEGIN_QUOTE
If x is a bound variable in E then there is a lambda expression where it is
bound. We call the list of formal parameters of the lambda expression the "bound
variable list" and we say that the lambda expression "binds" the variables
"declared" in its bound variable list. In addition, those parts of the
expression where a variable has a value defined by the lambda expression which
binds it is called the "scope" of the variable.
#+END_QUOTE

The evaluation rule 1:
#+BEGIN_QUOTE
A procedure object is applied to a set of arguments by constructing a frame,
binding the formal parameters of the procedure to the actual arguments of the
call, and then evaluating the body of the procedure in the context of the new
environment constructed. The new fram has as its enclosing environment the
environment part of the procedure object being applied.
#+END_QUOTE

The evaluation rule 2:
#+BEGIN_QUOTE
A lambda-expression is evaluated relative to a given environment as follows: A
new procedure object is formed, combining the text (code) of the lambda
expression with a pointer to the environment of evaluation.
#+END_QUOTE

The terminologis about actions and identity:
#+BEGIN_QUOTE
We say that an action, A, had an effect on an object, X, (or equivalently, that
X was changed by A) if some property, P, which was true of X before A became
false of X after A.

We say that two objects, X and Y, are the same if any action which has an effect
on X has the same effect on Y.
#+END_QUOTE

Professor end the lecture with following quote:

Mr. Gilbert and Sullivan said,
#+BEGIN_QUOTE
Things are seldom what they seem, 
Skim milk masquerades as cream...
#+END_QUOTE

He wanted to implies, I guess, the stream concept that would come up with following lecture; 
if we consider the meaning of quote in this specific context but it will convolve a lot more
profound meaning I think.
** Representing Queues
As we do usually, we build our data abstraction for our queue implementation:
- a constructor :: =(make-queue)= returns an empty queue.
- two selectors ::
  - =(empty-queue? <queue>)= tests if the queue is empty.
  - =(front-queue <queue>)= returns the object at the front of the queue,
    signaling an error if the queue is empty; it does not modify the queue.
- two mutators ::
  - =(insert-queue! <queue> <item>)= inserts the item at the front of the
    queue and returns the modified queue as its value.
  - =(delete-queue! <queue>)= removes the item at the front of the queue and
    returns the modified queue as its value, signaling an error if the queue is
    empty before the deletion.


For the implementation restriction, all the operation should require \Theta (1) steps.

In text book, they install additional layer, between manipulating queue
representation and implementing queue representation using list structure:
#+BEGIN_SRC scheme
;;; wrapping around the queue representation
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))

;;; selector -- predicate
(define (empty-queue? queue) (null? (front-ptr queue)))

;;; constructor
(define (make-queue) (cons '() '()))

;;; selector -- first element
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))

;;; mutator -- insert item
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue)
                     new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))

;;; mutator -- delete item
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue)))
#+END_SRC

*** Exercise 3.21
Eva Lu Ator denotes that it is just reachable from two different pointer not
that =insert-queue= inserts item twice; recall the exercise [[Exercise 3.16][3.16]], where all the
list has exactly three pairs in it but represented differently. (in both Ben
Bitdiddle's =count-pairs= and Lisp printer)

Here, to understand how the Lisp printer works, we implement the Lisp printer.
To implement that, we use nested induction -- induction on depth of expression
and within that, we run induction on width of expression. To deduce the
specification of Lisp printer, we play with Lisp interpreter for a while:
#+BEGIN_SRC scheme
1 (user) => (cons 1 2)

;Value: (1 . 2)

1 (user) => (list 1 2)

;Value: (1 2)

1 (user) => (cons 1 (cons 2 3))

;Value: (1 2 . 3)

1 (user) => (cons (cons 1 2) 3)

;Value: ((1 . 2) . 3)

1 (user) => (cons 1 (cons 2 '()))

;Value: (1 2)
#+END_SRC

And here is the implementation:
#+BEGIN_SRC scheme
(define (print exp)
  (cond ((pair? exp) (print-exp exp))
        (else                           ;not compound
         (display exp))))

(define (print-exp exp)
  (define (iter exp)
    (cond ((null? exp))
          ((pair? exp)
           (display " ")
           (print (car exp))
           (iter (cdr exp)))
          (else
           (display " . ")
           (print exp))))
  (display "(")
  (print (car exp))
  (iter (cdr exp))
  (display ")"))
#+END_SRC

Here is the test:
#+BEGIN_SRC scheme
1 (user) => (print (cons 1 2))
(1 . 2)
;Unspecified return value

1 (user) => (print (list 1 2))
(1 2)
;Unspecified return value

1 (user) => (print (cons 1 (cons 2 3)))
(1 2 . 3)
;Unspecified return value

1 (user) => (print (cons (cons 1 2) 3))
((1 . 2) . 3)
;Unspecified return value

1 (user) => (print (cons 1 (cons 2 '())))
(1 2)
;Unspecified return value
#+END_SRC

Then here is the examples for what the Ben Bitdiddle misunderstood:
#+BEGIN_SRC scheme
1 (user) => (print list3)
(((3) 3) (3) 3)
;Unspecified return value

1 (user) => (print list2)
(1 (3) 3)
;Unspecified return value
#+END_SRC

Consequently we can conclude that the Lisp printer display all the element
recursively following given pointer.

Actually, what version I use for now as scheme interpreter is smarter than that:
#+BEGIN_SRC scheme
(define q1 (make-queue))

;Value: q1

(insert-queue! q1 'a)

;Value: (#0=(a) . #0#)

(insert-queue! q1 'b)

;Value: ((a . #0=(b)) . #0#)

(delete-queue! q1)

;Value: (#0=(b) . #0#)

(delete-queue! q1)

;Value: (() b)
#+END_SRC

It recognize the same pointer using, I guess, memorize all the pointer it
encountered. But for now, let we stick the old version of printer in text book.

Return to our task, =print-queue= is really simple: Just print following the
first pointer of queue:
#+BEGIN_SRC scheme
(define (print-queue queue)
  (display (front-ptr queue)))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
1 (user) => (define q1 (make-queue))
;Value: q1

1 (user) => (print-queue (insert-queue! q1 'a))
(a)
;Unspecified return value

1 (user) => (print-queue (insert-queue! q1 'b))
(a b)
;Unspecified return value

1 (user) => (print-queue (delete-queue! q1))
(b)
;Unspecified return value

1 (user) => (print-queue (delete-queue! q1))
()
;Unspecified return value
#+END_SRC

Ben Bitdiddle should satisfy what =print-queue= display.
*** Exercise 3.22
We can map our previous implementation to message passing style by
- =(front-ptr queue)= \to =front-ptr= in =make-queue=
- =(rear-ptr queue)= \to =rear-ptr= in =make-queue=
- ...


It get boring to jot down all the relation; let I just show the result:
#+BEGIN_SRC scheme
(define (make-queue2)
  (let ((front-ptr '())
        (rear-ptr '()))
    ;; selector -- predicate
    (define (empty-queue?) (null? front-ptr))
    ;; selector -- first item
    (define (front-queue)
      (if (empty-queue?)
          (error "FRONT called with an empty queue -- MAKE-QUEUE2" dispatch)
          (car front-ptr)))
    (define (insert-queue! item)
      (let ((new-pair (cons item '())))
        (cond ((empty-queue?)
               (set! front-ptr new-pair)
               (set! rear-ptr new-pair)
               dispatch)
              (else
               (set-cdr! rear-ptr new-pair)
               (set! rear-ptr new-pair)
               dispatch))))
    (define (delete-queue!)
      (cond ((empty-queue?)
             (error "DELETE! called with an empty queue -- MAKE-QUEUE2" dispatch))
            (else
             (set! front-ptr (cdr front-ptr))
             dispatch)))
    (define (dispatch m)
      (cond ((eq? m 'empty-queue?) empty-queue?)
            ((eq? m 'front-queue) front-queue)
            ((eq? m 'insert-queue!) insert-queue!)
            ((eq? m 'delete-queue!) delete-queue!)
            (else
             (error "Unknown request -- MAKE-QUEUE2" m))))
    dispatch))
#+END_SRC

And here is how we should use:
#+BEGIN_SRC scheme
1 (user) => (define q1 (make-queue2))

;Value: q1

1 (user) => ((q1 'insert-queue!) 'a)

;Value: #[compound-procedure 44 dispatch]

1 (user) => ((q1 'front-queue))

;Value: a

1 (user) => ((q1 'insert-queue!) 'b)

;Value: #[compound-procedure 44 dispatch]

1 (user) => ((q1 'front-queue))

;Value: a

1 (user) => ((q1 'delete-queue!))

;Value: #[compound-procedure 44 dispatch]

1 (user) => ((q1 'front-queue))

;Value: b

1 (user) => ((q1 'delete-queue!))

;Value: #[compound-procedure 44 dispatch]

1 (user) => ((q1 'front-queue))

;FRONT called with an empty queue -- MAKE-QUEUE2 #[compound-procedure 44 dispatch]
#+END_SRC

We can integrate =print-queue= to this procedure object:
#+BEGIN_SRC scheme
(define (make-queue2)
  (let ((front-ptr '())
        (rear-ptr '()))
    ;; selector -- predicate
    (define (empty-queue?) (null? front-ptr))
    ;; selector -- first item
    (define (front-queue)
      (if (empty-queue?)
          (error "FRONT called with an empty queue -- MAKE-QUEUE2" dispatch)
          (car front-ptr)))
    (define (insert-queue! item)
      (let ((new-pair (cons item '())))
        (cond ((empty-queue?)
               (set! front-ptr new-pair)
               (set! rear-ptr new-pair)
               (print-queue)
               dispatch)
              (else
               (set-cdr! rear-ptr new-pair)
               (set! rear-ptr new-pair)
               (print-queue)
               dispatch))))
    (define (delete-queue!)
      (cond ((empty-queue?)
             (error "DELETE! called with an empty queue -- MAKE-QUEUE2" dispatch))
            (else
             (set! front-ptr (cdr front-ptr))
             (print-queue)
             dispatch)))
    (define (print-queue) (display front-ptr))
    (define (dispatch m)
      (cond ((eq? m 'empty-queue?) empty-queue?)
            ((eq? m 'front-queue) front-queue)
            ((eq? m 'insert-queue!) insert-queue!)
            ((eq? m 'delete-queue!) delete-queue!)
            (else
             (error "Unknown request -- MAKE-QUEUE2" m))))
    dispatch))
#+END_SRC

#+BEGIN_SRC scheme
1 (user) => ((q1 'insert-queue!) 'a)
(a)
;Value: #[compound-procedure 45 dispatch]

1 (user) => ((q1 'insert-queue!) 'b)
(a b)
;Value: #[compound-procedure 45 dispatch]

1 (user) => ((q1 'delete-queue!))
(b)
;Value: #[compound-procedure 45 dispatch]

1 (user) => ((q1 'delete-queue!))
()
;Value: #[compound-procedure 45 dispatch]
#+END_SRC

Note that with this local state paradigm, message passing style is more
succinctly encode the specification than the representation using concrete data
structure-- here pair.

*** Exercise 3.23
Not only to traverse one way-- =cdr=, we need means to traverse the opposite
way to implement /deque/. As we requested in implementation of queue, we need to
implement all the operation in \Theta (1) steps.

Here we devise new data structure not only /deque/, also /node/ with which we
represent /deque/. /Node/ has many analogy with primitive data structure, pair;
it construct one chunk using several pointers together, but /node/ has three
pointers in one chunk whereas pair has two pointers in it.

Here is the specification for /node/:
- constructor :: =(make-node prev item next)= returns node that has three
     pointers, each of which points =prev=, =item=, =next=, respectively.
- selectors ::
     - =(prev node)= returns first pointer.
     - =(item node)= returns second pointer.
     - =(next node)= returns last pointer.
- mutators ::
     - =(set-prev! node new-prev)= resets its pointer that points =prev= to =new-prev=.
     - =(set-item! node new-item)= resets its pointer that points =item= to =new-item=.
     - =(set-next! node new-next)= resets its pointer that points =next= to =new-next=.


Here is the implementation for /node/:
#+BEGIN_SRC scheme
;;; constructor
(define (make-node prev item next)
  (define (set-prev! new-prev) (set! prev new-prev))
  (define (set-item! new-item) (set! item new-item))
  (define (set-next! new-next) (set! next new-next))
  (define (dispatch m)
    (cond ((eq? m 'prev) prev)
          ((eq? m 'item) item)
          ((eq? m 'next) next)
          ((eq? m 'set-prev!) set-prev!)
          ((eq? m 'set-item!) set-item!)
          ((eq? m 'set-next!) set-next!)
          (else
           (error "Unknown request -- MAKE-NODE" m))))
  dispatch)

;;; selectors
(define (prev node) (node 'prev))
(define (item node) (node 'item))
(define (next node) (node 'next))

;;; mutators
(define (set-prev! node new-prev) ((node 'set-prev!) new-prev))
(define (set-item! node new-item) ((node 'set-item!) new-item))
(define (set-next! node new-next) ((node 'set-next!) new-next))
#+END_SRC

Then we can implement /deque/ using the analogy with /queue/. During
implementing node, queue, and the other massage passing style code, I got
intrigued by how am I going to implement the conventional array in scheme using
massage passing style; it should access its element with \Theta (1) steps. So
far, in message passing style, we dealt with only fixed sized argument list.

One way to deal with unspecified argument list is use the primitive procedure
syntax, e.g. =(x y . z)=; but the problem of this approach is that to access the
contents that stored in =z=, as it is list, needs \Theta (n) steps where n is
the size of =z=. To deal with this unfortunate, if we believe that accessing any
variable in the frame require only \Theta(1) steps, we need to register all the
argument of =z= (with =x= and =y= also) current environment of callee, for which
we don't have any method.

Let alone that problem let we conclude our original task. First let test our
node code:
#+BEGIN_SRC scheme
1 (user) => (define n (make-node '() 2 '()))

;Value: n

1 (user) => (define n2 (make-node n 3 '()))

;Value: n2

1 (user) => (item n)

;Value: 2

1 (user) => (item n2)

;Value: 3

1 (user) => (item (prev n2))

;Value: 2

1 (user) => (define n3 (make-node '() 4 '()))

;Value: n3

1 (user) => (set-next! n2 n3)

;Value: ()

1 (user) => (set-prev! n3 n2)

;Value: ()

1 (user) => (item (prev (prev n3)))

;Value: 2
#+END_SRC

And this is straightforward implementation for /deque/:
#+BEGIN_SRC scheme
;; constructor
(define (make-deque)
  (let ((front-ptr '())
        (rear-ptr '()))
    ;; selector -- predicate
    (define (empty-deque?) (or (null? front-ptr)
                               (null? rear-ptr)))
    ;; selector -- first item
    (define (front-deque)
      (if (empty-deque?)
          (error "FRONT called with an empty deque -- MAKE-DEQUE" dispatch)
          (item front-ptr)))
    (define (rear-deque)
      (if (empty-deque?)
          (error "REAR called with an empty deque -- MAKE-DEQUE" dispatch)
          (item rear-ptr)))
    (define (rear-insert-deque! item)
      (let ((new-node (make-node '() item '())))
        (cond ((empty-deque?)
               (set! front-ptr new-node)
               (set! rear-ptr new-node)
               dispatch)
              (else
               (set-next! rear-ptr new-node)
               (set! rear-ptr new-node)
               dispatch))))
    (define (front-insert-deque! item)
      (let ((new-node (make-node '() item '())))
        (cond ((empty-deque?)
               (set! front-ptr new-node)
               (set! rear-ptr new-node)
               dispatch)
              (else
               (set-prev! front-ptr new-node)
               (set! front-ptr new-node)
               dispatch))))
    (define (front-delete-deque!)
      (cond ((empty-deque?)
             (error "FRONT-DELETE! called with an empty deque -- MAKE-DEQUE" dispatch))
            (else
             (set! front-ptr (next front-ptr))
             dispatch)))
    (define (rear-delete-deque!)
      (cond ((empty-deque?)
             (error "FRONT-DELETE! called with an empty deque -- MAKE-DEQUE" dispatch))
            (else
             (set! rear-ptr (prev rear-ptr))
             dispatch)))
    (define (dispatch m)
      (cond ((eq? m 'empty-deque?) empty-deque?)
            ((eq? m 'front-deque) front-deque)
            ((eq? m 'rear-deque) rear-deque)
            ((eq? m 'front-insert-deque!) front-insert-deque!)
            ((eq? m 'rear-insert-deque!) rear-insert-deque!)
            ((eq? m 'front-delete-deque!) front-delete-deque!)
            ((eq? m 'rear-delete-deque!) rear-delete-deque!)
            (else
             (error "Unknown request -- MAKE-DEQUE" m))))
    dispatch))
;; selector -- predicate
(define (empty-deque? deque) ((deque 'empty-deque?)))
;; selector -- first item
(define (front-deque deque) ((deque 'front-deque)))
;; selector -- last item
(define (rear-deque deque) ((deque 'rear-deque)))
;; mutator -- insert front
(define (front-insert-deque! deque item) ((deque 'front-insert-deque!) item))
;; mutator -- insert rear
(define (rear-insert-deque! deque item) ((deque 'rear-insert-deque!) item))
;; mutator -- delete first
(define (front-delete-deque! deque) ((deque 'front-delete-deque!)))
;; mutator -- delete last
(define (rear-delete-deque! deque) ((deque 'rear-delete-deque!)))
#+END_SRC

Test for /deque/:
#+BEGIN_SRC scheme
1 (user) => (define d (make-deque))

;Value: d

1 (user) => (empty-deque? d)

;Value: #t

1 (user) => (front-insert-deque! d 'a)

;Value: #[compound-procedure 38 dispatch]

1 (user) => (rear-deque d)

;Value: a

1 (user) => (front-deque d)

;Value: a

1 (user) => (rear-insert-deque! d 'b)

;Value: #[compound-procedure 38 dispatch]

1 (user) => (rear-deque d)

;Value: b

1 (user) => (front-deque d)

;Value: a

1 (user) => (front-delete-deque! d)

;Value: #[compound-procedure 38 dispatch]

1 (user) => (front-delete-deque! d)

;Value: #[compound-procedure 38 dispatch]

1 (user) => (empty-deque? d)

;Value: #t
#+END_SRC
** Representing Tables
In chapter 2, we exploited a lot the data structure named /table/. /Table/ was
the backbone our data-directed programming scheme. Table is so general data
structure to the extent many of the "practical" programming languages provides
table as one of the primitive data structure. In Lisp, we don't have any table
like structure for granted. But we can implement that data structure by our own
if we allowed to use assignment.

Then what is table? What data structure we think as table? Here we define what
we think as table informally:
- We should be able to retrieve the registered value in the table by its key.
- We should be able to insert new entry, which contains key value pair-like
  structure, to the table.


More formally table should satisfy following axioms:
- =(lookup key (begin (insert! (make-entry key value) table) table))=
  returns =value=.


What value =(lookup not-in-the-table table)= should returns is implementation
detail. The implementor can choose whatever value we want unless the specifier
doesn't specify to that extent.

For the implementation detail, we need to use /headed/ list as the backbone of
our table to insert given entry to the given table; without this, we couldn't
locate the locus of the table's contents.

Here is the sample implementation in text book:
#+BEGIN_SRC scheme
;;; constructor
(define (make-table)
  (list '*table*))

;;; selector + predicate
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
;;; dependency
;;; we represent contents of table as A-list
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))

;;; mutator
(define (insert! key value table)
  (let ((record (assoc key records)))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value)
                        (cdr table)))))
  'ok)
#+END_SRC

*** Two-dimensional tables
We can extend one-dimensional table above to two-dimensional table by observing
that each value of one-dimensional table could be A-list. As the key of the
subtables performs as header, we don't need any auxiliary header as we did in
one-dimensional table.

As we noted above, all the left is to implement two dimensional lookup procedure
and insert accordingly:
#+BEGIN_SRC scheme
(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))

(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
#+END_SRC
*** Creating local tables
We can convert our concrete representation to message-passing:
#+BEGIN_SRC scheme
(define (make-table2)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))
#+END_SRC
*** Exercise 3.24
It is way too easy to implement we get what we want by slightly amending above
implementation:
#+BEGIN_SRC scheme
(define (make-table3 same-key?)

  (define (assoc key records)
    (cond ((null? records) false)
          ((same-key? key (caar records)) (car records))
          (else (assoc key (cdr records)))))

  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))
#+END_SRC
*** Exercise 3.25
It is equivalent to prove the behavior of the specification: Induction on depth
of the table. If we persist with the A-list representation as before, and also
assume that all the generalized table structured appropriately, we can easily
extend the previous table to generalized one:
#+BEGIN_SRC scheme
(define (lookup key-list table)
  (cond ((null? key-list)
         (error "LOOKUP called with empty key-list"))
        ((null? (cdr key-list))
         (let ((record (assoc (car key-list) (cdr table))))
           (if record
               (cdr record)
               false)))
        (else
         (let ((subtable (assoc (car key-list) (cdr table))))
           (if subtable
               (lookup (cdr key-list table))
               false)))))

(define (insert! key-list value table)
  (cond ((null? key-list)
         (error "INSERT! called with empty key-list"))
        ((null? (cdr key-list))
         (let ((record (assoc (car key-list) records)))
           (if record
               (set-cdr! record value)
               (set-cdr! table
                         (cons (cons (car key-list) value)
                               (cdr table))))))
        (else
         (let ((subtable (assoc (car key-list) (cdr table))))
           (if subtable
               (insert! (cdr key-list) value table)
               (set-cdr! table
                         (cons (make-table-with key-list value)
                               (cdr table)))))))
  'ok)

(define (make-table-with key-list value)
  (if (null? (cdr key-list))
      (cons (car key-list) value)
      (list (car key-list)
            (make-table-with (cdr key-list) value))))
#+END_SRC

I didn't tested it but it would work only if we lookup the table that contains
entry with key list with which we lookup. Unfortunately, it is huge bug, since
the user of lookup doesn't know whether the table has such entry. To fix this,
we make our table using the strategy learned from lecture, [[youtube:bWJlEevfp1E?list=PL7BcsI5ueSNFPCEisbaoQ0kXIDX9rR5FF][Abstract Data Type]].

In previous exercise, we only dealt with table of fixed dimension; we don't need
to check whether the value of given entry is table or not. Here we don't know
fore hand the dimension of table, and to deal with such situation, we treat
table as special value of one dimensional table. By induction on the depth on
the dimension of table, our result table would handle the unspecified dimension
of table without any trouble.

At our disposal, we have two candidates for implementation of this:
message-passing style with local state or dispatch on data type with concrete
data structure.

Here we first try out the message-passing style:
#+BEGIN_SRC scheme
;; constructor
(define (make-table4)
  (let ((local-table (list '*table*)))
    (define (lookup-internal key-list)
      (let ((record (assoc (car key-list) (cdr local-table))))
        (if record
            (let ((value (cdr record)))
              (cond ((null? (cdr key-list)) value)
                    ((table? value)
                     (lookup (cdr key-list) value))
                    (else false)))
            false)))
    (define (insert-internal! key-list value)
      (let ((record (assoc (car key-list) (cdr local-table))))
        (if record
            (let ((value (cdr record)))
              (cond ((null? (cdr key-list)) (set-cdr! record value))
                    ((table? value)
                     (insert! (cdr key-list) value))))
            (set-cdr! local-table
                      (cons (make-table-with key-list value)
                            (cdr local-table)))))
      'ok)
    (define (make-table-with key-list value)
      (if (null? (cdr key-list))
          (cons (car key-list) value)
          (let ((tbl (make-table4)))
            (insert! (cdr key-list)
                     value
                     tbl)
            (cons (car key-list) tbl))))
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup-internal)
            ((eq? m 'insert-proc!) insert-internal!)
            ((eq? m 'table?) true)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

;; selector -- predicate
(define (table? t) (t 'table?))
(define (lookup ks t) ((t 'lookup-proc) ks))

;; mutator
(define (insert! ks v t) ((t 'insert-proc!) ks v))
#+END_SRC

Then test:
#+BEGIN_SRC scheme
;; constructor
1 (user) => (define tbl (make-table4))

;Value: tbl

;; predicate
1 (user) => (table? tbl)

;Value: #t

;; mutator
1 (user) => (insert! '(1 2 3 4) 5 tbl)

;Value: ok

;; selector
1 (user) => (lookup '(1 2 3 4) tbl)

;Value: 5

1 (user) => (lookup '(1) tbl)

;Value: #[compound-procedure 39 dispatch]

1 (user) => (lookup '(2 3 4) (lookup '(1) tbl))

;Value: 5
#+END_SRC

The another way:
#+BEGIN_SRC scheme
;; type tag
(define table-tag '*table*)
;; constructor
(define (make-table5)
  (list table-tag))

;; selector -- predicate
(define (table? t)
  (and (pair? t) (eq? (car t) table-tag)))

;; selector
(define (lookup key-list tbl)
  (let ((record (assoc (car key-list) (cdr tbl))))
    (if record
        (let ((value (cdr record)))
          (cond ((null? (cdr key-list)) value)
                ((table? value)
                 (lookup (cdr key-list) value))
                (else false)))
        false)))

;; mutator
(define (insert! key-list value tbl)
  (let ((record (assoc (car key-list) (cdr tbl))))
    (if record
        (let ((value (cdr record)))
          (cond ((null? (cdr key-list)) (set-cdr! record value))
                ((table? value)
                 (insert! (cdr key-list) value))))
        (set-cdr! tbl
                  (cons (make-table-with key-list value)
                        (cdr tbl)))))
  'ok)

(define (make-table-with ks v)
  (if (null? (cdr ks))
      (cons (car ks) v)
      ;; (let ((tbl (make-table5)))
      ;;       (insert! (cdr key-list)
      ;;                value
      ;;                tbl)
      ;;       (cons (car key-list) tbl))))
      (cons (car ks) (list table-tag    ;more efficiently
                           (make-table-with (cdr ks) v)))))
#+END_SRC

To design =make-table-with=, I've exploit the opaque type. And here is the test:
#+BEGIN_SRC scheme
1 (user) => (define tbl (make-table5))

;Value: tbl

1 (user) => (table? tbl)

;Value: #t

1 (user) => (insert! '(1 2 3 4) 5 tbl)

;Value: ok

1 (user) => (lookup '(1 2 3 4) tbl)

;Value: 5

1 (user) => (lookup '(2 3 4) (lookup '(1) tbl))

;Value: 5
#+END_SRC

Note that the latter one is more efficient than former one; also seems cleaner.
Object-oriented paradigm do not always win.
